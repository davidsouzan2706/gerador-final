<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros Virais v109 - A Versão da Vitória</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF para geração de PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Fontes Google - Carlito para legibilidade -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Carlito:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        /* ========================================================== */
        /* ==================== ESTILOS GERAIS ==================== */
        /* ========================================================== */
        /* Variáveis CSS para cores consistentes e fácil manutenção */
        :root {
            --primary-color: #4f46e5; /* Indigo-600 */
            --primary-hover: #4338ca; /* Indigo-700 */
            --secondary-bg: #e0e7ff; /* Indigo-100 */
            --secondary-text: #4338ca; /* Indigo-700 */
            --secondary-hover: #c7d2fe; /* Indigo-200 */
            --success-color: #10B981; /* Green-500 */
            --success-hover: #059669; /* Green-600 */
            --text-dark: #1f2937; /* Gray-800 */
            --text-medium: #4b5563; /* Gray-600 */
            --text-light: #6b7280; /* Gray-500 */
            --bg-light: #f9fafb; /* Gray-50 */
            --border-light: #e5e7eb; /* Gray-200 */
        }

        body {
            font-family: 'Carlito', sans-serif;
            background-color: #f0f2f5;
            color: var(--text-dark); /* Cor do texto padrão */
        }
        .container {
            max-width: 1024px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
        }
        .input-group label {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.5rem;
            display: block;
        }
        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1.5px solid var(--border-light);
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            background-color: var(--bg-light);
            color: var(--text-dark);
        }
        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
            background-color: #ffffff;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: inline-flex; /* Para alinhar texto e spinner/ícone */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: none;
            white-space: nowrap; /* Evita que o texto do botão quebre linha */
        }
        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-primary {
            background-color: var(--primary-color);
            color: #ffffff;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }
        .btn-secondary {
            background-color: var(--secondary-bg);
            color: var(--secondary-text);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--secondary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.15);
        }
        .btn-success {
            background-color: var(--success-color) !important; /* !important para sobrescrever */
            color: #ffffff !important;
        }
        .btn-success:hover:not(:disabled) {
            background-color: var(--success-hover) !important;
        }

        /* Loading Spinner */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        .btn-secondary .loading-spinner {
            border: 4px solid rgba(67, 56, 202, 0.2);
            border-left-color: var(--secondary-text);
        }
        .loading-spinner.hidden { display: none; }
        .button-text.hidden { display: none; }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Icone de Conclusão */
        /* REMOVIDO: .completion-icon { ... } */
        /* REMOVIDO: .completion-icon.hidden { display: none; } */

        /* ========================================================== */
        /* ==================== UI MELHORADA ====================== */
        /* ========================================================== */
        .accordion-item {
            border: 1px solid var(--border-light);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden; /* Garante que o conteúdo escondido não vaze */
            background-color: var(--bg-light);
        }
        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            cursor: pointer;
            user-select: none; /* Impede seleção de texto ao clicar */
        }
        .header-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .header-buttons {
            display: flex;
            gap: 0.5rem; /* Espaçamento entre os botões de ação */
        }
        .accordion-header h3 {
            margin-bottom: 0; /* Remove a margem padrão do h3 */
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-dark);
        }
        .accordion-arrow {
            transition: transform 0.3s ease-in-out;
        }
        .accordion-arrow.open {
            transform: rotate(180deg);
        }
        .accordion-body {
            max-height: 0; /* Escondido por padrão */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
            padding: 0 1.5rem; /* Padding vertical zero quando fechado */
        }
        .accordion-body.open {
            max-height: 5000px; /* Valor grande para "abrir" */
            padding: 1rem 1.5rem 1.5rem; /* Padding quando aberto */
        }
        .accordion-body p[contenteditable="true"] {
            outline: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: box-shadow 0.2s, background-color 0.2s;
        }
        .accordion-body p[contenteditable="true"]:focus {
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
            background-color: #eef2ff; /* Fundo levemente azulado ao editar */
        }

        /* Botões de Copiar e Re-gerar dentro das seções */
        .copy-btn, .regenerate-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            white-space: nowrap;
        }
        .copy-btn {
            background-color: var(--primary-color);
            color: #ffffff;
        }
        .copy-btn:hover {
            background-color: var(--primary-hover);
        }
        .regenerate-btn {
            background-color: var(--secondary-bg);
            color: var(--secondary-text);
        }
        .regenerate-btn:hover {
            background-color: var(--secondary-hover);
        }
        
        /* Seções de Prompts e Trilha Sonora */
        .section-prompts, .section-soundtrack {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #d1d5db;
        }
        .btn-small {
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
        }
        .loading-spinner-small {
            border: 3px solid rgba(67, 56, 202, 0.2);
            border-left-color: var(--secondary-text);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }
        .individual-prompt-block {
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .prompt-time {
            font-size: 0.75rem;
            color: var(--primary-color);
            font-weight: 700;
        }
        .prompt-phrase {
            font-size: 0.875rem;
            color: var(--text-dark);
            font-weight: 700;
            line-height: 1.4;
        }
        .prompt-description-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-medium);
            margin-top: 0.5rem;
            border-top: 1px dashed var(--border-light);
            padding-top: 0.5rem;
        }
        .prompt-description-content {
            font-size: 0.9rem;
            color: var(--text-dark);
            line-height: 1.5;
        }
        pre {
            background-color: var(--bg-light);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-medium);
            overflow-x: auto; /* Para lidar com blocos de estilo longos */
            white-space: pre-wrap; /* Quebra linhas longas */
            word-break: break-all; /* Quebra palavras longas */
        }
        .soundtrack-list {
            list-style-type: disc;
            padding-left: 20px;
            font-size: 0.9rem;
            color: var(--text-dark);
        }
        .soundtrack-list li { margin-bottom: 0.5rem; }

        /* Separador para Thumbnails */
        .thumbnail-item-separator {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-light);
        }

        /* Toast Notification */
        #toastNotification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7); color: #fff; padding: 10px 20px;
            border-radius: 8px; font-size: 0.9rem; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1001; white-space: nowrap;
        }
        #toastNotification.toast-visible { opacity: 1; visibility: visible; }

        /* Alerta Full-Screen */
        #fullScreenAlertOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center;
            align-items: center; z-index: 1000; visibility: hidden; opacity: 0;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #fullScreenAlertOverlay.visible { visibility: visible; opacity: 1; }
        #fullScreenAlertBox {
            background-color: #ffffff; padding: 2.5rem; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); text-align: center; max-width: 500px;
            width: 90%; position: relative; transform: translateY(-20px);
            transition: transform 0.3s ease-out;
        }
        #fullScreenAlertOverlay.visible #fullScreenAlertBox { transform: translateY(0); }
        #fullScreenAlertBox p { font-size: 1.1rem; color: var(--text-dark); margin-bottom: 1.5rem; line-height: 1.6; }
        #fullScreenAlertBox button {
            background-color: var(--primary-color); color: #ffffff; padding: 0.75rem 1.5rem;
            border-radius: 8px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; border: none;
        }
        #fullScreenAlertBox button:hover { background-color: var(--primary-hover); }

        /* ========================================================== */
        /* ================= BARRA FLUTUANTE ====================== */
        /* ========================================================== */
        .floating-action-bar {
            position: fixed; top: 0; left: 0; width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 999; padding: 0.75rem 0;
            transform: translateY(-100%); opacity: 0; visibility: hidden;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .floating-action-bar.visible { transform: translateY(0); opacity: 1; visibility: visible; }
        .action-bar-content {
            max-width: 1024px; margin: 0 auto; padding: 0 2rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .action-bar-buttons-group {
            display: flex; align-items: center; gap: 0.75rem;
            width: 100%; /* Garante que o grupo ocupe o espaço */
        }
        .action-bar-buttons-group.hidden { display: none; }
        .action-bar-buttons-group .action-bar-title {
            white-space: nowrap; /* Impede que o título quebre linha */
            font-weight: 600;
            color: var(--text-dark);
        }
        .action-bar-buttons-group .btn-container {
            display: flex; gap: 0.75rem; justify-content: flex-end; width: 100%;
        }
        .btn-container .btn {
            padding: 0.5rem 1rem; /* Um pouco menores */
            font-size: 0.875rem;
        }
        /* Correção para o espaçamento dos botões clonados */
        .action-bar-buttons-group .btn-container .btn { margin-left: 0.75rem; }
        .action-bar-buttons-group .btn-container .btn:first-child { margin-left: 0; }

        /* ========================================================== */
        /* ======== ESTILOS PARA A BARRA DE PROGRESO ========= */
        /* ========================================================== */
        #progressBar {
            transition: width 0.5s ease-in-out; /* Animação suave do crescimento da barra */
            background-color: var(--success-color); /* Usa a nossa cor de sucesso verde! */
        }

        /* ========================================================== */
        /* ===== CORREÇÃO DE COR DE TEXTO PARA MODO CLARO ===== */
        /* ========================================================== */
        /* REMOVIDO: body:not(.dark) #titlesThumbnailsSection .p-3 p { color: #374151; } */
        /* REMOVIDO: body:not(.dark) #titlesThumbnailsSection .font-semibold { color: #1f2937; } */

        /* ========================================================== */
        /* ==================== MODO ESCURO ======================= */
        /* ========================================================== */
        body.dark {
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        .dark .container, .dark .accordion-item {
            background-color: #1f2937; /* gray-800 */
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }
        .dark .accordion-item { border-color: #4b5563; }
        .dark .floating-action-bar { background-color: rgba(31, 41, 55, 0.9); }
        .dark .action-bar-title, .dark h1, .dark h3, .dark h4, .dark label, .dark p { color: #f3f4f6; }
        .dark .text-gray-500 { color: #9ca3af; }
        .dark .input-group label { color: #d1d5db; }
        .dark .input-group input,
        .dark .input-group select,
        .dark .input-group textarea {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
            color: #f9fafb; /* gray-50 */
        }
        .dark .input-group input:focus,
        .dark .input-group select:focus,
        .dark .input-group textarea:focus {
            border-color: #6366f1; /* indigo-500 */
            background-color: #4b5563; /* gray-600 */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        .dark .bg-indigo-50 { background-color: #374151 !important; }
        .dark .border-indigo-200 { border-color: #4b5563 !important; }
        .dark .text-indigo-800 { color: #a5b4fc !important; }
        .dark .bg-gray-50 { background-color: #374151 !important; }
        .dark .border-gray-200 { border-color: #4b5563 !important; }
        .dark .accordion-body p[contenteditable="true"]:focus {
            background-color: #4b5563;
        }
        .dark .individual-prompt-block {
            background-color: #1f2937;
            border-color: #374151;
        }
        .dark .prompt-phrase { color: #f3f4f6; }
        .dark .prompt-description-label { color: #9ca3af; }
        .dark .prompt-description-content { color: #d1d5db; }
        .dark pre { background-color: #374151 !important; color: #d1d5db; }
        .dark #darkModeToggle { color: #9ca3af; }
        /* ========================================================== */
        /* ==================== ESTILOS TOOLTIP ===================== */
        /* ========================================================== */
        .tooltip {
            position: relative;
            cursor: help;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #e0e7ff; /* Indigo-100 */
            color: #4338ca; /* Indigo-700 */
            font-weight: bold;
            font-size: 0.8rem;
            border: 1px solid #c7d2fe;
        }
        .dark .tooltip {
            background-color: #4b5563; /* Gray-600 */
            color: #e5e7eb; /* Gray-200 */
            border-color: #374151; /* Gray-700 */
        }
        /* Esconde o tooltip por padrão */
        .tooltip::before, .tooltip::after {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            position: absolute;
            bottom: 150%; /* Posiciona acima do (?) */
            left: 50%;
            transform: translateX(-50%) translateY(10px); /* Começa um pouco abaixo */
            z-index: 10;
        }
        /* Mostra o tooltip no hover */
        .tooltip:hover::before, .tooltip:hover::after {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0); /* Sobe para a posição final */
        }
        /* Estilo da caixa de texto do tooltip */
        .tooltip::before {
            content: attr(data-tooltip); /* Pega o texto do atributo! */
            background-color: #1f2937; /* Gray-800 */
            color: #f9fafb; /* Gray-50 */
            padding: 0.75rem;
            border-radius: 8px;
            width: 300px; /* Largura do tooltip */
            text-align: left;
            white-space: pre-wrap; /* Respeita as quebras de linha do atributo */
            font-size: 0.85rem;
            line-height: 1.5;
            font-weight: normal;
        }
        .dark .tooltip::before {
            background-color: #374151; /* Gray-700 */
        }
        /* Estilo da setinha do tooltip */
        .tooltip::after {
            content: '';
            border-width: 6px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent; /* Seta aponta para baixo */
            margin-left: -6px; /* Centraliza a seta */
        }
        .dark .tooltip::after {
            border-color: #374151 transparent transparent transparent;
        }
        .dark .section-prompts, .dark .section-soundtrack { border-top-color: #4b5563; }
        .dark .soundtrack-list { color: #d1d5db; }
    </style>
</head>
<body>
    <!-- ========================================================== -->
    <!-- ===== BARRA FLUTUANTE COM BOTÕES INDEPENDENTES ===== -->
    <!-- ========================================================== -->
    <div id="floatingActionBar" class="floating-action-bar">
        <div class="action-bar-content">
            <!-- Grupo de Ações Principais -->
            <div id="mainActions" class="action-bar-buttons-group">
                <span class="action-bar-title">Passo 1:</span>
                <div class="btn-container">
                    <button id="float_generateIntroBtn" class="btn btn-primary">Introdução</button>
                    <button id="float_generateDevelopmentBtn" class="btn btn-primary">Desenvolvimento</button>
                    <button id="float_climaxBtn" class="btn btn-primary">Clímax</button>
                    <button id="float_conclusionBtn" class="btn btn-primary">Conclusão</button>
                    <button id="float_generateCTABtn" class="btn btn-primary">CTA</button>
                </div>
            </div>
            <!-- Grupo de Ações Rápidas -->
            <div id="quickActions" class="action-bar-buttons-group hidden">
                <span class="action-bar-title">Ações Rápidas:</span>
                 <div class="btn-container">
                    <button id="float_generateDescriptionBtn" class="btn btn-secondary">Descrição</button>
                    <button id="float_generateTitlesAndThumbnailsBtn" class="btn btn-secondary">Títulos</button>
                    <button id="float_downloadPdfBtn" class="btn btn-secondary">PDF</button>
                    <button id="float_resetScriptBtn" class="btn btn-secondary">Novo</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container relative">
        <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-2">Gerador de Roteiros Virais</h1>
        <!-- Botão de Modo Escuro -->
        <div class="absolute top-4 right-4">
             <button id="darkModeToggle" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m8.66-14.66l-.707.707M4.04 19.96l-.707.707M21 12h-1M4 12H3m16.66-7.96l-.707-.707M4.04 4.04l-.707-.707" /></svg>
            </button>
        </div>
        <p class="text-center text-gray-500 mb-8">Crie conteúdo de alto impacto para o seu canal do YouTube.</p>

        <!-- Seção de Inputs da Aplicação -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="input-group">
                <label for="channelName">Nome do Canal:</label>
                <input type="text" id="channelName" placeholder="Ex: The Biblical Unveiling" value="The Biblical Unveiling">
            </div>
            <div class="input-group">
                <label for="videoTheme">Tema do Vídeo:</label>
                <input type="text" id="videoTheme" placeholder="Ex: A Arca da Aliança Foi Encontrada?">
            </div>
             <div class="input-group md:col-span-2">
                <label for="videoDescription">Descrição do Vídeo (para inspiração):</label>
                <textarea id="videoDescription" rows="4" placeholder="Cole uma breve descrição do vídeo aqui para que a IA possa usar como inspiração para o roteiro."></textarea>
            </div>

            <!-- Botão de Estratégia Automática com IA -->
            <div class="md:col-span-2 my-4 flex justify-center">
                <button id="analyzeStrategyBtn" class="btn btn-primary w-full md:w-1/2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M9.5 2.672a.5.5 0 1 0 1 0V.843a.5.5 0 0 0-1 0v1.829Zm4.5.035A.5.5 0 0 0 13.293 2L12 3.293a.5.5 0 1 0 .707.707L14 2.707a.5.5 0 0 0 0-.707ZM7.293 4A.5.5 0 1 0 8 3.293L6.707 2A.5.5 0 0 0 6 2.707L7.293 4Zm-.621 2.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L7.38 6.207a.5.5 0 0 0-.707 0ZM5.5 7a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Zm-1.829-1.5a.5.5 0 0 0-.707 0L2 6.793a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L3.707 7.5H3.5a.5.5 0 0 0 0-1h.207L2.707 5.5Zm-1 .707a.5.5 0 0 0-.707-.707L.707 6.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L1.293 7.5H1.5a.5.5 0 0 0 0-1h-.207L2.293 6.207Z"/><path d="M12.026 8.5H11a.5.5 0 0 0 0 1h1.026a.5.5 0 0 0 0-1Zm-1.633.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293Zm-3.134 3.367a.5.5 0 1 0-.707.707l1.293 1.293a.5.5 0 0 0 .707-.707l-1.293-1.293Zm1.633-.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293A.5.5 0 0 1 8.89 11.86Z"/></svg>
                    <span class="button-text">Definir Estratégia com IA</span>
                    <div class="loading-spinner hidden"></div>
                </button>
            </div>
            
            <!-- Campos de Estratégia Preenchidos pela IA -->
            <div class="input-group md:col-span-2">
                <label for="targetAudience">Público-Alvo:</label>
                <input type="text" id="targetAudience" value="Pessoas Interessadas em Arqueologia Bíblica e História Antiga, Cristãos e Pessoas de Fé, Entusiastas de Ciência e Ceticismo (com mente aberta), Curiosos em Geral e Amantes de Mistérios." readonly>
            </div>
            <div class="input-group">
                <label for="languageSelect">Idioma do Roteiro:</label>
                <select id="languageSelect">
                    <option value="pt-br">Português (Brasil)</option>
                    <option value="pt-pt">Português (Portugal)</option>
                    <option value="en" selected>English</option>
                    <option value="es">Españão</option>
                </select>
            </div>
            <div class="input-group">
                <label for="languageStyle">Estilo de Linguagem:</label>
                <select id="languageStyle">
                    <option value="formal">Formal</option>
                    <option value="informal">Informar</option>
                    <option value="emocional">Emocional</option>
                    <option value="tecnico">Técnico</option>
                    <option value="inspirador" selected>Inspirador</option>
                    <option value="humoristico">Humorístico</option>
                </select>
            </div>
            <div class="input-group md:col-span-2">
                <label for="videoObjective">Objetivo do Vídeo:</label>
                <select id="videoObjective">
                    <option value="informar" selected>Informar</option>
                    <option value="emocionar">Emocionar</option>
                    <option value="evangelizar">Evangelizar (criar defensores)</option>
                    <option value="vender">Vender</option>
                    <option value="entreter">Entreter</option>
                </select>
            </div>
            <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                <div class="input-group">
                    <label for="videoDuration">Duração Desejada:</label>
                    <select id="videoDuration">
                        <option value="">-- Selecione a Duração --</option>
                        <option value="short">Curto (~1-3 min)</option>
                        <option value="medium">Médio (~4-7 min)</option>
                        <option value="long">Longo (~8-12 min)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="speakingPace">Ritmo de Fala:</label>
                    <select id="speakingPace">
                        <option value="moderate" selected>Moderado</option>
                        <option value="slow">Lento</m>
                        <option value="fast">Rápido</option>
                    </select>
                </div>
            </div>
            <div class="input-group md:col-span-2">
                <div class="flex items-center gap-2">
                    <label for="narrativeStyle">Estilo da Narrativa:</label>
                    <span class="tooltip"
                        data-tooltip="Direto e Informativo: Estrutura clássica de começo, meio e fim. Ideal para documentários.&#10;&#10;Jornada do Herói: Conta uma história de transformação e superação. Ótimo para narrativas inspiradoras.&#10;&#10;Mistério (Loop Aberto): Apresenta uma pergunta no início e a responde no final. Excelente para reter a atenção.&#10;&#10;Problema-Agitação-Solução (PAS): Foca em um problema que o público tem e apresenta a solução. Perfeito para vídeos de marketing e tutoriais.&#10;&#10;Antes-Depois-Ponte (BAB): Mostra um cenário 'antes' (o problema), um 'depois' (o resultado ideal) e seu conteúdo como 'a ponte' para chegar lá.&#10;&#10;Narrativa com Virada (Twist): Constrói uma expectativa e a quebra com uma revelação surpreendente no final."
                    >
                        (?)
                    </span>
                </div>
                <select id="narrativeStyle">
                    <option value="direct" selected>Direto e Informativo (Padrão)</option>
                    <option value="heros_journey">Jornada do Herói (Clássico)</option>
                    <option value="mystery_loop">Mistério (com Loop Aberto)</option>
                    <option value="pas">Problema-Agitação-Solução (PAS)</option>
                    <option value="before_after_bridge">Antes-Depois-Ponte (BAB)</option>
                    <option value="twist">Narrativa com Virada (Twist)</option>
                </select>
            </div>
            <div class="input-group md:col-span-2">
                <label for="centralQuestion">Pergunta Central (Opcional):</label>
                <textarea id="centralQuestion" rows="2" placeholder="Ex: A Arca da Aliança era uma arma ou um meio de comunicação?"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="emotionalArc">Arco Emocional Desejado (Opcional):</label>
                <textarea id="emotionalArc" rows="2" placeholder="Ex: Começar com curiosidade, construir para admiração, e terminar com inspiração."></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="viralElements">Elementos Virais/Tendências (Opcional):</label>
                <textarea id="viralElements" rows="2" placeholder="Insira memes, frases, tendências ou palavras-chave em alta. Ex: 'o hype é real', 'chocado', 'plot twist'"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="imageDescriptionEngine">Motor de Descrição de Imagem:</label>
                <textarea id="imageDescriptionEngine" rows="2" placeholder="Ex: 'alta resolução', 'detalhado', 'fotorrealista', 'cores vibrantes'"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="imageStyleSelect">Motor de Qualidade de Imagem:</label>
                <select id="imageStyleSelect">
                    <option value="cinematic" selected>Cinematográfico</option>
                    <option value="custom">Personalizado</option>
                    <option value="none">Nenhum</option>
                </select>
            </div>
            <div class="input-group md:col-span-2" id="customImageStyleContainer" style="display: none;">
                <label for="customImageStyle">Estilo Visual Personalizado:</label>
                <textarea id="customImageStyle" rows="5" placeholder="Cole aqui o seu bloco de estilo personalizado (ex: para cartoon, anime, etc.)."></textarea>
            </div>
        </div>

        <!-- ========================================================== -->
        <!-- ========= NOVA BARRA DE PROGRESO VISUAL ============= -->
        <!-- ========================================================== -->
        <div id="progressBarContainer" class="progress-bar-container mb-8">
            <div class="flex justify-between mb-1">
                <span class="text-base font-medium text-gray-700 dark:text-gray-300">Progresso do Projeto</span>
                <span id="progressText" class="text-sm font-medium text-gray-700 dark:text-gray-300">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>
        <!-- ========================================================== -->

        <!-- Botões de Ação Principais -->
        <div class="mb-8 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
            <h3 class="font-bold text-lg text-indigo-800 mb-3">Passo 1: Gerar o Roteiro Principal</h3>
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                <button id="generateIntroBtn" class="btn btn-primary">
                    <span class="button-text">Introdução</span>
                    <div class="loading-spinner hidden" id="introSpinner"></div>
                </button>
                <button id="generateDevelopmentBtn" class="btn btn-primary">
                    <span class="button-text">Desenvolvimento</span>
                    <div class="loading-spinner hidden" id="developmentSpinner"></div>
                </button>
                <button id="climaxBtn" class="btn btn-primary">
                    <span class="button-text">Clímax</span>
                    <div class="loading-spinner hidden" id="climaxSpinner"></div>
                </button>
                <button id="conclusionBtn" class="btn btn-primary">
                    <span class="button-text">Conclusão</span>
                    <div class="loading-spinner hidden" id="conclusionSpinner"></div>
                </button>
                <button id="generateCTABtn" class="btn btn-primary">
                    <span class="button-text">CTA</span>
                    <div class="loading-spinner hidden" id="ctaSpinner"></div>
                </button>
            </div>
        </div>

        <!-- Botões de Material de Suporte -->
        <div class="mb-8 p-4 bg-gray-50 border border-gray-200 rounded-lg">
            <h3 class="font-bold text-lg text-gray-800 mb-3">Passo 2: Criar Material de Suporte</h3>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <button id="generateDescriptionBtn" class="btn btn-secondary">
                    <span class="button-text">Descrição do Vídeo</span>
                    <div class="loading-spinner hidden" id="descriptionSpinner"></div>
                </button>
                <button id="generateTitlesAndThumbnailsBtn" class="btn btn-secondary">
                    <span class="button-text">Títulos de Vídeos e Thumbnails</span>
                    <div class="loading-spinner hidden" id="titlesThumbnailsSpinner"></div>
                </button>
            </div>
        </div>
       
        <!-- Botões de Salvar e Exportar -->
        <div class="mb-8 p-4 bg-gray-50 border border-gray-200 rounded-lg">
            <h3 class="font-bold text-lg text-gray-800 mb-3">Passo 3: Salvar e Exportar</h3>
             <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <button id="exportProjectBtn" class="btn btn-secondary">Exportar Projeto</button>
                <button id="importProjectBtn" class="btn btn-secondary">Importar Projeto</button>
                <input type="file" id="importFileInput" class="hidden" accept=".json">
                <button id="downloadPdfBtn" class="btn btn-secondary">Download PDF</button>
                <button id="resetScriptBtn" class="btn btn-secondary">Novo Roteiro</button>
            </div>
        </div>

        <!-- Área de Saída do Roteiro (Acordeões) -->
        <div id="scriptOutput" class="mt-8">
            <div id="introSection" class="script-section hidden"></div>
            <div id="developmentSection" class="script-section hidden"></div>
            <div id="climaxSection" class="script-section hidden"></div>
            <div id="conclusionSection" class="script-section hidden"></div>
            <div id="ctaSection" class="script-section hidden"></div>
            <div id="videoDescriptionOutputSection" class="script-section hidden"></div>
            <div id="titlesThumbnailsSection" class="script-section hidden"></div>
        </div>
    </div>

    <!-- Elementos de Feedback (Toast e Alerta) -->
    <div id="toastNotification" class="toast-notification"></div>
    <div id="fullScreenAlertOverlay">
        <div id="fullScreenAlertBox">
            <p id="fullScreenAlertMessage"></p>
            <button id="fullScreenAlertCloseBtn">Entendi</button>
        </div>
    </div>

    <script type="module">
        // ==========================================================
        // ==================== SETUP INICIAL =======================
        // ==========================================================
        // Variáveis de estado globais
        let generatedTitlesAndThumbnails = null;
        let allImagePrompts = {}; // Armazena prompts de imagem por seção

        // Bloco de estilo cinematográfico para prompts de imagem
        const CINEMATIC_STYLE_BLOCK = `
**[ESTILO CINEMATOGRÁFICO]**
**Style:** Cinematic film still, hyper-realistic, masterful cinematography. Shot on an Arri Alexa 65 with vintage anamorphic lenses. The composition is deliberate and powerful, using principles of photographic storytelling.
**Lighting:** Naturalistic and dramatic lighting. Strong use of light and shadow (chiaroscuro) to create depth and mood. The light source feels authentic to the environment, whether it's harsh sunlight, soft window light, or moody candlelight.
**Details & Textures:** Extreme attention to micro-details. Hyper-realistic textures are paramount: visible skin pores, fabric weaves, material imperfections (scratches on metal, weathering on stone, dust on surfaces). Every element feels tangible and real.
**Color & Mood:** Rich, cinematic color grading. The color palette is carefully controlled to enhance the story and emotion of the scene. The overall mood is immersive, evocative, and deeply atmospheric.
**Negative Prompt:** --no cgi, 3d, render, painting, illustration, animation, video game, digital art, cartoon
`;
        // Labels para descrição de imagem em diferentes idiomas
        const imageDescriptionLabels = { 'pt-br': 'Descrição da Imagem:', 'pt-pt': 'Descrição da Imagem:', 'en': 'Image Description:' };

        // Mapeamento de elementos do DOM para acesso fácil
        const elements = {};
        const buttons = {};
        // Preenche os objetos elements e buttons dinamicamente
        document.querySelectorAll('[id]').forEach(el => {
            if (el.tagName === 'BUTTON') buttons[el.id] = el;
            else elements[el.id] = el;
        });

        // ADICIONADO: Mapeamento manual para os ícones de modo escuro
        elements.moonIcon = document.getElementById('moonIcon');
        elements.sunIcon = document.getElementById('sunIcon');

        // ==========================================================
        // ================== FUNÇÕES DE UTILIDADE ==================
        // ==========================================================
        /**
         * Exibe uma notificação toast na parte inferior da tela.
         * @param {string} message - A mensagem a ser exibida.
         */
        window.showToast = (message) => {
            elements.toastNotification.textContent = message;
            elements.toastNotification.classList.add('toast-visible');
            setTimeout(() => {
                elements.toastNotification.classList.remove('toast-visible');
                setTimeout(() => { elements.toastNotification.textContent = ''; }, 300);
            }, 3000);
        };

        /**
         * Copia um texto para a área de transferência.
         * @param {string} text - O texto a ser copiado.
         */
        window.copyTextToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                window.showToast('Copiado!');
            } catch (err) {
                // Fallback para navegadores mais antigos ou contextos restritos (ex: iframes)
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                try {
                    document.execCommand('copy');
                    window.showToast('Copiado!');
                } finally {
                    document.body.removeChild(ta);
                }
            }
        };

        /**
         * Mostra um spinner de carregamento e desabilita todos os botões de geração.
         * @param {HTMLElement} button - O botão que acionou o carregamento.
         */
        const showLoading = (button) => {
            // Desabilitar TODOS os botões de geração para evitar rate limit
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = true; });
        
            const textSpan = button.querySelector('.button-text');
            const spinnerDiv = button.querySelector('.loading-spinner');

            if (textSpan) textSpan.classList.add('hidden');
            if (spinnerDiv) spinnerDiv.classList.remove('hidden');
        };

        /**
         * Esconde o spinner de carregamento e reabilita os botões.
         * @param {HTMLElement} button - O botão que estava em estado de carregamento.
         */
        const hideLoading = (button) => {
            // Habilita TODOS os botões de geração novamente
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = false; });
            
            const spinnerDiv = button.querySelector('.loading-spinner');
            if (spinnerDiv) spinnerDiv.classList.add('hidden');
            
            const textSpan = button.querySelector('.button-text');
            if (textSpan) textSpan.classList.remove('hidden');

            updateButtonStates(); // Chama a função centralizada para reavaliar o estado
        };

        /**
         * Marca um botão (original e flutuante) como concluído (cor verde).
         * @param {string} originalId - O ID do botão original.
         */
        const markButtonAsCompleted = (originalId) => {
            const originalButton = document.getElementById(originalId);
            const floatButton = document.getElementById(`float_${originalId}`);

            [originalButton, floatButton].forEach(btn => {
                if (btn) {
                    btn.classList.remove('btn-primary', 'btn-secondary');
                    btn.classList.add('btn-success');
                }
            });
            updateProgressBar(); // <-- ADICIONADO AQUI
        };

        /**
         * Reseta os ícones de conclusão de todos os botões (original e flutuante) para suas cores padrão.
         */
        const resetCompletionIcons = () => {
            const passo1_buttons_ids = ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'];
            
            for (const buttonId in buttons) { // Iterar sobre todos os botões
                const isPasso1 = passo1_buttons_ids.includes(buttonId);
                const originalButton = document.getElementById(buttonId);
                const floatButton = document.getElementById(`float_${buttonId}`);

                // Remove a classe de sucesso e adiciona a classe correta (primary/secondary)
                [originalButton, floatButton].forEach(btn => {
                    if (btn) {
                        btn.classList.remove('btn-success');
                        if (isPasso1) {
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-primary');
                        } else {
                            btn.classList.remove('btn-primary');
                            btn.classList.add('btn-secondary');
                        }
                    }
                });
            }
        };
        
        /**
         * Verifica se as seções principais do roteiro foram geradas.
         * @returns {boolean} True se todas as seções principais foram geradas, caso contrário, false.
         */
        const isScriptComplete = () => {
            return ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'].every(id => {
                const section = document.getElementById(id);
                return section && !section.classList.contains('hidden') && section.querySelector('p')?.textContent.trim() !== '';
            });
        };

        /**
         * Atualiza o estado de habilitação/desabilitação dos botões com base no estado do roteiro.
         */
        const updateButtonStates = () => {
            const allMainScriptGenerated = isScriptComplete();
            // Verifica se há qualquer conteúdo gerado para habilitar PDF e reset
            const hasAnyContent = document.querySelector('#scriptOutput .accordion-item') != null;

            // Botões que dependem da conclusão do roteiro principal
            ['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn'].forEach(id => {
                const originalBtn = document.getElementById(id);
                const floatBtn = document.getElementById(`float_${id}`);
                if (originalBtn) originalBtn.disabled = !allMainScriptGenerated;
                if (floatBtn) floatBtn.disabled = !allMainScriptGenerated;
            });
            
            // Botões que dependem de qualquer conteúdo gerado
            ['downloadPdfBtn'].forEach(id => {
                 const originalBtn = document.getElementById(id);
                 const floatBtn = document.getElementById(`float_${id}`);
                 if (originalBtn) originalBtn.disabled = !hasAnyContent;
                 if (floatBtn) floatBtn.disabled = !hasAnyContent;
            });

            // Botão de reset sempre habilitado (ou desabilitado apenas se não houver nada para resetar)
            const resetBtn = document.getElementById('resetScriptBtn');
            const floatResetBtn = document.getElementById('float_resetScriptBtn');
            if (resetBtn) resetBtn.disabled = false; // Ajuste conforme a necessidade de reset
            if (floatResetBtn) floatResetBtn.disabled = false;
        };

        /**
         * Mostra um alerta em tela cheia com uma mensagem.
         * @param {string} message - A mensagem do alerta.
         */
        const showFullScreenAlert = (message) => {
            elements.fullScreenAlertMessage.textContent = message;
            elements.fullScreenAlertOverlay.classList.add('visible');
        };

        /** Esconde o alerta em tela cheia. */
        const hideFullScreenAlert = () => {
            elements.fullScreenAlertOverlay.classList.remove('visible');
        };

        /** Alterna a visibilidade do campo de estilo de imagem personalizado. */
        const toggleCustomImageStyleVisibility = () => {
            elements.customImageStyleContainer.style.display = elements.imageStyleSelect.value === 'custom' ? 'block' : 'none';
        };

        /**
         * Gera o HTML para uma seção do roteiro em formato de acordeão.
         * @param {string} sectionId - O ID da seção (ex: 'intro', 'development').
         * @param {string} title - O título da seção a ser exibido.
         * @param {string} content - O conteúdo do roteiro para a seção.
         * @param {object} options - Opções para controlar a exibição de botões (showPromptsButton, showSoundtrackButton).
         * @returns {string} O HTML completo da seção.
         */
        const generateSectionHtmlContent = (sectionId, title, content, options = {}) => {
            // Define os valores padrão se não forem fornecidos
            const { showPromptsButton = true, showSoundtrackButton = true } = options;
            
            const bodyId = `${sectionId}Body`;
            const arrowId = `${sectionId}Arrow`;

            const regenerateBtnHtml = `<button class="regenerate-btn" onclick="event.stopPropagation(); window.regenerateSection('${sectionId}', '${title}', '${sectionId}')" title="Re-gerar esta seção">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                    <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
                </svg>
            </button>`;

            const copyBtnHtml = `<button class="copy-btn" onclick="event.stopPropagation(); copyTextToClipboard(document.getElementById('${bodyId}').querySelector('p').textContent)">Copiar</button>`;
            
            // Constrói condicionalmente as seções de prompt e trilha sonora
            const promptsSectionHtml = showPromptsButton ? `
                <div class="section-prompts">
                    <button class="btn btn-secondary btn-small" onclick="window.generatePromptsForSection('${sectionId}Section')">
                        Gerar Prompts de Imagem
                    </button>
                    <div class="prompt-container mt-4"></div>
                </div>
            ` : '';
            
            const soundtrackSectionHtml = showSoundtrackButton ? `
                <div class="section-soundtrack">
                    <button class="btn btn-secondary btn-small" onclick="window.suggestSoundtrack('${sectionId}Section')">
                        Sugerir Trilha Sonora
                    </button>
                    <div class="soundtrack-container mt-4"></div>
                </div>
            ` : '';

            // Removido o regenerateBtnHtml do header-buttons para a Descrição do Vídeo
            const headerButtonsHtml = (sectionId === 'videoDescriptionOutput' || sectionId === 'titlesThumbnails') ?
                `${copyBtnHtml}` :
                `${regenerateBtnHtml} ${copyBtnHtml}`;

            return `<div class="accordion-item">
                        <div class="accordion-header" onclick="toggleAccordion('${bodyId}', '${arrowId}')">
                            <div class="header-content">
                                 <h3>${title}</h3>
                                 <svg id="${arrowId}" class="accordion-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                                 </svg>
                            </div>
                            <div class="header-buttons">
                                ${headerButtonsHtml}
                            </div>
                        </div>
                        <div id="${bodyId}" class="accordion-body">
                            <p class="whitespace-pre-wrap" contenteditable="true">${content}</p>
                            ${promptsSectionHtml}
                            ${soundtrackSectionHtml}
                        </div>
                    </div>`;
        };

        /**
         * Limpa o texto gerado pela IA, removendo metadados e extraindo JSON se necessário.
         * @param {string} text - O texto bruto da IA.
         * @param {boolean} expectJson - Se true, tenta extrair e validar um JSON.
         * @returns {string|null} O texto limpo ou o JSON stringificado, ou null em caso de erro.
         */
        const cleanGeneratedText = (text, expectJson = false) => {
            if (!text) return null;

            if (expectJson) {
                // Procura o início do JSON, seja ele um objeto '{' ou um array '['
                const startIndex = text.indexOf('{');
                const startBracket = text.indexOf('[');
                
                let jsonStartIndex = -1;

                if (startIndex > -1 && startBracket > -1) {
                    jsonStartIndex = Math.min(startIndex, startBracket);
                } else if (startIndex > -1) {
                    jsonStartIndex = startIndex;
                } else {
                    jsonStartIndex = startBracket;
                }

                if (jsonStartIndex === -1) {
                    console.error("cleanGeneratedText: Não foi possível encontrar um início de JSON ('{' ou '[') na resposta.", text);
                    return null;
                }

                const potentialJson = text.substring(jsonStartIndex);
                let jsonString = '';
                if (potentialJson.startsWith('{')) {
                    const endIndex = potentialJson.lastIndexOf('}');
                    jsonString = potentialJson.substring(0, endIndex + 1);
                } else {
                    const endIndex = potentialJson.lastIndexOf(']');
                    jsonString = potentialJson.substring(0, endIndex + 1);
                }
                
                try {
                    JSON.parse(jsonString); // Apenas para validar
                    return jsonString;
                } catch (e) {
                    console.error("O JSON extraído é inválido.", e.message, jsonString);
                    return null;
                }
            }
            
            return text.trim();
        };

        /**
         * Remove comentários meta da IA do texto gerado.
         * @param {string} text - O texto gerado pela IA.
         * @returns {string} O texto sem os comentários meta.
         */
        const removeMetaComments = (text) => {
            if (!text) return text;
            let cleanedText = text;
            // Remove frases como "Here's the **Section** section..." ou "Here is a compelling..."
            const introPattern = /^(Here's|Here is)\s.*?\n/gim;
            cleanedText = cleanedText.replace(introPattern, '');
            return cleanedText.trim();
        };

        /**
         * Constrói o contexto base do prompt com base nos inputs do usuário.
         * @returns {string} O contexto do prompt.
         */
        const getBasePromptContext = () => {
            const channelName = elements.channelName.value.trim();
            const videoTheme = elements.videoTheme.value.trim();
            const targetAudience = elements.targetAudience.value.trim();
            const language = elements.languageSelect.value;
            const languageStyle = elements.languageStyle.value;
            const videoObjective = elements.videoObjective.value;
            const videoDuration = elements.videoDuration.value;
            const speakingPace = elements.speakingPace.value;
            const narrativeStyle = elements.narrativeStyle.value;
            const videoDescription = elements.videoDescription.value.trim();
            const centralQuestion = elements.centralQuestion.value.trim();
            const emotionalArc = elements.emotionalArc.value.trim();
            const viralElements = elements.viralElements.value.trim();
            const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
            const imageStyleSelect = elements.imageStyleSelect.value;
            const customImageStyle = elements.customImageStyle.value.trim();

            let context = `
            You are an expert YouTube scriptwriter for the channel "${channelName}".
            Your goal is to create highly engaging and viral video content.
            
            Video Theme: "${videoTheme}"
            Target Audience: "${targetAudience}"
            Language: "${language}"
            Language Style: "${languageStyle}"
            Video Objective: "${videoObjective}"
            Desired Duration: "${videoDuration}"
            Speaking Pace: "${speakingPace}"
            Narrative Style: "${narrativeStyle}"
            `;

            if (videoDescription) { context += `\nInspiration/Context: "${videoDescription}"`; }
            if (centralQuestion) { context += `\nCentral Question to guide the entire script: "${centralQuestion}"`; }
            if (emotionalArc) { context += `\nEmotional Arc: "${emotionalArc}"`; }
            if (viralElements) { context += `\nViral Elements to incorporate: "${viralElements}"`; }
            if (imageDescriptionEngine) { context += `\nImage Description Instructions: "${imageDescriptionEngine}"`; }
            
            if (imageStyleSelect === 'cinematic') {
                context += `\nImage Style: Cinematic film still, hyper-realistic, masterful cinematography. Shot on an Arri Alexa 65 with vintage anamorphic lenses. The composition is deliberate and powerful, using principles of photographic storytelling. Naturalistic and dramatic lighting. Strong use of light and shadow (chiaroscuro) to create depth and mood. Extreme attention to micro-details. Hyper-realistic textures are paramount: visible skin pores, fabric weaves, material imperfections. Rich, cinematic color grading. The overall mood is immersive, evocative, and deeply atmospheric.`;
            } else if (imageStyleSelect === 'custom' && customImageStyle) {
                context += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
            }

            return context;
        };

        /**
         * Constrói o prompt específico para cada seção do roteiro ou tipo de conteúdo.
         * @param {string} sectionName - O nome da seção (ex: 'intro', 'titles_thumbnails').
         * @param {string} sectionTitle - O título da seção para o prompt.
         * @returns {{prompt: string, maxTokens: number}} O prompt e o limite de tokens.
         */
        const constructScriptPrompt = (sectionName, sectionTitle) => {
            const baseContext = getBasePromptContext();
            const videoDuration = elements.videoDuration.value;
            const selectedLanguage = elements.languageSelect.value;
            const narrativeStyle = elements.narrativeStyle.value;

            let prompt = `${baseContext}\n\nGenerate the **${sectionTitle}** section of the video script. Focus on making it highly engaging and suitable for a viral video. Ensure the tone and content align with the channel and audience.`;
            let maxTokens = 2000;

            prompt += `\n\nIMPORTANT: Do NOT include any scene descriptions, visual/audio cues (e.g., [SHOT], (Camera pan), (Music swells)), or speaker labels (e.g., "Narrator:", "Host:") in the generated script content. Provide only the spoken text.`;
            prompt += `\n\nABSOLUTELY NO META-COMMENTS. Do not add any explanatory text about the script itself. Your entire response must be ONLY the text to be spoken in the video, and nothing else.`;

            if (elements.centralQuestion.value.trim()) {
                prompt += `\nIf a 'Central Question' is provided, ensure every section of the script (Introduction, Development, Climax) directly contributes to exploring or answering this question. The entire video must revolve around this central theme.`;
            }

            switch (narrativeStyle) {
                case 'mystery_loop':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Mystery/Open Loop' structure.
                    - In the **Introduction**, present a compelling central question or mystery and promise the answer by the end.
                    - In the **Development**, build suspense by exploring clues and theories, occasionally reminding the viewer of the central question.
                    - In the **Climax**, deliver the satisfying answer to the question posed in the introduction.`;
                    break;
                case 'pas':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Problem-Agitate-Solution' structure.
                    - Frame the **Introduction** around a clear 'Problem' that the audience can relate to.
                    - Use the first part of the **Development** to 'Agitate' this problem, explaining its importance and complexity.
                    - Frame the rest of the **Development** and the **Climax** as the 'Solution' or the revealing insight that addresses the initial problem.`;
                    break;
                case 'twist':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'False Climax & Twist' structure.
                    - In the **Development**, build evidence towards a seemingly obvious conclusion (the 'false climax').
                    - In the **Climax**, introduce a surprising new piece of information or a counter-argument that completely changes the expected outcome (the 'twist').
                    - The **Conclusion** should reflect on the implications of this new, unexpected truth.`;
                    break;
                case 'heros_journey':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Hero's Journey' structure.
                    - **Introduction:** Present the 'Ordinary World' and the 'Call to Adventure'. Introduce the central character or concept.
                    - **Development:** This is the 'Special World'. Describe the trials, allies, and enemies. Build the character's transformation through challenges.
                    - **Climax:** The 'Ordeal' or the final battle. The moment of greatest tension and the hero's ultimate test.
                    - **Conclusion:** The 'Return with the Elixir'. Show the resolution, what was learned, and how the 'Ordinary World' has changed because of the journey.`;
                    break;
                case 'before_after_bridge':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Before-After-Bridge' (BAB) structure.
                    - **Introduction (Before):** Describe the 'Before' state. A world without the knowledge or solution you're about to present. Paint a picture of the problem or the lack of understanding.
                    - **Development (After):** Describe the 'After' state. A desirable world where the problem is solved or the knowledge is revealed. Show the benefits and the ideal outcome.
                    - **Climax & Conclusion (The Bridge):** Present your content as 'The Bridge'. Explain how your video's information is the exact path to get from the 'Before' state to the 'After' state. This is the solution, the 'how-to'.`;
                    break;
            }

            prompt += `\n\nIMPORTANT WRITING STYLE: Use the 'Show, Don't Tell' principle. Instead of stating facts plainly, use descriptive, evocative language to paint a picture in the viewer's mind. Create a sensory and visual experience through your words.`;

            switch (sectionName) {
                case 'intro':
                    prompt += `
                    The introduction should hook the viewer immediately, clearly state the video's intriguing question or mystery, and set the stage for what's to come. It must be captivating and create curiosity. For a "${videoDuration}" video, make this introduction appropriate in length and detail.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 1** of the story. Your introduction should serve as the 'Inciting Incident', clearly presenting the central question or mystery that will drive the video. Establish the 'Normal World' of the topic before introducing the core conflict.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'development':
                    prompt += `
                    The development section should delve into the core topic, presenting facts, arguments, and historical context. It should maintain a strong narrative flow, building suspense and providing compelling information. Break down complex ideas into easily digestible parts. For a "${videoDuration}" video, ensure this section is comprehensive but also flows well, adapting its length to the desired duration.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 2** of the story. Your goal is to raise the stakes. Present compelling evidence but also introduce obstacles and counter-arguments. Build towards a major revelation or turning point (the Midpoint).`;
                    }
                    maxTokens = 1500;
                    break;
                case 'climax':
                    prompt += `
                    The climax should be the most impactful part of the video, revealing key insights, surprising twists, or the most compelling evidence related to the video theme. It should be dramatic and leave the viewer with a sense of awe or profound understanding. For a "${videoDuration}" video, make this climax impactful and well-paced.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is the peak of **Act 2**, leading into Act 3. Deliver the most impactful revelation or the resolution of the main conflict.`;
                    }
                    maxTokens = 500;
                    break;
                case 'conclusion':
                    prompt += `
                    The conclusion should summarize the main points, provide a final thought or reflection, and leave the viewer with a lasting impression. Ensure the conclusion is complete and well-rounded, providing a sense of closure. For a "${videoDuration}" video, make this conclusion concise yet impactful.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 3** of the story. Provide the final resolution and reflect on the implications of the video's journey.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'cta':
                    prompt += `
                    The Call to Action (CTA) should be clear and concise, encouraging viewers to subscribe, like, comment, share, or engage with other content. Make it compelling and natural within the video's flow. For a "${videoDuration}" video, keep this CTA direct and effective.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is the final part of **Act 3**. Ensure a strong and clear call to action that naturally concludes the video's narrative.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 200;
                    break;
                case 'titles_thumbnails':
                    prompt = `${baseContext}
Generate 5 highly clickable and viral YouTube video titles and 3 compelling thumbnail ideas.

IMPORTANT: Respond ONLY with a valid JSON object. Do not include any other text, preambles, or explanations outside of the JSON structure itself.

The JSON object must have two top-level keys:
1.  "titles": An array of strings.
2.  "thumbnails": An array of objects, where each object has a "title" (string) and a "description" (string) key.

The final output MUST be only the JSON code, like this example:
{
  "titles": [
    "The Shocking Truth About the Ark of the Covenant",
    "Was the Ark of the Covenant Finally Discovered?",
    "This Ancient Secret Could Change History Forever",
    "Biblical Mystery: The Ark's Final Location Revealed",
    "They Found It? The Search for the Lost Ark Ends Here"
  ],
  "thumbnails": [
    {
      "title": "FOUND?",
      "description": "A dramatic image of an ancient, glowing chest half-buried in a dark cave, with an astonished archaeologist looking on."
    },
    {
      "title": "TOP SECRET",
      "description": "A collage showing a faded ancient map, a secret biblical text, and a satellite image pointing to a location in Ethiopia."
    },
    {
      "title": "HISTORY CHANGED",
      "description": "A visually stunning image of the Ark of the Covenant radiating golden light inside a reconstructed Solomon's Temple."
    }
  ]
}
`;
                    maxTokens = 800;
                    break;
                case 'description':
                    prompt = `${baseContext}\n\nGenerate a compelling YouTube video description (around 150-200 words) that summarizes the video, includes relevant keywords for SEO, and encourages engagement. Include a strong hook, a brief overview of the content, and a call to action. Also, suggest 10 relevant hashtags.
                    Output format:
                    Description:
                    [Your description here]

                    Hashtags:
                    #hashtag1 #hashtag2 ...
                    `;
                    maxTokens = 700;
                    break;
                default:
                    maxTokens = 1000;
                    break;
            }
            return { prompt, maxTokens };
        };

        /**
         * Faz uma chamada à API Groq através de uma função Netlify.
         * @param {string} prompt - O prompt a ser enviado para a IA.
         * @param {number} maxTokens - O número máximo de tokens para a resposta.
         * @returns {Promise<string>} A resposta bruta da IA.
         * @throws {Error} Se a chamada à API falhar.
         */
        const callGroqAPI = async (prompt, maxTokens) => {
            const proxyUrl = "/.netlify/functions/groq"; // Endpoint do proxy

            const payload = {
                prompt: prompt,
                maxTokens: maxTokens
            };

            const request = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetch(proxyUrl, request);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Erro desconhecido do servidor proxy.' } }));
                    throw new Error(`Erro na API via Proxy: ${errorData.error?.message || 'Erro do servidor'}`);
                }
                const result = await response.json();
                const rawContent = result.choices?.[0]?.message?.content;
                if (rawContent) { return rawContent; }
                else { throw new Error("Resposta inesperada da API Groq."); }
            } catch (error) {
                console.error("Fetch da API via Netlify Function falhou:", error);
                window.showToast(`Falha na API: ${error.message}`);
                throw error;
           }
        };

        /**
         * Valida os inputs essenciais antes de gerar conteúdo.
         * @returns {boolean} True se os inputs são válidos, caso contrário, false.
         */
        const validateInputs = () => {
            if (!elements.channelName.value.trim()) {
                window.showToast("Por favor, insira o nome do canal.");
                return false;
            }
            if (!elements.videoTheme.value.trim()) {
                window.showToast("Por favor, insira o tema do vídeo.");
                return false;
            }
            if (!elements.videoDescription.value.trim()) {
                window.showToast("Por favor, insira a descrição do vídeo (para inspiração).");
                return false;
            }
            if (!elements.videoDuration.value || elements.videoDuration.value === "") {
                window.showToast("Por favor, selecione a Duração Desejada do vídeo.");
                return false;
            }
            return true;
        };

        // ==========================================================
        // ================== FUNÇÕES PRINCIPAIS ====================
        // ==========================================================

        /**
         * Lida com a geração de uma seção específica do roteiro.
         * @param {HTMLElement} button - O botão que acionou a geração.
         * @param {string} sectionName - O nome da seção (ex: 'intro').
         * @param {string} sectionTitle - O título da seção para exibição.
         * @param {string} elementId - O ID do elemento HTML onde o conteúdo será inserido (ex: 'intro').
         */
        const handleGenerateSection = async (button, sectionName, sectionTitle, elementId) => {
            if (!validateInputs()) return;
            showLoading(button);
            try {
                const { prompt, maxTokens } = constructScriptPrompt(sectionName, sectionTitle);
                let result = await callGroqAPI(prompt, maxTokens);
                
                // Limpeza específica de metadados da IA
                result = result.replace(/^Here's (?:the|a potential) \*\*[\w\s]+\*\* (?:section of the video script|for the video script):\s*\n*\s*$/gm, '');
                result = result.replace(/^(?:Host|Narrator)(?:\s*\(.*?\))?:\s*/gm, '');
                result = result.replace(/^\*\*[\w\s]+\*\*$/gm, '');
                result = result.replace(/^\s*(?:\*\*?\[.*?\]\*\*?|\(.*?\))\s*$/gm, '');
                result = result.replace(/^\s*[\r\n]+/gm, '');

                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);

                const targetSectionElement = document.getElementById(`${elementId}Section`);
                if (targetSectionElement) {
                    targetSectionElement.innerHTML = generateSectionHtmlContent(elementId, sectionTitle, result);
                    targetSectionElement.classList.remove('hidden');
                } else {
                    console.error(`Target section element with ID '${elementId}Section' not found.`);
                    window.showToast("Erro interno: Seção do roteiro não encontrada.");
                    return;
                }
                
                markButtonAsCompleted(button.id);
                updateButtonStates(); // Atualiza o estado dos botões após uma seção ser gerada

            } catch (error) {
                window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
                console.error(`Error generating ${sectionTitle}.`, error);
            } finally {
                hideLoading(button);
            }
        };

        /**
         * Re-gera o conteúdo de uma seção específica do roteiro.
         * Chamada pelos botões "Re-gerar" dentro das seções.
         * @param {string} sectionName - O nome da seção (ex: 'intro').
         * @param {string} sectionTitle - O título da seção.
         * @param {string} elementId - O ID do elemento HTML da seção.
         */
        window.regenerateSection = (sectionName, sectionTitle, elementId) => {
            const mainButtonIdMap = {
                'intro': 'generateIntroBtn',
                'development': 'generateDevelopmentBtn',
                'climax': 'climaxBtn',
                'conclusion': 'conclusionBtn',
                'cta': 'generateCTABtn'
            };
            const buttonId = mainButtonIdMap[sectionName];
            if (buttonId) {
                const button = document.getElementById(buttonId);
                handleGenerateSection(button, sectionName, sectionTitle, elementId);
            }
        };

        /**
         * Gera prompts de imagem para uma seção específica do roteiro.
         * @param {string} sectionElementId - O ID do elemento HTML da seção (ex: 'introSection').
         */
        window.generatePromptsForSection = async (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            const scriptContentElement = sectionElement.querySelector('p[contenteditable="true"]');
            const promptContainer = sectionElement.querySelector('.prompt-container');
            
            if (!scriptContentElement || !scriptContentElement.textContent.trim()) {
                window.showToast("Por favor, gere o conteúdo do roteiro desta seção primeiro.");
                return;
            }

            const scriptContent = scriptContentElement.textContent;
            
            promptContainer.innerHTML = `<div class="loading-spinner-small"></div>`; // Mostra um spinner

            const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
            const imageStyleSelect = elements.imageStyleSelect.value;
            const customImageStyle = elements.customImageStyle.value.trim();
            let selectedStyleBlock = '';

            let prompt = `Você é um diretor de vídeo. Sua tarefa é ler o trecho de roteiro a seguir e criar prompts de imagem.

**SUA REGRA MAIS IMPORTANTE é manter um ritmo dinâmico.** Não crie uma imagem para cada frase. O objetivo é criar um prompt a cada **15 a 25 segundos de narração**, aproximadamente. Isso significa que você deve LER várias frases, entender o tempo de narração e só então escolher o momento mais impactante DENTRO desse bloco de tempo para criar UM prompt.

**IMAGEM INICIAL INEGOCIÁVEL:** O primeiro prompt de imagem que você criar **DEVE OBRIGATORIAMENTE** corresponder à **PRIMEIRA FRASE COMPLETA** do trecho do roteiro. Sem exceções. O vídeo precisa de um impacto visual imediato.

Encontre os pontos de virada ou as imagens mentais mais fortes dentro desses intervalos de tempo.

Responda APENAS com um array JSON de objetos (com chaves "scriptPhrase" e "imageDescription").

Trecho do roteiro:
---${scriptContent}
---`;
            
            if (imageDescriptionEngine) {
                prompt += `\n\nAlso, ensure the image descriptions incorporate the following quality instructions: "${imageDescriptionEngine}"`;
            }

            if (imageStyleSelect === 'cinematic') {
                const cinematicPromptPart = `Apply a cinematic film still style to these image descriptions: hyper-realistic, masterful cinematography, Arri Alexa 65, vintage anamorphic lenses, deliberate composition, dramatic naturalistic lighting, strong chiaroscuro, extreme attention to micro-details, hyper-realistic textures (skin pores, fabric weaves, material imperfections), rich cinematic color grading, immersive and evocative mood. Avoid cgi, 3d, render, painting, illustration, animation, video game, digital art, cartoon.`;
                prompt += `\n\n${cinematicPromptPart}`;
                selectedStyleBlock = CINEMATIC_STYLE_BLOCK;
            } else if (imageStyleSelect === 'custom' && customImageStyle) {
                prompt += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
                selectedStyleBlock = customImageStyle;
            }

            try {
                const rawResult = await callGroqAPI(prompt, 4000); // Aumentado para 4000 tokens para prompts de imagem
                const cleanedText = cleanGeneratedText(rawResult, true);
                let prompts = [];
                if (cleanedText) {
                    try {
                        prompts = JSON.parse(cleanedText);
                        if (!Array.isArray(prompts)) {
                            console.warn("AI returned non-array JSON, attempting to convert.");
                            prompts = [prompts];
                        }
                    } catch (e) {
                        window.showToast("Erro ao analisar JSON de prompts de imagem. Verifique o console.");
                        console.error("Erro ao analisar JSON de prompts de imagem:", e);
                        prompts = [];
                    }
                } else {
                    window.showToast("Erro: IA não retornou prompts ou o formato está incorreto para esta seção.");
                }

                // Armazena os prompts gerados na estrutura global
                let accumulatedTimeSeconds = 1; // Reinicia para cada seção para cálculo de tempo
                allImagePrompts[sectionElementId] = prompts.map((p, i) => {
                    const time = accumulatedTimeSeconds;
                    accumulatedTimeSeconds += 20; // Estimativa de 20s por cena
                    const mins = Math.floor(time / 60);
                    const secs = Math.floor(time % 60);
                    return { 
                        ...p, 
                        time: `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`, 
                        sequence: String(i + 1).padStart(2, '0'),
                        styleBlock: selectedStyleBlock
                    };
                });

                promptContainer.innerHTML = ''; // Limpa o spinner
                if (allImagePrompts[sectionElementId] && allImagePrompts[sectionElementId].length > 0) {
                    allImagePrompts[sectionElementId].forEach(promptData => {
                        const styleBlockContent = promptData.styleBlock || '';
                        const promptHtml = `
                            <div class="individual-prompt-block">
                                <div class="flex items-center justify-between mb-2">
                                    <p class="prompt-time">${promptData.time} - Cena ${promptData.sequence}</p>
                                    <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${promptData.sequence}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${promptData.sequence}').textContent)">Copiar</button>
                                </div>
                                <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                                <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                                <p id="prompt-content-${sectionElementId}-${promptData.sequence}" class="prompt-description-content">${promptData.imageDescription}</p>
                                <pre id="style-block-${sectionElementId}-${promptData.sequence}" class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                            </div>
                        `;
                        promptContainer.innerHTML += promptHtml;
                    });
                } else {
                    promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta seção.</p>';
                }
                updateButtonStates(); // Atualiza o estado dos botões após gerar prompts
            } catch (error) {
                promptContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar prompts: ${error.message}</p>`;
                console.error(`Error generating prompts for section ${sectionElementId}.`, error);
            }
        };

        /**
         * Sugere trilhas sonoras para uma seção específica do roteiro.
         * @param {string} sectionId - O ID do elemento HTML da seção (ex: 'introSection').
         */
        window.suggestSoundtrack = async (sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const scriptContent = sectionElement.querySelector('p[contenteditable="true"]').textContent;
            const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
            
            if (!scriptContent) {
                window.showToast("Gere o roteiro para esta seção primeiro.");
                return;
            }

            soundtrackContainer.innerHTML = `<div class="loading-spinner-small"></div>`; // Mostra um spinner

            const prompt = `Você é um produtor musical e compositor de trilhas sonoras para filmes. Analise o tone, o ritmo e a emoção do seguinte trecho de roteiro.

Sua tarefa é criar 3 prompts de texto detalhados e prontos para serem usados em uma IA de geração de música (como Suno ou Udio). Cada prompt deve gerar uma trilha sonora instrumental única e de alta qualidade que combine com o roteiro.

Para cada um dos 3 prompts, inclua:
- O gênero/estilo (ex: cinematic, orchestral, ambient, electronic).
- O humor/emoção (ex: inspirational, tense, mysterious, melancholic, epic).
- Instrumentos chave (ex: solo piano, string section, taiko drums, synth pads).
- Influências de estilo (ex: Hans Zimmer style, Lo-fi chillhop, Two Steps from Hell).
- Instruções negativas (ex: no vocals, no saxophone).

Responda APENAS com um array JSON de strings, onde cada string é um prompt musical completo e detalhado.

Trecho do roteiro para analisar:
---
${scriptContent}
---`;
            
            try {
                const rawResult = await callGroqAPI(prompt, 500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const suggestions = JSON.parse(cleanedResult);

                soundtrackContainer.innerHTML = ''; // Limpa o spinner
                if (suggestions && suggestions.length > 0) {
                    let suggestionsHtml = '<ul class="soundtrack-list">';
                    suggestions.forEach(suggestion => {
                        suggestionsHtml += `<li>${suggestion}</li>`;
                    });
                    suggestionsHtml += '</ul>';
                    soundtrackContainer.innerHTML = suggestionsHtml;
                } else {
                    soundtrackContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhuma sugestão de trilha sonora foi gerada.</p>';
                }
            } catch (error) {
                soundtrackContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugestões: ${error.message}</p>`;
            }
        };

        /**
         * Gera títulos de vídeo e ideias de thumbnail.
         */
        const generateTitlesAndThumbnails = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateTitlesAndThumbnailsBtn);
            try {
                const { prompt, maxTokens } = constructScriptPrompt('titles_thumbnails');
                let result = await callGroqAPI(prompt, maxTokens);
                let cleanedResult = cleanGeneratedText(result, true);
                let parsedContent = { titles: [], thumbnails: [] };
                try {
                    if (cleanedResult) {
                        parsedContent = JSON.parse(cleanedResult);
                        generatedTitlesAndThumbnails = parsedContent;
                    }
                } catch (e) {
                    console.error("Falha ao analisar o JSON da IA:", e);
                    console.error("Texto problemático:", cleanedResult);
                    window.showToast("Erro: A IA retornou um formato de título/thumbnail inválido.");
                    generatedTitlesAndThumbnails = null;
                }
                
                const targetSectionElement = document.getElementById('titlesThumbnailsSection');
                if (targetSectionElement) {
                    let titlesListHtml = '<p class="text-red-500">Não foi possível extrair os títulos.</p>';
                    if (parsedContent.titles && parsedContent.titles.length > 0) {
                        titlesListHtml = parsedContent.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                    }
                    
                    let thumbnailsListHtml = '<p class="text-red-500">Não foi possível extrair as thumbnails.</p>';
                    if (parsedContent.thumbnails && parsedContent.thumbnails.length > 0) {
                        thumbnailsListHtml = parsedContent.thumbnails.map((thumb, index) => {
                            const itemClasses = index === 0 ? '' : 'thumbnail-item-separator';
                            return `
                                <div class="${itemClasses}"> 
                                    <p class="font-semibold text-gray-800 dark:text-gray-200 mb-0.5">"${thumb.title}"</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-300 leading-tight">Descrição: ${thumb.description}</p>
                                </div>
                            `;
                        }).join('\n');
                    }
                    
                    const fullInnerHtml = `
                        <div class="whitespace-normal">
                            <div class="section-header">
                                <h3 class="text-gray-800 dark:text-gray-100">Títulos e Thumbnails</h3>
                                <div class="header-buttons">
                                    <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('titlesThumbnailsSection').textContent)">Copiar</button>
                                </div>
                            </div>
                            
                            <div class="mt-4 space-y-6">
                                <div>
                                    <h4 class="font-bold text-lg text-gray-700 dark:text-gray-200 mb-2">Títulos de Vídeos:</h4>
                                    <div class="p-3 border border-gray-200 dark:border-gray-700 rounded-md bg-gray-50 dark:bg-gray-800 shadow-sm space-y-2 text-gray-700 dark:text-gray-300">
                                        ${titlesListHtml}
                                    </div>
                                    <div class="mt-4">
                                        <button class="btn btn-secondary btn-small" onclick="window.analyzeTitles()">
                                            Analisar Potencial de Clique (CTR)
                                        </button>
                                        <div id="ctrAnalysisResult" class="mt-4"></div>
                                    </div>
                                </div>
                                <div>
                                    <h4 class="font-bold text-lg text-gray-700 dark:text-gray-200 mb-2">Thumbnails:</h4>
                                    <div class="p-3 border border-gray-200 dark:border-gray-700 rounded-md bg-gray-50 dark:bg-gray-800 shadow-sm text-gray-700 dark:text-gray-300">${thumbnailsListHtml}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    targetSectionElement.innerHTML = fullInnerHtml;
                    targetSectionElement.classList.remove('hidden');
                    markButtonAsCompleted(buttons.generateTitlesAndThumbnailsBtn.id);
                }
                updateButtonStates();
            } catch (error) {
                window.showToast(`Falha ao gerar Títulos e Thumbnails: ${error.message}`);
                console.error(`Error generating Titles/Thumbnails.`, error);
            } finally {
                hideLoading(buttons.generateTitlesAndThumbnailsBtn);
            }
        };

        /**
         * Analisa o potencial de clique (CTR) dos títulos gerados.
         */
        window.analyzeTitles = async () => {
            if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.titles || generatedTitlesAndThumbnails.titles.length === 0) {
                window.showToast("Gere os títulos primeiro!");
                return;
            }

            const resultContainer = document.getElementById('ctrAnalysisResult');
            resultContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

            const titlesString = generatedTitlesAndThumbnails.titles.join('\n');
            
            const prompt = `Você é um especialista em marketing de conteúdo para o YouTube. Analise a seguinte lista de títulos de vídeo. Para cada um, forneça uma "nota de CTR" de 0 a 10 (onde 10 é um clique quase garantido) e uma sugestão curta e objetiva para melhorá-lo, focando em curiosidade, urgência e benefício claro.

            Responda APENAS com um array JSON. Cada objeto no array deve ter as chaves "titulo_original", "nota_ctr" e "sugestao_melhora".

            Títulos para analisar:
            ---
            ${titlesString}
            ---`;

            try {
                const rawResult = await callGroqAPI(prompt, 2000);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const analysis = JSON.parse(cleanedResult);

                let analysisHtml = '<div class="space-y-4">';
                analysis.forEach(item => {
                    analysisHtml += `
                        <div class="p-3 border border-gray-200 rounded-md dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm">
                            <p class="font-semibold text-gray-800 dark:text-gray-200">${item.titulo_original}</p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de CTR:</strong> <span class="text-indigo-500 font-bold">${item.nota_ctr} / 10</span></p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugestão:</strong> ${item.sugestao_melhora}</p>
                        </div>
                    `;
                });
                analysisHtml += '</div>';
                resultContainer.innerHTML = analysisHtml;

            } catch (error) {
                resultContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao analisar os títulos: ${error.message}</p>`;
            }
        };

        /**
         * Gera a descrição do vídeo e hashtags.
         */
        const generateVideoDescription = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateDescriptionBtn);
            try {
                const { prompt, maxTokens } = constructScriptPrompt('description');
                let result = await callGroqAPI(prompt, maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);
                const targetSectionElement = document.getElementById('videoDescriptionOutputSection');
                if (targetSectionElement) {
                    targetSectionElement.innerHTML = generateSectionHtmlContent(
                        'videoDescriptionOutput', 
                        'Descrição do Vídeo e Hashtags', 
                        result,
                        { showPromptsButton: false, showSoundtrackButton: false } // <-- A MÁGICA ACONTECE AQUI
                    );
                    targetSectionElement.classList.remove('hidden');
                } else {
                    console.error("Target section element with ID 'videoDescriptionOutputSection' not found.");
                    window.showToast("Erro interno: Seção de descrição não encontrada.");
                    return;
                }
                markButtonAsCompleted(buttons.generateDescriptionBtn.id);
                updateButtonStates();
            } catch (error) {
                window.showToast(`Falha ao gerar Descrição do Vídeo: ${error.message}`);
                console.error(`Error generating Video Description.`, error);
            } finally {
                hideLoading(buttons.generateDescriptionBtn);
            }
        };

        /**
         * Realiza o download do roteiro como PDF.
         */
        const downloadPdf = async () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            let y = 10;
            doc.setFontSize(22);
            doc.text("Roteiro Viral", 105, y, null, null, "center");
            y += 10;
            doc.setFontSize(12);
            doc.text(`Canal: ${elements.channelName.value}`, 10, y);
            y += 7;
            doc.text(`Tema: ${elements.videoTheme.value}`, 10, y);
            y += 10;

            const sectionOrder = ['intro', 'development', 'climax', 'conclusion', 'cta', 'videoDescriptionOutput', 'titlesThumbnails'];
            sectionOrder.forEach(id => {
                const sectionElement = document.getElementById(`${id}Section`);
                if (sectionElement && !sectionElement.classList.contains('hidden')) {
                    const title = sectionElement.querySelector('h3').textContent;
                    doc.setFontSize(16);
                    doc.text(title, 10, y);
                    y += 7;
                    doc.setFontSize(12);

                    if (id === 'titlesThumbnails') {
                        const titlesHtmlDiv = sectionElement.querySelector('.p-3:first-of-type');
                        if (titlesHtmlDiv) {
                            const titlesText = Array.from(titlesHtmlDiv.querySelectorAll('p')).map(p => p.textContent).join('\n');
                            const splitTitles = doc.splitTextToSize(`Títulos de Vídeos:\n${titlesText}`, 180);
                            doc.text(splitTitles, 10, y);
                            y += (splitTitles.length * 7) + 5;
                        }

                        const thumbnailsHtmlDiv = sectionElement.querySelector('.p-3:last-of-type');
                        if (thumbnailsHtmlDiv) {
                            const thumbnailsText = Array.from(thumbnailsHtmlDiv.querySelectorAll('div')).map(div => {
                                const thumbTitle = div.querySelector('p:first-of-type').textContent;
                                const thumbDesc = div.querySelector('p:last-of-type').textContent;
                                return `${thumbTitle}\n${thumbDesc}`;
                            }).join('\n\n');
                            const splitThumbnails = doc.splitTextToSize(`Thumbnails:\n${thumbnailsText}`, 180);
                            doc.text(splitThumbnails, 10, y);
                            y += (splitThumbnails.length * 7) + 5;
                        }
                    } else {
                        const content = sectionElement.querySelector('p[contenteditable="true"]').textContent;
                        const splitContent = doc.splitTextToSize(content, 180);
                        doc.text(splitContent, 10, y);
                        y += (splitContent.length * 7) + 5;
                    }

                    if (y > 280) {
                        doc.addPage();
                        y = 10;
                    }
                }
            });

            // Loop através das seções para adicionar os prompts de imagem
            for (const sectionId in allImagePrompts) {
                if (allImagePrompts.hasOwnProperty(sectionId) && allImagePrompts[sectionId].length > 0) {
                    if (y > 250) {
                        doc.addPage();
                        y = 10;
                    }
                    const sectionTitleElement = document.getElementById(sectionId)?.querySelector('h3');
                    const sectionTitle = sectionTitleElement ? sectionTitleElement.textContent : sectionId.replace('Section', '');

                    doc.setFontSize(18);
                    doc.text(`Prompts de Imagem para ${sectionTitle}`, 10, y);
                    y += 10;
                    doc.setFontSize(10);

                    allImagePrompts[sectionId].forEach(promptData => {
                        const promptText = `${promptData.time} - Cena ${promptData.sequence}\nScript Phrase: ${promptData.scriptPhrase}\nImage Description: ${promptData.imageDescription}\n\n`;
                        const splitPrompt = doc.splitTextToSize(promptText, 180);
                        doc.text(splitPrompt, 10, y);
                        y += (splitPrompt.length * 5) + 3;

                        if (y > 280) {
                            doc.addPage();
                            y = 10;
                        }
                    });
                }
            }

            doc.save(`${elements.videoTheme.value.replace(/[^a-zA-Z0-9]/g, '_')}_roteiro.pdf`);
            window.showToast("PDF gerado!");
        };

        /**
         * Reseta o estado da aplicação para um novo roteiro.
         */
        const resetApplicationState = () => {
            elements.videoTheme.value = '';
            elements.videoDescription.value = '';
            elements.centralQuestion.value = '';
            elements.emotionalArc.value = '';
            elements.viralElements.value = '';
            elements.imageDescriptionEngine.value = '';
            elements.imageStyleSelect.value = 'cinematic';
            elements.customImageStyle.value = '';
            toggleCustomImageStyleVisibility();
            elements.narrativeStyle.value = 'direct';
            elements.videoDuration.value = '';

            document.querySelectorAll('#scriptOutput > .script-section').forEach(sec => {
                sec.innerHTML = '';
                sec.classList.add('hidden');
            });

            allImagePrompts = {}; // Limpa todos os prompts de imagem
            generatedTitlesAndThumbnails = null;
            
            resetCompletionIcons();
            updateButtonStates();
            updateProgressBar(); // <-- ADICIONADO AQUI

            window.showToast("Pronto para um novo roteiro!");
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        /**
         * Exporta o estado atual do projeto para um arquivo JSON.
         */
        const exportProject = () => {
            const projectData = {
                inputs: {},
                outputs: {},
                memory: {
                    allImagePrompts: allImagePrompts,
                    generatedTitlesAndThumbnails: generatedTitlesAndThumbnails
                }
            };

            // Salva o estado dos inputs
            for (const key in elements) {
                if (elements[key] && typeof elements[key].value !== 'undefined') {
                    projectData.inputs[key] = elements[key].value;
                }
            }
            // Salva o conteúdo gerado (HTML interno das seções)
            const sectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection', 'videoDescriptionOutputSection', 'titlesThumbnailsSection'];
            sectionIds.forEach(id => {
                const sectionElement = document.getElementById(id);
                if (sectionElement) {
                    projectData.outputs[id] = sectionElement.innerHTML;
                }
            });
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            const fileName = elements.videoTheme.value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro_viral';
            downloadAnchorNode.setAttribute("download", `${fileName}_projeto.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            window.showToast("Projeto exportado com sucesso!");
        };

        /**
         * Renderiza os prompts de imagem para uma seção específica na UI.
         * Usado após carregar um projeto.
         * @param {string} sectionElementId - O ID do elemento HTML da seção.
         */
        const renderImagePromptsForSection = (sectionElementId) => {
            const promptContainer = document.getElementById(sectionElementId)?.querySelector('.prompt-container');
            if (!promptContainer) return;

            promptContainer.innerHTML = ''; // Limpa prompts existentes

            const promptsData = allImagePrompts[sectionElementId];
            if (promptsData && promptsData.length > 0) {
                promptsData.forEach(promptData => {
                    const styleBlockContent = promptData.styleBlock || '';
                    const promptHtml = `
                        <div class="individual-prompt-block">
                            <div class="flex items-center justify-between mb-2">
                                <p class="prompt-time">${promptData.time} - Cena ${promptData.sequence}</p>
                                <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${promptData.sequence}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${promptData.sequence}').textContent)">Copiar</button>
                            </div>
                            <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                            <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                            <p id="prompt-content-${sectionElementId}-${promptData.sequence}" class="prompt-description-content">${promptData.imageDescription}</p>
                            <pre id="style-block-${sectionElementId}-${promptData.sequence}" class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                        </div>
                    `;
                    promptContainer.innerHTML += promptHtml;
                });
            } else {
                promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta seção.</p>';
            }
        };

        /**
         * Importa um projeto de um arquivo JSON.
         * @param {Event} event - O evento de mudança do input de arquivo.
         */
        const importProject = (event) => {
            const file = event.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    resetApplicationState(); // Limpa o estado atual antes de importar

                    // Restaura os inputs
                    for (const key in projectData.inputs) {
                        if (elements[key] && typeof elements[key].value !== 'undefined') {
                            elements[key].value = projectData.inputs[key];
                        }
                    }

                    // Restaura o conteúdo gerado
                    for (const key in projectData.outputs) {
                        const element = document.getElementById(key);
                        if (element && projectData.outputs[key]) {
                            element.innerHTML = projectData.outputs[key];
                            element.classList.remove('hidden');
                        }
                    }

                    // Restaura as variáveis de memória
                    allImagePrompts = projectData.memory.allImagePrompts || {};
                    generatedTitlesAndThumbnails = projectData.memory.generatedTitlesAndThumbnails || null;

                    updateButtonStates();
                    
                    // Marca os botões como concluídos se o conteúdo existir
                    if (document.getElementById('introSection').innerHTML.trim()) markButtonAsCompleted('generateIntroBtn');
                    if (document.getElementById('developmentSection').innerHTML.trim()) markButtonAsCompleted('generateDevelopmentBtn');
                    if (document.getElementById('climaxSection').innerHTML.trim()) markButtonAsCompleted('climaxBtn');
                    if (document.getElementById('conclusionSection').innerHTML.trim()) markButtonAsCompleted('conclusionBtn');
                    if (document.getElementById('ctaSection').innerHTML.trim()) markButtonAsCompleted('generateCTABtn');
                    if (document.getElementById('videoDescriptionOutputSection').innerHTML.trim()) markButtonAsCompleted('generateDescriptionBtn');
                    if (document.getElementById('titlesThumbnailsSection').innerHTML.trim()) markButtonAsCompleted('generateTitlesAndThumbnailsBtn');

                    // Re-renderiza os prompts de imagem para todas as seções
                    for (const sectionId in allImagePrompts) {
                        if (allImagePrompts.hasOwnProperty(sectionId)) {
                            renderImagePromptsForSection(sectionId);
                        }
                    }
                    updateProgressBar(); // <-- ADICIONADO AQUI
                    window.showToast("Projeto importado com sucesso!");

                } catch (err) {
                    window.showToast("Erro: Arquivo de projeto inválido ou corrompido.");
                    console.error("Erro ao importar projeto:", err);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Limpa o input para permitir importar o mesmo arquivo novamente
        };

        /**
         * Analisa o tema e a descrição do vídeo para definir a estratégia de conteúdo.
         */
        const analyzeAndSetStrategy = async () => {
            const theme = elements.videoTheme.value.trim();
            const description = elements.videoDescription.value.trim();

            if (!theme || !description) {
                window.showToast("Por favor, preencha o Tema e a Descrição do Vídeo.");
                return;
            }

            const button = buttons.analyzeStrategyBtn;
            showLoading(button);

            // Opções válidas para cada campo (precisamos disso para a IA)
            const languageStyleOptions = Array.from(elements.languageStyle.options).map(o => o.value).join(', ');
            const videoObjectiveOptions = Array.from(elements.videoObjective.options).map(o => o.value).join(', ');
            const narrativeStyleOptions = Array.from(elements.narrativeStyle.options).map(o => o.value).join(', ');

            const prompt = `Você é um Estrategista de Conteúdo de IA para o YouTube. Sua tarefa é analisar o tema e a descrição de um vídeo e definir a melhor estratégia de conteúdo para ele.

            Tema do Vídeo: "${theme}"
            Descrição do Vídeo: "${description}"

            Com base nisso, preencha os seguintes campos. Responda APENAS com um objeto JSON válido.

            O objeto JSON deve ter as seguintes chaves:
            1.  "target_audience": (string) Descreva em uma frase o público-alvo ideal para este vídeo.
            2.  "language_style": (string) Escolha o melhor estilo de linguagem da seguinte lista: [${languageStyleOptions}].
            3.  "video_objective": (string) Escolha o objetivo principal do vídeo da seguinte lista: [${videoObjectiveOptions}].
            4.  "narrative_style": (string) Escolha a estrutura narrativa mais impactante da seguinte lista: [${narrativeStyleOptions}].
            5.  "central_question": (string) Formule a pergunta central mais intrigante que o vídeo deve responder.
            6.  "emotional_arc": (string) Descreva o arco emocional ideal em uma frase curta (Ex: Curiosidade -> Tensão -> Revelação -> Inspiração).

            Analise profundamente o tema e a descrição para fazer as escolhas mais coesas e eficazes.`;

            try {
                const rawResult = await callGroqAPI(prompt, 1000);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const strategy = JSON.parse(cleanedResult);

                // Preenche os campos da interface com a resposta da IA
                if(strategy.target_audience) elements.targetAudience.value = strategy.target_audience;
                if(strategy.language_style) elements.languageStyle.value = strategy.language_style;
                if(strategy.video_objective) elements.videoObjective.value = strategy.video_objective;
                if(strategy.narrative_style) elements.narrativeStyle.value = strategy.narrative_style; // CORRIGIDO AQUI
                if(strategy.central_question) elements.centralQuestion.value = strategy.central_question;
                if(strategy.emotional_arc) elements.emotionalArc.value = strategy.emotional_arc;

                window.showToast("Estratégia definida com sucesso!");

            } catch (error) {
                window.showToast(`Falha ao definir estratégia: ${error.message}`);
                console.error("Erro na análise estratégica:", error);
            } finally {
                hideLoading(button);
            }
        };

        /**
         * Ativa/desativa o modo escuro da aplicação.
         * @param {boolean} isDark - True para ativar o modo escuro, false para desativar.
         */
        const setDarkMode = (isDark) => {
            if (isDark) {
                document.body.classList.add('dark');
                if (elements.moonIcon) elements.moonIcon.classList.add('hidden');
                if (elements.sunIcon) elements.sunIcon.classList.remove('hidden');
                localStorage.setItem('darkMode', 'enabled');
            } else {
                document.body.classList.remove('dark');
                if (elements.moonIcon) elements.moonIcon.classList.remove('hidden');
                if (elements.sunIcon) elements.sunIcon.classList.add('hidden');
                localStorage.setItem('darkMode', 'disabled');
            }
        };

        /**
         * Controla a visibilidade e o conteúdo da barra de ações flutuante com base na rolagem.
         */
        window.handleFloatingActionBar = () => {
            const mainActions = document.getElementById('mainActions');
            const quickActions = document.getElementById('quickActions');
            const scriptOutput = document.getElementById('scriptOutput');
            
            if (!scriptOutput) return;

            const actionBar = elements.floatingActionBar;
            // Ponto de gatilho para a barra flutuante (um pouco antes da área de output)
            const triggerPoint = scriptOutput.offsetTop - actionBar.offsetHeight - 50; // 50px de buffer

            if (window.scrollY > triggerPoint) {
                // Se rolou para a área de resultados, mostra a barra e as Ações Rápidas
                actionBar.classList.add('visible');
                mainActions.classList.add('hidden');
                quickActions.classList.remove('hidden');
            } else if (window.scrollY > 150) { // Um pequeno buffer para não aparecer imediatamente no topo
                // Se rolou um pouco, mas não chegou nos resultados, mostra a barra com as Ações Principais
                actionBar.classList.add('visible');
                mainActions.classList.remove('hidden');
                quickActions.classList.add('hidden');
            } else {
                // Se está no topo, esconde a barra
                actionBar.classList.remove('visible');
            }
        };

        /**
         * Alterna o estado de um acordeão (abrir/fechar).
         * @param {string} bodyId - O ID do corpo do acordeão.
         * @param {string} arrowId - O ID do ícone de seta do acordeão.
         */
        window.toggleAccordion = (bodyId, arrowId) => {
            const body = document.getElementById(bodyId);
            const arrow = document.getElementById(arrowId);
            if (body && arrow) {
                body.classList.toggle('open');
                arrow.classList.toggle('open');
            }
        };

        // ==========================================================
        // NOVA FUNÇÃO PARA ATUALIZAR A BARRA DE PROGRESO
        // ==========================================================
        const updateProgressBar = () => {
            // Lista de todas as tarefas que contam para o progresso
            const taskButtonIds = [
                'generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 
                'conclusionBtn', 'generateCTABtn', 'generateDescriptionBtn', 
                'generateTitlesAndThumbnailsBtn'
            ];
            const totalTasks = taskButtonIds.length;

            let completedTasks = 0;
            taskButtonIds.forEach(id => {
                const button = document.getElementById(id);
                if (button && button.classList.contains('btn-success')) {
                    completedTasks++;
                }
            });

            const percentage = Math.round((completedTasks / totalTasks) * 100);

            // Atualiza a UI
            if (elements.progressBar && elements.progressText) {
                elements.progressBar.style.width = `${percentage}%`;
                elements.progressText.textContent = `${percentage}%`;

                if (percentage === 100) {
                    elements.progressBar.textContent = "Projeto Pronto!"; // Atualiza o texto diretamente na barra
                    elements.progressBar.style.backgroundColor = 'var(--primary-color)';
                } else {
                     // Garante que a cor volte ao verde se não for 100%
                    elements.progressBar.style.backgroundColor = 'var(--success-color)';
                }
            }
        };

        // ==========================================================
        // ================== INICIALIZAÇÃO =======================
        // ==========================================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Initializing app."); 
            
            // Adiciona as novas referências de elementos
            elements.progressBar = document.getElementById('progressBar');
            elements.progressText = document.getElementById('progressText');

            // Configura os event listeners para os botões
            const setupClick = (originalId) => {
                const floatBtn = document.getElementById(`float_${originalId}`);
                if (floatBtn) {
                    floatBtn.addEventListener('click', () => {
                        document.getElementById(originalId).click();
                    });
                }
            };

            // Conecta os botões flutuantes aos originais
            // Iterar sobre todos os botões que têm um flutuante correspondente
            const allButtonIds = Object.keys(buttons);
            allButtonIds.forEach(id => {
                if (id.startsWith('generate') || id.startsWith('climax') || id.startsWith('conclusion') || id.startsWith('cta') || id.startsWith('download') || id.startsWith('reset') || id.startsWith('export') || id.startsWith('import')) {
                    setupClick(id);
                }
            });
            
            // Adiciona os listeners de ação aos botões originais
            if (buttons.generateIntroBtn) buttons.generateIntroBtn.addEventListener('click', () => handleGenerateSection(buttons.generateIntroBtn, 'intro', 'Introdução', 'intro'));
            if (buttons.generateDevelopmentBtn) buttons.generateDevelopmentBtn.addEventListener('click', () => handleGenerateSection(buttons.generateDevelopmentBtn, 'development', 'Desenvolvimento', 'development'));
            if (buttons.climaxBtn) buttons.climaxBtn.addEventListener('click', () => handleGenerateSection(buttons.climaxBtn, 'climax', 'Clímax', 'climax'));
            if (buttons.conclusionBtn) buttons.conclusionBtn.addEventListener('click', () => handleGenerateSection(buttons.conclusionBtn, 'conclusion', 'Conclusão', 'conclusion'));
            if (buttons.generateCTABtn) buttons.generateCTABtn.addEventListener('click', () => handleGenerateSection(buttons.generateCTABtn, 'cta', 'Chamada para Ação', 'cta'));
            if (buttons.generateTitlesAndThumbnailsBtn) buttons.generateTitlesAndThumbnailsBtn.addEventListener('click', generateTitlesAndThumbnails);
            if (buttons.generateDescriptionBtn) buttons.generateDescriptionBtn.addEventListener('click', generateVideoDescription);
            if (buttons.resetScriptBtn) buttons.resetScriptBtn.addEventListener('click', resetApplicationState);
            if (buttons.downloadPdfBtn) buttons.downloadPdfBtn.addEventListener('click', downloadPdf);
            if (buttons.exportProjectBtn) buttons.exportProjectBtn.addEventListener('click', exportProject); // Listener para o botão de exportar
            
            // Outros listeners
            if (elements.fullScreenAlertCloseBtn) elements.fullScreenAlertCloseBtn.addEventListener('click', hideFullScreenAlert);
            if (elements.imageStyleSelect) elements.imageStyleSelect.addEventListener('change', toggleCustomImageStyleVisibility);
            if (elements.darkModeToggle) {
                elements.darkModeToggle.addEventListener('click', () => {
                    const isDarkMode = document.body.classList.contains('dark');
                    setDarkMode(!isDarkMode);
                });
            }
            if (buttons.analyzeStrategyBtn) buttons.analyzeStrategyBtn.addEventListener('click', analyzeAndSetStrategy);
            if (buttons.importProjectBtn) {
                buttons.importProjectBtn.addEventListener('click', () => elements.importFileInput.click());
                elements.importFileInput.addEventListener('change', importProject);
            }

            // Define o estado inicial dos botões e do modo escuro
            updateButtonStates();
            if (localStorage.getItem('darkMode') === 'enabled') {
                setDarkMode(true);
            }
            // Adiciona o listener de rolagem para a barra flutuante
            window.addEventListener('scroll', window.handleFloatingActionBar);
            updateProgressBar(); // <-- ADICIONADO AQUI
        });
    </script>
</body>
</html>
