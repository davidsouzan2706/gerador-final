<<<<<<< HEAD
<!--Revertendo-01-->
=======
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros Virais v2.0 - O Painel do Projeto</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF para gera√ß√£o de PDF (ainda inclu√≠do, mas n√£o usado para download principal) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Fontes Google - Carlito para legibilidade -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Carlito:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üöÄ</text></svg>">
    <style>
        /* ========================================================== */
        /* ==================== ESTILOS GERAIS ==================== */
        /* ========================================================== */
        /* Vari√°veis CSS para cores consistentes e f√°cil manuten√ß√£o */
        :root {
            --primary-color: #4f46e5; /* Indigo-600 */
            --primary-hover: #4338ca; /* Indigo-700 */
            --secondary-bg: #e0e7ff; /* Indigo-100 */
            --secondary-text: #4338ca; /* Indigo-700 */
            --secondary-hover: #c7d2fe; /* Indigo-200 */
            --success-color: #10B981; /* Green-500 */
            --success-hover: #059669; /* Green-600 */
            --text-dark: #1f2937; /* Gray-800 */
            --text-medium: #4b5563; /* Gray-600 */
            --text-light: #6b7280; /* Gray-500 */
            --bg-light: #f9fafb; /* Gray-50 */
            --border-light: #e5e7eb; /* Gray-200 */
        }

        body {
            font-family: 'Carlito', sans-serif;
            background-color: #f0f2f5; /* Cinza bem claro */
            color: var(--text-dark); /* Cor de texto padr√£o para modo claro */
        }
        .dark body {
            background-color: #111827; /* Cinza 900 */
            color: #d1d5db; /* Cor de texto padr√£o para modo escuro */
        }
        .container {
            max-width: 1024px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #ffffff; /* Branco */
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
        }
        .dark .container {
            background-color: #1f2937; /* Cinza 800 */
        }
        .input-group label {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.5rem;
            display: block;
        }
        /* ========================================================== */
        /* ======== ESTILIZA√á√ÉO DEFINITIVA DE INPUTS E FORMS ======== */
        /* ========================================================== */
        /* Classe Mestra para Fundos de Componentes */
        .card-background {
            background-color: #ffffff; /* Padr√£o (Claro) */
            border: 1px solid var(--border-light);
        }
        .dark .card-background {
            background-color: #1f2937; /* Escuro */
            border: 1px solid #4b5563;
        }

        /* --- ESTADO PADR√ÉO (MODO CLARO) --- */
        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none !important;
            border-color: var(--primary-color) !important;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2) !important;
            background-color: #ffffff !important; /* Explicitly white on focus in light mode */
        }
        /* --- ESTADO MODO ESCURO --- */
        .dark .input-group input:focus,
        .dark .input-group select:focus,
        .dark .input-group textarea:focus {
            border-color: #6366f1 !important; /* indigo-500 */
            background-color: #4b5563 !important; /* gray-600 */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3) !important;
        }
        /* --- CORRE√á√ÉO PARA O PLACEHOLDER --- */
        .dark .input-group input::placeholder,
        .dark .input-group textarea::placeholder {
            color: #9ca3af; /* gray-400 */
        }
        /* Cor de texto para elementos no modo escuro */
        .dark h1, .dark h2, .dark h3, .dark h4, .dark label {
            color: #f3f4f6;
        }
        .dark .input-group input, .dark .input-group select, .dark .input-group textarea {
            color: #f9fafb;
        }


        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: inline-flex; /* Para alinhar texto e spinner/√≠cone */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: none;
            white-space: nowrap; /* Evita que o texto do bot√£o quebre linha */
        }
        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-primary {
            background-color: var(--primary-color);
            color: #ffffff;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }
        .btn-secondary {
            background-color: var(--secondary-bg);
            color: var(--secondary-text);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--secondary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.15);
        }
        .btn-success {
            background-color: var(--success-color) !important; /* !important para sobrescrever */
            color: #ffffff !important;
        }
        .btn-success:hover:not(:disabled) {
            background-color: var(--success-hover) !important;
        }

        /* Loading Spinner */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        .btn-secondary .loading-spinner {
            border: 4px solid rgba(67, 56, 202, 0.2);
            border-left-color: var(--secondary-text);
        }
        .loading-spinner.hidden { display: none; }
        .button-text.hidden { display: none; }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Icone de Conclus√£o */
        /* REMOVIDO: .completion-icon { ... } */
        /* REMOVIDO: .completion-icon.hidden { display: none; } */

        /* ========================================================== */
        /* ==================== UI MELHORADA ====================== */
        /* ========================================================== */
        .accordion-item {
            border: 1px solid var(--border-light);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden; /* Garante que o conte√∫do escondido n√£o vaze */
            background-color: var(--bg-light);
        }
        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            cursor: pointer;
            user-select: none; /* Impede sele√ß√£o de texto ao clicar */
        }
        /* Estilo para o cabe√ßalho do acorde√£o ativo */
        .accordion-header.active {
            background-color: var(--secondary-bg);
        }
        .dark .accordion-header.active {
            background-color: #374151; /* Gray-700 */
        }
        .header-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .header-buttons {
            display: flex;
            gap: 0.5rem; /* Espa√ßamento entre os bot√µes de a√ß√£o */
        }
        .accordion-header h3 {
            margin-bottom: 0; /* Remove a margem padr√£o do h3 */
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-dark);
        }
        .accordion-arrow {
            transition: transform 0.3s ease-in-out;
        }
        .accordion-arrow.open {
            transform: rotate(180deg);
        }
        .accordion-body {
            max-height: 0; /* Escondido por padr√£o */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
            padding: 0 1.5rem; /* Padding vertical zero quando fechado */
        }
        /* For√ßa o fundo correto para o corpo do acorde√£o */
        .accordion-body {
            background-color: #ffffff; /* Fundo branco padr√£o (Modo Claro) */
        }
        /* Define a cor correta para o fundo do corpo no Modo Escuro */
        .dark .accordion-body {
            background-color: #1f2937; /* Mesmo fundo do container (Cinza 800) */
        }
        /* Garante a cor de texto correta para o conte√∫do gerado */
        .generated-content-wrapper {
            color: var(--text-dark); /* Garante texto escuro no modo claro */
            line-height: 1.6; /* Melhora a legibilidade */
        }
        .dark .generated-content-wrapper {
            color: #d1d5db; /* Garante texto claro no modo escuro (Gray-300) */
        }
        .accordion-body.open {
            max-height: 5000px; /* Valor grande para "abrir" */
            padding: 1rem 1.5rem 1.5rem; /* Padding quando aberto */
        }
        .accordion-body .generated-content-wrapper[contenteditable="true"] {
            outline: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: box-shadow 0.2s, background-color 0.2s;
        }
        .accordion-body .generated-content-wrapper[contenteditable="true"]:focus {
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
            background-color: #eef2ff; /* Fundo levemente azulado ao editar */
        }

        /* Bot√µes de Copiar e Re-gerar dentro das se√ß√µes */
        .copy-btn, .regenerate-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            white-space: nowrap;
        }
        .copy-btn {
            background-color: var(--primary-color);
            color: #ffffff;
        }
        .copy-btn:hover {
            background-color: var(--primary-hover);
        }
        .regenerate-btn {
            background-color: var(--secondary-bg);
            color: var(--secondary-text);
        }
        .regenerate-btn:hover {
            background-color: var(--secondary-hover);
        }
        
        /* Se√ß√µes de Prompts e Trilha Sonora */
        .section-prompts, .section-soundtrack {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #d1d5db;
        }
        .btn-small {
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
        }
        .loading-spinner-small {
            border: 3px solid rgba(67, 56, 202, 0.2);
            border-left-color: var(--secondary-text);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }
        .individual-prompt-block {
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .prompt-time {
            font-size: 0.75rem;
            color: var(--primary-color);
            font-weight: 700;
        }
        .prompt-phrase {
            font-size: 0.875rem;
            color: var(--text-dark);
            font-weight: 700;
            line-height: 1.4;
        }
        .prompt-description-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-medium);
            margin-top: 0.5rem;
            border-top: 1px dashed var(--border-light);
            padding-top: 0.5rem;
        }
        .prompt-description-content {
            font-size: 0.9rem;
            color: var(--text-dark);
            line-height: 1.5;
        }
        pre {
            background-color: var(--bg-light);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-medium);
            overflow-x: auto; /* Para lidar com blocos de estilo longos */
            white-space: pre-wrap; /* Quebra linhas longas */
            word-break: break-all; /* Quebra palavras longas */
        }
        .soundtrack-list {
            list-style-type: disc;
            padding-left: 20px;
            font-size: 0.9rem;
            color: var(--text-dark);
        }
        .soundtrack-list li { margin-bottom: 0.5rem; }

        /* Separador para Thumbnails */
        .thumbnail-item-separator {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-light);
        }

        /* Toast Notification */
        #toastNotification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7); color: #fff; padding: 10px 20px;
            border-radius: 8px; font-size: 0.9rem; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1001; white-space: nowrap;
        }
        #toastNotification.toast-visible { opacity: 1; visibility: visible; }

        /* Alerta Full-Screen */
        #fullScreenAlertOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center;
            align-items: center; z-index: 1000; visibility: hidden; opacity: 0;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #fullScreenAlertOverlay.visible { visibility: visible; opacity: 1; }
        #fullScreenAlertBox {
            /* Removido background-color e border para usar .card-background */
            padding: 2.5rem; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); text-align: center; max-width: 500px;
            width: 90%; position: relative; transform: translateY(-20px);
            transition: transform 0.3s ease-out;
        }
        #fullScreenAlertOverlay.visible #fullScreenAlertBox { transform: translateY(0); }
        #fullScreenAlertBox p { font-size: 1.1rem; color: var(--text-dark); margin-bottom: 1.5rem; line-height: 1.6; }
        #fullScreenAlertBox button {
            background-color: var(--primary-color); color: #ffffff; padding: 0.75rem 1.5rem;
            border-radius: 8px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; border: none;
        }
        #fullScreenAlertBox button:hover { background-color: var(--primary-hover); }

        /* ========================================================== */
        /* ================= BARRA FLUTUANTE ====================== */
        /* ========================================================== */
        .floating-action-bar {
            position: fixed; top: 0; left: 0; width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 999; padding: 0.75rem 0;
            transform: translateY(-100%); opacity: 0; visibility: hidden;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .floating-action-bar.visible { transform: translateY(0); opacity: 1; visibility: visible; }
        .action-bar-content {
            max-width: 1024px; margin: 0 auto; padding: 0 2rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .action-bar-buttons-group {
            display: flex; align-items: center; gap: 0.75rem;
            width: 100%; /* Garante que o grupo ocupe o espa√ßo */
        }
        .action-bar-buttons-group.hidden { display: none; }
        .action-bar-buttons-group .action-bar-title {
            white-space: nowrap; /* Impede que o t√≠tulo quebre linha */
            font-weight: 600;
            color: var(--text-dark);
        }
        .action-bar-buttons-group .btn-container {
            display: flex; gap: 0.75rem; justify-content: flex-end; width: 100%;
        }
        .btn-container .btn {
            padding: 0.5rem 1rem; /* Um pouco menores */
            font-size: 0.875rem;
        }
        /* Corre√ß√£o para o espa√ßamento dos bot√µes clonados */
        .action-bar-buttons-group .btn-container .btn { margin-left: 0.75rem; }
        .action-bar-buttons-group .btn-container .btn:first-child { margin-left: 0; }

        /* ========================================================== */
        /* ======== ESTILOS PARA A BARRA DE PROGRESO ========= */
        /* ========================================================== */
        #progressBar {
            transition: width 0.5s ease-in-out; /* Anima√ß√£o suave do crescimento da barra */
            background-color: var(--success-color); /* Usa a nossa cor de sucesso verde! */
        }

        /* ========================================================== */
        /* ===== CORRE√á√ÉO DE COR DE TEXTO PARA MODO CLARO ===== */
        /* ========================================================== */
        /* REMOVIDO: body:not(.dark) #titlesThumbnailsSection .p-3 p { color: #374151; } */
        /* REMOVIDO: body:not(.dark) #titlesThumbnailsSection .font-semibold { color: #1f2937; } */

        /* ========================================================== */
        /* ==================== MODO ESCURO ======================= */
        /* ========================================================== */
        body.dark {
            /* background-color e color j√° definidos acima */
        }
        .dark .container, .dark .accordion-item {
            /* background-color j√° definido acima */
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }
        .dark .accordion-item { border-color: #4b5563; }
        .dark .floating-action-bar { background-color: rgba(31, 41, 55, 0.9); }
        .dark .action-bar-title, .dark h3, .dark h4, .dark label, .dark p { /* color j√° definido acima */ }
        .dark .text-gray-500 { color: #9ca3af; }
        .dark .input-group label { /* color j√° definido acima */ }
        /* As regras para .dark .input-group input, select, textarea j√° est√£o no bloco definitivo acima */
        .dark .bg-indigo-50 { background-color: #374151 !important; }
        .dark .border-indigo-200 { border-color: #4b5563 !important; }
        .dark .text-indigo-800 { color: #a5b4fc !important; }
        .dark .bg-gray-50 { background-color: #374151 !important; }
        .dark .border-gray-200 { border-color: #4b5563 !important; }
        .dark .accordion-body .generated-content-wrapper[contenteditable="true"]:focus {
            background-color: #4b5563;
        }
        .dark .individual-prompt-block {
            /* background-color e border j√° definidos por .card-background */
        }
        .dark .prompt-phrase { color: #f3f4f6; }
        .dark .prompt-description-label { color: #9ca3af; }
        .dark .prompt-description-content { color: #d1d5db; }
        .dark pre { background-color: #374151 !important; color: #d1d5db; }
        .dark #darkModeToggle { color: #9ca3af; }

        /* Corre√ß√£o Espec√≠fica para Modo Escuro */
        /* Garante que o input do tema siga as regras */
        .dark #videoTheme.card-background {
            background-color: #374151 !important; 
            border-color: #4b5563 !important; 
        }
        /* Garante que o container dos bot√µes de gera√ß√£o siga as regras */
        .dark #scriptGenerationControls.card-background {
            background-color: #1f2937 !important; /* Cinza 800 */
            border-top: 1px solid #4b5563 !important; /* Adiciona uma borda superior para separar */
            border-left: none !important;
            border-right: none !important;
            border-bottom: none !important;
        }

        /* ========================================================== */
        /* ==================== ESTILOS TOOLTIP ===================== */
        /* ========================================================== */
        .tooltip {
            position: relative;
            cursor: help;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #e0e7ff; /* Indigo-100 */
            color: #4338ca; /* Indigo-700 */
            font-weight: bold;
            font-size: 0.8rem;
            /* Removido border para usar .card-background, mas manteremos o border-color para a borda espec√≠fica do tooltip */
            border-color: #c7d2fe;
        }
        .dark .tooltip {
            background-color: #4b5563; /* Gray-600 */
            color: #e5e7eb; /* Gray-200 */
            border-color: #374151; /* Gray-700 */
        }
        /* Esconde o tooltip por padr√£o */
        .tooltip::before, .tooltip::after {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            position: absolute;
            bottom: 150%; /* Posiciona acima do (?) */
            left: 50%;
            transform: translateX(-50%) translateY(10px); /* Come√ßa um pouco abaixo */
            z-index: 10;
        }
        /* Mostra o tooltip no hover */
        .tooltip:hover::before, .tooltip:hover::after {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0); /* Sube para a posi√ß√£o final */
        }
        /* Estilo da caixa de texto do tooltip */
        .tooltip::before {
            content: attr(data-tooltip); /* Pega o texto do atributo! */
            background-color: #1f2937; /* Gray-800 */
            color: #f9fafb; /* Gray-50 */
            padding: 0.75rem;
            border-radius: 8px;
            width: 300px; /* Largura do tooltip */
            text-align: left;
            white-space: pre-wrap; /* Respeita as quebras de linha do atributo */
            font-size: 0.85rem;
            line-height: 1.5;
            font-weight: normal;
        }
        .dark .tooltip::before {
            background-color: #374151; /* Gray-700 */
        }
        /* Estilo da setinha do tooltip */
        .tooltip::after {
            content: '';
            border-width: 6px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent; /* Seta aponta para baixo */
            margin-left: -6px; /* Centraliza a seta */
        }
        .dark .tooltip::after {
            border-color: #374151 transparent transparent transparent;
        }
        .dark .section-prompts, .dark .section-soundtrack { border-top-color: #4b5563; }
        .dark .soundtrack-list { color: #d1d5db; }

        /* Anima√ß√£o para surgimento suave das se√ß√µes */
        @keyframes fadeInSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .animate-fade-in {
            animation: fadeInSlideUp 0.5s ease-out forwards;
        }

        /* ========================================================== */
        /* ============ ESTILOS MODO FOCO - VERS√ÉO FINAL ============ */
        /* ========================================================== */
        /* Quando o modo foco est√° ativo... */
        /* 1. Esconde os elementos que n√£o queremos ver */
        body.zen-mode .floating-action-bar,
        body.zen-mode #mainInputsGrid,
        body.zen-mode #progressBarContainer,
        body.zen-mode #assetsColumn,
        body.zen-mode .absolute.top-4.right-4, /* Esconde os bot√µes do canto */
        body.zen-mode .container > h1,
        body.zen-mode .container > p {
            display: none !important;
        }

        /* 2. Ajusta o container e o grid principal */
        body.zen-mode .container {
            max-width: 100%;
            padding: 1rem;
        }

        body.zen-mode #projectDashboard .grid {
            display: block; /* Faz o grid se comportar como um bloco normal */
        }

        /* 3. Expande a coluna do roteiro para ocupar todo o espa√ßo */
        body.zen-mode #scriptColumn {
            max-height: none; 
            grid-column: auto; /* Reseta as regras de coluna do grid */
        }
        /* Mostra o bot√£o de sair apenas no Modo Foco */
        body.zen-mode #exitZenModeBtn {
            display: inline-flex;
        }
        
        /* ========================================================== */
        /* Estilos para a coluna de roteiro com controles fixos */
        /* ========================================================== */
        #scriptColumn {
            /* Define uma altura m√°xima para a coluna, para que a rolagem interna funcione */
            /* 'vh' √© a altura da viewport (tela vis√≠vel) */
            max-height: 90vh; 
        }
        #scriptSectionsContainer {
            /* Permite que este cont√™iner de acorde√µes ocupe todo o espa√ßo dispon√≠vel e role */
            flex-grow: 1;
            overflow-y: auto;
        }
        /* ========================================================== */
        /* ====== PAINEL DE BOT√ïES STICKY - DESIGN FINAL ELEGANTE ===== */
        /* ========================================================== */
        #scriptGenerationControls {
            position: sticky;
            bottom: 0;
            z-index: 10;
            padding: 1rem 1.5rem; /* Espa√ßamento interno consistente */

            /* MANTIDO: O efeito de vidro fosco */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);

            /* ADICIONADO: Sombra sutil para o efeito flutuante */
            box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.08);

            /* Garante que o painel ocupe a largura da coluna e tenha as bordas inferiores arredondadas */
            border-bottom-left-radius: 0.5rem; /* 8px */
            border-bottom-right-radius: 0.5rem; /* 8px */
            
            /* --- Estilos para MODO CLARO --- */
            background-color: rgba(255, 255, 255, 0.75); /* Fundo branco com mais transpar√™ncia */
            border-top: 1px solid rgba(0, 0, 0, 0.07); /* Borda superior muito sutil */
        }
        
        .dark #scriptGenerationControls {
            /* --- Estilos para MODO ESCURO --- */
            background-color: rgba(31, 41, 55, 0.75); /* Fundo cinza-800 com mais transpar√™ncia */
            border-top-color: rgba(255, 255, 255, 0.1); /* Borda superior clara e sutil */
            box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.2); /* Sombra um pouco mais forte para o modo escuro */
        }

        /* Ajuste fino no t√≠tulo "Gerar Se√ß√µes do Roteiro" dentro do painel */
        #scriptGenerationControls h3 {
            color: var(--text-dark) !important;
        }
        .dark #scriptGenerationControls h3 {
            color: #f3f4f6 !important;
        }

        /* ========================================================== */
        /* =============== ESTILOS DE IMPRESS√ÉO (PDF) =============== */
        /* ========================================================== */
        @media print {
            /* Esconde tudo que n√£o est√° no nosso container de impress√£o */
            body > *:not(#print-container) {
                display: none !important;
            }

            /* Regras para o container de impress√£o */
            #print-container, #print-container * {
                visibility: visible; /* Garante que ele e TODOS os seus filhos sejam vis√≠veis */
                color: #000 !important; /* FOR√áA tudo dentro dele a ser preto */
                background-color: #fff !important; /* Garante fundo branco */
            }

            #print-container {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                padding: 1.5cm; /* Margens de documento */
                font-size: 11pt;
            }

            .print-section-title {
                font-size: 16pt;
                font-weight: bold;
                margin-top: 24px;
                margin-bottom: 12px;
                border-bottom: 1px solid #ccc;
                padding-bottom: 4px;
            }

            .print-section-content {
                line-height: 1.6;
                white-space: pre-wrap; /* Respeita as quebras de linha */
            }
        }

        /* ========================================================== */
        /* ========= CORRE√á√ïES FINAIS PARA MODO ESCURO ========== */
        /* ========================================================== */
        /* Garante que o input focado no modo escuro tenha o fundo correto */
        .dark .input-group input:focus {
            background-color: #4b5563 !important; /* gray-600 */
        }
        /* Garante que os blocos de prompt individuais fiquem escuros */
        .dark .individual-prompt-block {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        /* Garante que o texto dentro dos prompts fique claro */
        .dark .prompt-phrase,
        .dark .prompt-description-content {
            color: #d1d5db !important; /* gray-300 */
        }
        /* Garante que o fundo do <pre> tamb√©m fique escuro */
        .dark .individual-prompt-block pre {
            background-color: #374151 !important; /* gray-700 */
        }

        /* ========================================================== */
        /* ========= CORRE√á√ïES FINAIS PARA MODO CLARO ========== */
        /* ========================================================== */
        /* Define a cor padr√£o (Modo Claro) para os t√≠tulos do dashboard */
        #projectDashboard h2,
        #projectDashboard h3 {
            color: var(--text-dark) !important;
        }
        /* Define a cor para o Modo Escuro, garantindo que ela sobrescreva o padr√£o */
        .dark #projectDashboard h2,
        .dark #projectDashboard h3 {
            color: #f3f4f6 !important; /* Cor de texto clara */
        }

        /* ========================================================== */
        /* ========= BLINDAGEM DE ESTILO PARA PROMPTS ========== */
        /* ========================================================== */
        /* Estilo para o <pre> em MODO CLARO dentro do prompt */
        .individual-prompt-block pre {
            background-color: var(--bg-light) !important; /* Ex: #f9fafb (cinza 50) */
            color: var(--text-medium) !important; /* Ex: #4b5563 (cinza 600) */
        }
        /* Estilo para o <pre> em MODO ESCURO dentro do prompt */
        .dark .individual-prompt-block pre {
            background-color: #374151 !important; /* Cinza 700 */
            color: #d1d5db !important; /* Cinza 300 */
        }

        /* ========================================================== */
        /* ==== BLINDAGEM FINAL DE TEXTOS PARA O PAINEL (AMBAS COLUNAS) - CORRIGIDO ==== */
        /* ========================================================== */
        /* Define a cor de texto padr√£o (MODO CLARO) para o conte√∫do dos pain√©is */
        /* MODIFICADO: Adicionamos os IDs dos containers de conte√∫do gerado */
        #projectDashboard #videoDescriptionContent,
        #projectDashboard #titlesThumbnailsContent,
        #projectDashboard .card-background p,
        #projectDashboard #projectDashboard .card-background li, /* Added specific rule for li inside card-background */
        #projectDashboard .card-background strong,
        #projectDashboard .asset-card-placeholder,
        #projectDashboard .list-disc {
            color: var(--text-dark) !important;
        }

        /* Define a cor de texto (MODO ESCURO) para o conte√∫do dos pain√©is */
        /* MODIFICADO: Adicionamos os IDs dos containers de conte√∫do gerado */
        .dark #projectDashboard #videoDescriptionContent,
        .dark #projectDashboard #titlesThumbnailsContent,
        .dark #projectDashboard .card-background p,
        .dark #projectDashboard .card-background li, /* Added specific rule for li inside card-background */
        .dark #projectDashboard .card-background strong,
        .dark #projectDashboard .asset-card-placeholder,
        .dark #projectDashboard .list-disc {
            color: #d1d5db !important;
        }

        /* Ajuste espec√≠fico para os t√≠tulos H3 e H4 dentro do painel */
        #projectDashboard h3, #projectDashboard h4 {
            color: var(--text-dark) !important;
        }
        .dark #projectDashboard h3, .dark #projectDashboard h4 {
            color: #f3f4f6 !important;
        }
        /* ========================================================== */
        /* ====== CORRE√á√ÉO FINAL DE CORES DE T√çTULOS (MODO CLARO) ===== */
        /* ========================================================== */

        /* Garante que o H1 principal e os textos da barra de progresso
           tenham a cor correta no MODO CLARO, sem afetar o modo escuro. */
        .container > h1,
        #progressBarContainer .flex > span {
            color: var(--text-dark); /* Cor escura padr√£o para o Modo Claro */
        }

        /* Garante que eles voltem a ser claros no MODO ESCURO para sobrescrever o padr√£o */
        .dark .container > h1 {
             color: #f3f4f6; /* Cinza 100 - Bem claro para o t√≠tulo principal */
        }
        .dark #progressBarContainer .flex > span {
            color: #d1d5db; /* Cinza 300 - Padr√£o de texto do modo escuro */
        }
        /* ========================================================== */
        /* === CORRE√á√ÉO FINAL - FUNDO DO ACORDE√ÉO NO MODO ESCURO ==== */
        /* ========================================================== */
        /* Esta regra garante que o item do acorde√£o (e por heran√ßa, seu
           cabe√ßalho inativo) tenha o fundo escuro correto no Modo Escuro,
           sobrescrevendo a regra geral do modo claro. */
        .dark .accordion-item {
            background-color: #1f2937; /* Cinza 800 - o mesmo do container */
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900">
    <!-- ========================================================== -->
    <!-- ===== BARRA FLUTUANTE COM BOT√ïES INDEPENDENTES ===== -->
    <!-- ========================================================== -->
    <div id="floatingActionBar" class="floating-action-bar">
        <div class="action-bar-content">
            <!-- Grupo de A√ß√µes Principais -->
            <div id="mainActions" class="action-bar-buttons-group">
                <span class="action-bar-title">Passo 1:</span>
                <div class="btn-container">
                    <button id="float_generateIntroBtn" class="btn btn-primary">Introdu√ß√£o</button>
                    <button id="float_generateDevelopmentBtn" class="btn btn-primary">Desenvolvimento</button>
                    <button id="float_climaxBtn" class="btn btn-primary">Cl√≠max</button>
                    <button id="float_conclusionBtn" class="btn btn-primary">Conclus√£o</button>
                    <button id="float_generateCTABtn" class="btn btn-primary">CTA</button>
                </div>
            </div>
            <!-- Grupo de A√ß√µes R√°pidas -->
            <div id="quickActions" class="action-bar-buttons-group hidden">
                <span class="action-bar-title">A√ß√µes R√°pidas:</span>
                 <div class="btn-container">
                    <button id="float_generateDescriptionBtn" class="btn btn-secondary">Descri√ß√£o</button>
                    <button id="float_generateTitlesAndThumbnailsBtn" class="btn btn-secondary">T√≠tulos</button>
                    <button id="float_downloadPdfBtn" class="btn btn-secondary">PDF</button>
                    <button id="float_resetScriptBtn" class="btn btn-secondary">Novo</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container relative">
        <div class="absolute top-4 right-4 flex items-center gap-2 z-[1001]">
            <button id="toggleZenModeBtn" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-gray-500 dark:text-gray-400" title="Modo Foco">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/><path d="M3 14.5a1.5 1.5 0 0 1-1.5-1.5V3a1.5 1.5 0 0 1 1.5-1.5h10A1.5 1.5 0 0 1 14.5 3v10a1.5 1.5 0 0 1-1.5 1.5H3zM4 3v10h8V3H4z"/></svg>
            </button>
            <button id="darkModeToggle" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-gray-500 dark:text-gray-400" title="Modo Escuro">
                <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m8.66-14.66l-.707.707M4.04 19.96l-.707.707M21 12h-1M4 12H3m16.66-7.96l-.707-.707M4.04 4.04l-.707-.707m11.314 0l-1.414 1.414M5.464 18.536l-1.414 1.414m12.728-1.414l-1.414-1.414m-9.9-9.9l-1.414-1.414M12 6a6 6 0 100 12 6 6 0 000-12z" /></svg>
            </button>
        </div>
        
        <h1 class="text-4xl font-extrabold text-gray-800 dark:text-gray-100 text-center mb-2">Gerador de Roteiros Virais v2.0</h1>
        <p class="text-center text-gray-500 dark:text-gray-400 mb-8">O seu painel de controle para conte√∫do de alto impacto.</p>
        
        <!-- Se√ß√£o de Inputs da Aplica√ß√£o -->
        <div id="mainInputsGrid" class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="input-group">
                <label for="channelName">Nome do Canal:</label>
                <input type="text" id="channelName" class="card-background" placeholder="Ex: The Biblical Unveiling" value="The Biblical Unveiling">
            </div>
            <div class="input-group">
                <label for="videoTheme">Tema do V√≠deo:</label>
                <input type="text" id="videoTheme" class="card-background" placeholder="Ex: A Arca da Alian√ßa Foi Encontrada?">
            </div>
             <div class="input-group md:col-span-2">
                <label for="videoDescription">Descri√ß√£o do V√≠deo (para inspira√ß√£o):</label>
                <textarea id="videoDescription" rows="4" class="card-background" placeholder="Cole uma breve descri√ß√£o do v√≠deo aqui para que a IA possa usar como inspira√ß√£o para o roteiro."></textarea>
            </div>

            <!-- Bot√£o de Estrat√©gia Autom√°tica com IA -->
            <div class="md:col-span-2 my-4 flex justify-center">
                <button id="analyzeStrategyBtn" class="btn btn-primary w-full md:w-1/2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M9.5 2.672a.5.5 0 1 0 1 0V.843a.5.5 0 0 0-1 0v1.829Zm4.5.035A.5.5 0 0 0 13.293 2L12 3.293a.5.5 0 1 0 .707.707L14 2.707a.5.5 0 0 0 0-.707ZM7.293 4A.5.5 0 1 0 8 3.293L6.707 2A.5.5 0 0 0 6 2.707L7.293 4Zm-.621 2.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L7.38 6.207a.5.5 0 0 0-.707 0ZM5.5 7a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Zm-1.829-1.5a.5.5 0 0 0-.707 0L2 6.793a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L3.707 7.5H3.5a.5.5 0 0 0 0-1h.207L2.707 5.5Zm-1 .707a.5.5 0 0 0-.707-.707L.707 6.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L1.293 7.5H1.5a.5.5 0 0 0 0-1h-.207L2.293 6.207Z"/><path d="M12.026 8.5H11a.5.5 0 0 0 0 1h1.026a.5.5 0 0 0 0-1Zm-1.633.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293Zm-3.134 3.367a.5.5 0 1 0-.707.707l1.293 1.293a.5.5 0 0 0 .707-.707l-1.293-1.293Zm1.633-.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293A.5.5 0 0 1 8.89 11.86Z"/></svg>
                    <span class="button-text">Definir Estrat√©gia com IA</span>
                    <div class="loading-spinner hidden"></div>
                </button>
            </div>
            
            <!-- Campos de Estrat√©gia Preenchidos pela IA -->
            <div class="input-group md:col-span-2">
                <label for="targetAudience">P√∫blico-Alvo:</label>
                <input type="text" id="targetAudience" class="card-background" value="Pessoas Interessadas em Arqueologia B√≠blica e Hist√≥ria Antiga, Crist√£os e Pessoas de F√©, Entusiastas de Ci√™ncia e Ceticismo (com mente aberta), Curiosos em Geral e Amantes de Mist√©rios." readonly>
            </div>
            <div class="input-group">
                <label for="languageSelect">Idioma do Roteiro:</label>
                <select id="languageSelect" class="card-background">
                    <option value="pt-br">Portugu√™s (Brasil)</option>
                    <option value="pt-pt">Portugu√™s (Portugal)</option>
                    <option value="en" selected>English</option>
                    <option value="es">Espa√±√£o</option>
                </select>
            </div>
            <div class="input-group">
                <label for="languageStyle">Estilo de Linguagem:</label>
                <select id="languageStyle" class="card-background">
                    <option value="formal">Formal</option>
                    <option value="informal">Informar</option>
                    <option value="emocional">Emocional</option>
                    <option value="tecnico">T√©cnico</option>
                    <option value="inspirador" selected>Inspirador</option>
                    <option value="humoristico">Humor√≠stico</option>
                </select>
            </div>
            <div class="input-group md:col-span-2">
                <label for="videoObjective">Objetivo do V√≠deo:</label>
                <select id="videoObjective" class="card-background">
                    <option value="informar" selected>Informar</option>
                    <option value="emocionar">Emocionar</option>
                    <option value="evangelizar">Evangelizar (criar defensores)</option>
                    <option value="vender">Vender</option>
                    <option value="entreter">Entreter</option>
                </select>
            </div>
            <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                <div class="input-group">
                    <label for="videoDuration">Dura√ß√£o Desejada:</label>
                    <select id="videoDuration" class="card-background">
                        <option value="">-- Selecione a Dura√ß√£o --</option>
                        <option value="short">Curto (~1-3 min)</option>
                        <option value="medium">M√©dio (~4-7 min)</option>
                        <option value="long">Longo (~8-12 min)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="speakingPace">Ritmo de Fala:</label>
                    <select id="speakingPace" class="card-background">
                        <option value="moderate" selected>Moderado</option>
                        <option value="slow">Lento</option> <!-- CORRIGIDO AQUI -->
                        <option value="fast">R√°pido</option>
                    </select>
                </div>
            </div>
<<<<<<< HEAD
            <div class="input-group md:col-span-2">
                <div class="flex items-center gap-2">
                    <label for="narrativeStyle">Estilo da Narrativa:</label>
                    <span class="tooltip card-background"
                        data-tooltip="Direto e Informativo: Estrutura cl√°ssica de come√ßo, meio e fim. Ideal para v√≠deos gerais.

Document√°rio (Factual e Investigativo): Constr√≥i um argumento com fatos, evid√™ncias e uma narra√ß√£o autorit√°ria. Perfeito para v√≠deos expositivos e de investiga√ß√£o.

Jornada do Her√≥i: Conta uma hist√≥ria de transforma√ß√£o e supera√ß√£o. √ìtimo para narrativas inspiradoras.

Mist√©rio (Loop Aberto): Apresenta uma pergunta no in√≠cio e a responde no final. Excelente para reter a aten√ß√£o.

Problema-Agita√ß√£o-Solu√ß√£o (PAS): Foca em um problema que o p√∫blico tem e apresenta a solu√ß√£o. Perfeito para v√≠deos de marketing e tutoriais.

Antes-Depois-Ponte (BAB): Mostra um cen√°rio 'antes' (o problema), um 'depois' (o resultado ideal) e seu conte√∫do como 'a ponte' para chegar l√°.

Narrativa com Virada (Twist): Constr√≥i uma expectativa e a quebra com uma revela√ß√£o surpreendente no final."
                    >
                        (?)
                    </span>
                </div>
                <select id="narrativeStyle" class="card-background">
                    <option value="direct" selected>Direto e Informativo (Padr√£o)</option>
                    <!-- ADICIONE A LINHA ABAIXO -->
                    <option value="documentary">Document√°rio (Factual e Investigativo)</option>
                    <option value="heros_journey">Jornada do Her√≥i (Cl√°ssico)</option>
                    <option value="mystery_loop">Mist√©rio (com Loop Aberto)</option>
                    <option value="pas">Problema-Agita√ß√£o-Solu√ß√£o (PAS)</option>
                    <option value="before_after_bridge">Antes-Depois-Ponte (BAB)</option>
                    <option value="twist">Narrativa com Virada (Twist)</option>
                </select>
            </div>
=======
            <!-- NOVO BLOCO DE C√ìDIGO PARA INSERIR -->
            <!-- Novo M√≥dulo de Sele√ß√£o de Narrativa -->
            <div class="input-group md:col-span-1">
                <label for="narrativeGoal">1. Objetivo da Narrativa:</label>
                <select id="narrativeGoal" class="card-background">
                    <option value="storytelling">Conectar e Entreter (Storytelling)</option>
                    <option value="storyselling">Persuadir e Vender (Storyselling)</option>
                </select>
            </div>
            <div class="input-group md:col-span-1">
                <div class="flex items-center gap-2">
                    <label for="narrativeStructure">2. Estrutura da Narrativa:</label>
                    <span id="narrativeStructureTooltip" class="tooltip card-background" data-tooltip="Selecione um objetivo primeiro.">
                        (?)
                    </span>
                </div>
                <select id="narrativeStructure" class="card-background">
                    <!-- As op√ß√µes ser√£o preenchidas dinamicamente pelo JavaScript -->
                </select>
            </div>
            
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            <div class="input-group md:col-span-2">
                <label for="centralQuestion">Pergunta Central (Opcional):</label>
                <textarea id="centralQuestion" rows="2" class="card-background" placeholder="Ex: A Arca da Alian√ßa Foi Encontrada?"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="emotionalArc">Arco Emocional Desejado (Opcional):</label>
                <textarea id="emotionalArc" rows="2" class="card-background" placeholder="Ex: Come√ßar com curiosidade, construir para admira√ß√£o, e terminar com inspira√ß√£o."></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="viralElements">Elementos Virais/Tend√™ncias (Opcional):</label>
                <textarea id="viralElements" rows="2" class="card-background" placeholder="Insira memes, frases, tend√™ncias ou palavras-chave em alta. Ex: 'o hype √© real', 'chocado', 'plot twist'"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="imageDescriptionEngine">Motor de Descri√ß√£o de Imagem:</label>
                <textarea id="imageDescriptionEngine" rows="2" class="card-background" placeholder="Ex: 'alta resolu√ß√£o', 'detalhado', 'fotorrealista', 'cores vibrantes'"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="imageStyleSelect">Motor de Qualidade de Imagem:</label>
                <select id="imageStyleSelect" class="card-background">
                    <option value="cinematic" selected>Cinematogr√°fico</option>
                    <option value="custom">Personalizado</option>
                    <option value="none">Nenhum</option>
                </select>
            </div>
            <div class="input-group md:col-span-2" id="customImageStyleContainer" style="display: none;">
                <label for="customImageStyle">Estilo Visual Personalizado:</label>
                <textarea id="customImageStyle" rows="5" class="card-background" placeholder="Cole aqui o seu bloco de estilo personalizado (ex: para cartoon, anime, etc.)."></textarea>
            </div>
        </div>

        <!-- ========================================================== -->
        <!-- ========= NOVA BARRA DE PROGRESO VISUAL ============= -->
        <!-- ========================================================== -->
        <div id="progressBarContainer" class="progress-bar-container mb-8">
            <div class="flex justify-between mb-1">
                <span class="text-base font-medium text-gray-700 dark:text-gray-300">Progresso do Projeto</span>
                <span id="progressText" class="text-sm font-medium text-gray-700 dark:text-gray-300">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>
        <!-- ========================================================== -->
       
        <!-- ========================================================== -->
        <!-- ===== NOVA √ÅREA DE SA√çDA: O PAINEL DO PROJETO ======== -->
        <!-- ========================================================== -->
        <div id="projectDashboard" class="hidden mt-12">
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
                
                <!-- Coluna Principal: Roteiro -->
                <div id="scriptColumn" class="lg:col-span-7 flex flex-col gap-4">
                    <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-200 border-b-2 border-indigo-200 dark:border-indigo-800 pb-2">Roteiro Principal</h2>

                    <!-- Cart√£o do Esbo√ßo Estrat√©gico (permanece no topo) -->
                    <div id="strategicOutlineCard" class="card-background p-4 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200">Esbo√ßo Estrat√©gico</h3>
                            <button id="generateOutlineBtn" class="btn btn-secondary btn-small">Criar Esbo√ßo</button>
                        </div>
                        <div id="outlineContent">
                             <div class="asset-card-placeholder">Clique em 'Criar Esbo√ßo' para a IA planejar a estrutura do roteiro.</div>
                        </div>
                    </div>

                    <!-- Novo Cont√™iner para os Acorde√µes que vai rolar -->
                    <div id="scriptSectionsContainer" class="flex-grow space-y-4 overflow-y-auto">
                        <div id="introSection" class="script-section"></div>
                        <div id="developmentSection" class="script-section"></div>
                        <div id="climaxSection" class="script-section"></div>
                        <div id="conclusionSection" class="script-section"></div>
                        <div id="ctaSection" class="script-section"></div>
                    </div>
                    
                    <!-- Controles de Gera√ß√£o, agora fixos no final da coluna -->
                    <div id="scriptGenerationControls" class="rounded-b-lg sticky bottom-0">
                        <h3 class="font-bold text-lg text-indigo-800 dark:text-indigo-300 mb-3 text-center">Gerar Se√ß√µes do Roteiro</h3>
                        <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                            <button id="generateIntroBtn" class="btn btn-primary btn-small">Introdu√ß√£o</button>
                            <button id="generateDevelopmentBtn" class="btn btn-primary btn-small">Desenvolvimento</button>
                            <button id="climaxBtn" class="btn btn-primary btn-small">Cl√≠max</button>
                            <button id="conclusionBtn" class="btn btn-primary btn-small">Conclus√£o</button>
                            <button id="generateCTABtn" class="btn btn-primary btn-small">CTA</button>
                        </div>
                    </div>
                </div>

                <!-- Coluna Lateral: Recursos e Metadados -->
                <div id="assetsColumn" class="lg:col-span-5 space-y-6">
                    <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-200 border-b-2 border-indigo-200 dark:border-indigo-800 pb-2">Recursos</h2>
                    
                    <!-- Cart√£o: Descri√ß√£o e Hashtags (AGORA PRIMEIRO) -->
                    <div class="card-background p-4 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200">Descri√ß√£o & Hashtags</h3>
                            <button id="generateDescriptionBtn" class="btn btn-secondary btn-small">Gerar</button>
                        </div>
                        <div id="videoDescriptionContent">
                             <div class="asset-card-placeholder">Clique em 'Gerar' para ver a descri√ß√£o</div>
                        </div>
                    </div>

                    <!-- Cart√£o: T√≠tulos e Thumbnails (AGORA EM SEGUNDO) -->
                    <div class="card-background p-4 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200">T√≠tulos & Thumbnails</h3>
                            <button id="generateTitlesAndThumbnailsBtn" class="btn btn-secondary btn-small">Gerar</button>
                        </div>
                        <div id="titlesThumbnailsContent">
                             <div class="asset-card-placeholder">Clique em 'Gerar' para ver as sugest√µes</div>
                        </div>
                    </div>

                    <!-- Cart√£o: Storyboard Visual (REMOVIDO) -->
                    <div id="storyboardContent" style="display: none;"></div>
                    
                    <!-- Cart√£o: Salvar e Exportar -->
                    <div class="card-background p-4 rounded-lg shadow-md">
                         <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200 mb-3">Finalizar Projeto</h3>
                         <div class="grid grid-cols-2 gap-3">
                            <button id="exportProjectBtn" class="btn btn-secondary">Exportar</button>
                            <button id="importProjectBtn" class="btn btn-secondary">Importar</button>
                            <input type="file" id="importFileInput" class="hidden" accept=".json">
                            <button id="downloadPdfBtn" class="btn btn-secondary">PDF</button>
                            <button id="resetScriptBtn" class="btn btn-secondary">Novo</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bot√£o para Sair do Modo Foco (come√ßa escondido) -->
    <button id="exitZenModeBtn" class="hidden fixed top-5 right-5 z-[2001] bg-white/50 dark:bg-gray-800/50 backdrop-blur-sm p-2 rounded-full text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/><path d="M3 14.5a1.5 1.5 0 0 1-1.5-1.5V3a1.5 1.5 0 0 1 1.5-1.5h10A1.5 1.5 0 0 1 14.5 3v10a1.5 1.5 0 0 1-1.5 1.5H3zM4 3v10h8V3H4z"/></svg>
    </button>
    
    <!-- Elementos de Feedback (Toast e Alerta) -->
    <div id="toastNotification" class="toast-notification"></div>
    <div id="fullScreenAlertOverlay">
        <div id="fullScreenAlertBox" class="card-background">
            <p id="fullScreenAlertMessage"></p>
            <button id="fullScreenAlertCloseBtn">Entendi</button>
        </div>
    </div>

    <script type="module">
        // ==========================================================
        // ==================== SETUP INICIAL =======================
        // ==========================================================
        // Vari√°veis de estado globais
        let generatedTitlesAndThumbnails = null;
        let allImagePrompts = {}; // Armazena prompts de imagem por se√ß√£o
        let strategicOutline = null; // Vari√°vel para armazenar o esbo√ßo estrat√©gico

        // Bloco de estilo cinematogr√°fico para prompts de imagem
        const CINEMATIC_STYLE_BLOCK = `
**[ESTILO CINEMATOGR√ÅFICO]**
Ultra-realistic, high-resolution photographic image. Captured with natural lighting and cinematic composition. Rich textures and fine surface details ‚Äî visible skin pores, fabric fibers, weathered materials, realistic reflections, and organic imperfections. Sharp focus with subtle depth of field. True-to-life colors with refined tonal range. Every element should look authentic, physical, and believable ‚Äî as if taken with a high-end DSLR camera. No exaggerated features, no artificial smoothness ‚Äî only pure, grounded realism.`;
        // Labels para descri√ß√£o de imagem em diferentes idiomas
        const imageDescriptionLabels = { 'pt-br': 'Descri√ß√£o da Imagem:', 'pt-pt': 'Descri√ß√£o da Imagem:', 'en': 'Image Description:' };

        // Mapeamento de elementos do DOM para acesso f√°cil
        const elements = {};
        const buttons = {};
        // Mapeia todos os elementos e bot√µes com ID
        document.querySelectorAll('[id]').forEach(el => {
            if (el.tagName === 'BUTTON') {
                buttons[el.id] = el;
            } else {
                elements[el.id] = el;
            }
        });

        // ==========================================================
        // ================== FUN√á√ïES DE UTILIDADE ==================
        // ==========================================================
        /**
         * Exibe uma notifica√ß√£o toast na parte inferior da tela.
         * @param {string} message - A mensagem a ser exibida.
         */
        window.showToast = (message) => {
            elements.toastNotification.textContent = message;
            elements.toastNotification.classList.add('toast-visible');
            setTimeout(() => {
                elements.toastNotification.classList.remove('toast-visible');
                setTimeout(() => { elements.toastNotification.textContent = ''; }, 300);
            }, 3000);
        };

        /**
         * Copia um texto para a √°rea de transfer√™ncia.
         * @param {string} text - O texto a ser copiado.
         */
        window.copyTextToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                window.showToast('Copiado!');
            } catch (err) {
                // Fallback para navegadores mais antigos ou contextos restritos (ex: iframes)
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                try {
                    document.execCommand('copy');
                    window.showToast('Copiado!');
                } finally {
                    document.body.removeChild(ta);
                }
            }
        };

        /**
         * Fornece feedback visual em um bot√£o ap√≥s uma a√ß√£o de c√≥pia.
         * @param {HTMLElement} buttonElement - O elemento do bot√£o que foi clicado.
         */
        window.showCopyFeedback = (buttonElement) => {
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = 'Copiado!';
            buttonElement.classList.add('btn-success');
            buttonElement.disabled = true; // Desabilita o bot√£o temporariamente

            setTimeout(() => {
                buttonElement.innerHTML = originalText;
                buttonElement.classList.remove('btn-success');
                buttonElement.disabled = false;
            }, 2000); // Reverte ap√≥s 2 segundos
        };

        /**
         * Mostra um spinner de carregamento e desabilita todos os bot√µes de gera√ß√£o.
         * @param {HTMLElement} button - O bot√£o que acionou o carregamento.
         */
        const showLoading = (button) => {
            // Desabilitar TODOS os bot√µes de gera√ß√£o para evitar rate limit
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = true; });
        
            const textSpan = button.querySelector('.button-text');
            const spinnerDiv = button.querySelector('.loading-spinner');

            if (textSpan) textSpan.classList.add('hidden');
            if (spinnerDiv) spinnerDiv.classList.remove('hidden');
        };

        /**
         * Esconde o spinner de carregamento e reabilita os bot√µes.
         * @param {HTMLElement} button - O bot√£o que estava em estado de carregamento.
         */
        const hideLoading = (button) => {
            // Habilita TODOS os bot√µes de gera√ß√£o novamente
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = false; });
            
            const spinnerDiv = button.querySelector('.loading-spinner');
            if (spinnerDiv) spinnerDiv.classList.add('hidden');
            
            const textSpan = button.querySelector('.button-text');
            if (textSpan) textSpan.classList.remove('hidden');

            updateButtonStates(); // Chama a fun√ß√£o centralizada para reavaliar o estado
        };

        /**
         * Marca um bot√£o (original e flutuante) como conclu√≠do (cor verde).
         * @param {string} originalId - O ID do bot√£o original.
         */
        const markButtonAsCompleted = (originalId) => {
            const originalButton = document.getElementById(originalId);
            const floatButton = document.getElementById(`float_${originalId}`);

            [originalButton, floatButton].forEach(btn => {
                if (btn) {
                    btn.classList.remove('btn-primary', 'btn-secondary');
                    btn.classList.add('btn-success');
                }
            });
            updateProgressBar(); // <-- ADICIONADO AQUI
        };

        /**
         * Reseta os √≠cones de conclus√£o de todos os bot√µes (original e flutuante) para suas cores padr√£o.
         */
        const resetCompletionIcons = () => {
            const passo1_buttons_ids = ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'];
            
            for (const buttonId in buttons) { // Iterar sobre todos os bot√µes
                const isPasso1 = passo1_buttons_ids.includes(buttonId);
                const originalButton = document.getElementById(buttonId);
                const floatButton = document.getElementById(`float_${buttonId}`);

                // Remove a classe de sucesso e adiciona a classe correta (primary/secondary)
                [originalButton, floatButton].forEach(btn => {
                    if (btn) {
                        btn.classList.remove('btn-success');
                        if (isPasso1) {
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-primary');
                        } else {
                            btn.classList.remove('btn-primary');
                            btn.classList.add('btn-secondary');
                        }
                    }
                });
            }
        };
        
        /**
         * Verifica se as se√ß√µes principais do roteiro foram geradas.
         * @returns {boolean} True se todas as se√ß√µes principais foram geradas, caso contr√°rio, false.
         */
        const isScriptComplete = () => {
            return ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'].every(id => {
                const section = document.getElementById(id);
                return section && !section.classList.contains('hidden') && section.querySelector('.generated-content-wrapper')?.textContent.trim() !== '';
            });
        };

        /**
         * Atualiza o estado de habilita√ß√£o/desabilita√ß√£o dos bot√µes com base no estado do roteiro.
         */
        const updateButtonStates = () => {
            const allMainScriptGenerated = isScriptComplete();
            // Verifica se h√° qualquer conte√∫do gerado para habilitar PDF e reset
            const hasAnyContent = document.querySelector('#scriptColumn .accordion-item') != null; // Updated selector for new dashboard

            // Bot√µes que dependem da conclus√£o do roteiro principal
            ['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn'].forEach(id => { 
                const originalBtn = document.getElementById(id);
                const floatBtn = document.getElementById(`float_${id}`);
                if (originalBtn) originalBtn.disabled = !allMainScriptGenerated;
                if (floatBtn) floatBtn.disabled = !allMainScriptGenerated;
            });
            
            // /* Bloco removido para manter o bot√£o PDF sempre ativo
            // Bot√µes que dependem de qualquer conte√∫do gerado
            // ['downloadPdfBtn'].forEach(id => {
            //      const originalBtn = document.getElementById(id);
            //      const floatBtn = document.getElementById(`float_${id}`);
            //      if (originalBtn) originalBtn.disabled = !hasAnyContent;
            //      if (floatBtn) floatBtn.disabled = !hasAnyContent;
            // });
            // */

            // Bot√£o de reset sempre habilitado (ou desabilitado apenas se n√£o houver nada para resetar)
            const resetBtn = document.getElementById('resetScriptBtn');
            const floatResetBtn = document.getElementById('float_resetScriptBtn');
            if (resetBtn) resetBtn.disabled = false; // Ajuste conforme a necessidade de reset
            if (floatResetBtn) floatResetBtn.disabled = false;

<<<<<<< HEAD
            // REMOVIDO: Habilitar bot√µes de gera√ß√£o de roteiro se o esbo√ßo estiver pronto
=======
            // REMOVIDO: Habilita os bot√µes de gera√ß√£o de roteiro se o esbo√ßo estiver pronto
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            // A l√≥gica agora est√° na fun√ß√£o handleGenerateSection para exibir um alerta.
        };

        /**
         * Mostra um alerta em tela cheia com uma mensagem.
         * @param {string} message - A mensagem a ser exibida.
         */
        const showFullScreenAlert = (message) => {
            elements.fullScreenAlertMessage.textContent = message;
            elements.fullScreenAlertOverlay.classList.add('visible');
        };

        /** Esconde o alerta em tela cheia. */
        const hideFullScreenAlert = () => {
            elements.fullScreenAlertOverlay.classList.remove('visible');
        };

        /** Alterna a visibilidade do campo de estilo de imagem personalizado. */
        const toggleCustomImageStyleVisibility = () => {
            elements.customImageStyleContainer.style.display = elements.imageStyleSelect.value === 'custom' ? 'block' : 'none';
        };

        /**
         * Calcula o tempo de leitura estimado de um texto.
         * @param {string} text - O texto a ser analisado.
         * @returns {string} O tempo de leitura formatado (ex: "~1 min 15 seg").
         */
        const calculateReadingTime = (text) => {
            if (!text) return "";
            const wordsPerMinute = 150; // M√©dia para um ritmo de fala moderado
            const words = text.trim().split(/\s+/).length;
            const totalSeconds = (words / wordsPerMinute) * 60;
            
            if (totalSeconds < 1) return "";
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.round(totalSeconds % 60);
            
            let timeString = "~";
            if (minutes > 0) {
                timeString += ` ${minutes} min`;
            }
            if (seconds > 0) {
                timeString += ` ${seconds} seg`;
            }
            
            return timeString.trim();
        };

        /**
         * Gera o HTML para uma se√ß√£o do roteiro em formato de acorde√£o.
         * @param {string} sectionId - O ID da se√ß√£o (ex: 'intro', 'development').
         * @param {string} title - O t√≠tulo da se√ß√£o a ser exibido.
         * @param {string} content - O conte√∫do do roteiro para a se√ß√£o.
         * @param {object} options - Op√ß√µes para controlar a exibi√ß√£o de bot√µes (showPromptsButton, showSoundtrackButton).
         * @returns {string} O HTML completo da se√ß√£o.
         */
        const generateSectionHtmlContent = (sectionId, title, content, options = {}) => {
            // Define os valores padr√£o se n√£o forem fornecidos
            const { showPromptsButton = true, showSoundtrackButton = true } = options;
            
            const bodyId = `${sectionId}Body`;
            const arrowId = `${sectionId}Arrow`;

            const regenerateBtnHtml = `<button class="regenerate-btn" onclick="event.stopPropagation(); window.regenerateSection('${sectionId}', '${title}', '${sectionId}')" title="Re-gerar esta se√ß√£o">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                    <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
                </svg>
            </button>`;

            const copyBtnHtml = `<button class="copy-btn" onclick="event.stopPropagation(); copyTextToClipboard(document.getElementById('${bodyId}').querySelector('.generated-content-wrapper').textContent); window.showCopyFeedback(this)">Copiar</button>`;
            
            // Constr√≥i condicionalmente as se√ß√µes de prompt e trilha sonora
            const promptsSectionHtml = showPromptsButton ? `
                <div class="section-prompts">
                    <button class="btn btn-secondary btn-small" onclick="window.generatePromptsForSection('${sectionId}Section')">
                        Gerar Prompts de Imagem
                    </button>
                    <div class="prompt-container mt-4"></div>
                </div>
            ` : '';
            
            const soundtrackSectionHtml = showSoundtrackButton ? `
                <div class="section-soundtrack">
                    <button class="btn btn-secondary btn-small" onclick="window.suggestSoundtrack('${sectionId}Section')">
                        Sugerir Trilha Sonora
                    </button>
                    <div class="soundtrack-container mt-4"></div>
                </div>
            ` : '';

            // Removido o regenerateBtnHtml do header-buttons para a Descri√ß√£o do V√≠deo
            const headerButtonsHtml = (sectionId === 'videoDescriptionOutput' || sectionId === 'titlesThumbnails' || sectionId === 'strategicOutline') ?
                `${copyBtnHtml}` :
                `${regenerateBtnHtml} ${copyBtnHtml}`;

            return `<div class="accordion-item">
                        <div class="accordion-header" onclick="toggleAccordion('${bodyId}', '${arrowId}')">
                            <div class="header-content">
                                 <h3>${title}</h3>
                                 <span class="text-xs font-normal text-gray-400 dark:text-gray-500">${calculateReadingTime(content)}</span>
                                 <svg id="${arrowId}" class="accordion-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                                 </svg>
                            </div>
                            <div class="header-buttons">
                                ${headerButtonsHtml}
                            </div>
                        </div>
                        <div id="${bodyId}" class="accordion-body">
                            <div class="generated-content-wrapper" contenteditable="true">${content.startsWith('<div') ? content : `<p class="whitespace-pre-wrap">${content}</p>`}</div>
                            ${promptsSectionHtml}
                            ${soundtrackSectionHtml}
                        </div>
                    </div>`;
        };

        /**
         * Limpa o texto gerado pela IA, removendo metadados e extraindo JSON se necess√°rio.
         * @param {string} text - O texto bruto da IA.
         * @param {boolean} expectJson - Se true, tenta extrair e validar um JSON.
         * @returns {string|null} O texto limpo ou o JSON stringificado, ou null em caso de erro.
         */
        const cleanGeneratedText = (text, expectJson = false) => {
            if (!text) return null;

            if (expectJson) {
<<<<<<< HEAD
                // Encontra o primeiro colchete de abertura ou chave
                const firstBracket = text.indexOf('[');
                const firstBrace = text.indexOf('{');
                let startIndex = -1;

                if (firstBracket !== -1 && firstBrace !== -1) {
                    startIndex = Math.min(firstBracket, firstBrace);
                } else {
                    startIndex = Math.max(firstBracket, firstBrace);
                }
=======
                // --- IN√çCIO DA CORRE√á√ÉO ---
                // Encontra o primeiro colchete de abertura ou chave
                const firstBracket = text.indexOf('[');
                const firstBrace = text.indexOf('{');
                
                let startIndex = -1;

                // Determina o √≠ndice de in√≠cio real do JSON, ignorando textos anteriores
                if (firstBracket === -1) {
                    startIndex = firstBrace;
                } else if (firstBrace === -1) {
                    startIndex = firstBracket;
                } else {
                    startIndex = Math.min(firstBracket, firstBrace);
                }
                // --- FIM DA CORRE√á√ÉO ---
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                
                if (startIndex === -1) {
                    console.error("N√£o foi poss√≠vel encontrar um in√≠cio de JSON ('{' ou '[') na resposta.", text);
                    return null;
                }

                // Determina o caractere de fechamento correspondente
                const startChar = text[startIndex];
                const endChar = startChar === '[' ? ']' : '}';

                // Encontra o √∫ltimo caractere de fechamento correspondente
                const endIndex = text.lastIndexOf(endChar);

                if (endIndex === -1) {
                    console.error(`JSON incompleto: caractere de fechamento '${endChar}' n√£o encontrado.`, text);
                    return null;
                }

                const jsonString = text.substring(startIndex, endIndex + 1);

                try {
                    JSON.parse(jsonString); // Valida o JSON
                    return jsonString;
                } catch (e) {
                    console.error("O JSON extra√≠do √© inv√°lido.", e.message, jsonString);
                    return null; // Retorna nulo se a valida√ß√£o falhar
                }
            }
            
            return text.trim();
        };
<<<<<<< HEAD

=======
    
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
        /**
         * Remove coment√°rios meta da IA do texto gerado.
         * @param {string} text - O texto gerado pela IA.
         * @returns {string} O texto sem os coment√°rios meta.
         */
        const removeMetaComments = (text) => {
            if (!text) return text;
            // Padr√£o para remover "Here is/are..." ou "Sure, here is..." etc.
            const introPattern = /^(Sure, |Of course, )?(here is|here's|here are|below is|certainly, here is) .*?:\s*\n?/im;
            let cleanedText = text.replace(introPattern, '');
            
            // Remove linhas que come√ßam com "Description:" ou "Hashtags:" se a IA as adicionar
            cleanedText = cleanedText.replace(/^(Description:|Hashtags:)\s*\n?/gim, '');

            return cleanedText.trim();
        };

        /**
<<<<<<< HEAD
=======
         * Concatena o texto de todas as se√ß√µes do roteiro em uma √∫nica string.
         * @returns {string} O roteiro completo.
         */
        const getFullScriptText = () => {
            let fullScript = '';
            const sectionOrder = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'];
            sectionOrder.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                const contentWrapper = section?.querySelector('.generated-content-wrapper');
                if (contentWrapper?.textContent.trim()) {
                    const title = section.querySelector('h3')?.textContent || sectionId.replace('Section', '');
                    fullScript += `\n\n--- ${title.toUpperCase()} ---\n${contentWrapper.textContent.trim()}`;
                }
            });
            return fullScript.trim();
        };
    
        // --- IN√çCIO DO NOVO M√ìDULO DE NARRATIVA ---

        // Mapeamento das estruturas narrativas e seus tooltips
        const narrativeStructures = {
            storytelling: {
                heros_journey: "Jornada do Her√≥i (Estrutura √âpica)",
                pixar_spine: "Espinha Dorsal - Pixar (Estrutura Emocional)",
                mystery_loop: "Mist√©rio (com Loop Aberto)",
                twist: "Narrativa com Virada (Twist)",
                documentary: "Document√°rio (Factual e Investigativo)"
            },
            storyselling: {
                underdog_victory: "Vit√≥ria do Vira-lata (Conex√£o e Supera√ß√£o)",
                discovery_mentor: "A Grande Descoberta / Mentor Secreto",
                if_not_found_create: "N√£o Encontrei, Ent√£o Criei (Hist√≥ria de Origem)",
                pas: "Problema-Agita√ß√£o-Solu√ß√£o (PAS)",
                bab: "Antes-Depois-Ponte (BAB)"
            }
        };

        const narrativeTooltips = {
            heros_journey: "Conta uma hist√≥ria de transforma√ß√£o e supera√ß√£o. √ìtimo para narrativas inspiradoras.",
            pixar_spine: "Estrutura emocional de 8 passos (Era uma vez... todo dia... at√© que...). Perfeita para arcos de personagem r√°pidos.",
            mystery_loop: "Apresenta uma pergunta no in√≠cio e a responde no final. Excelente para reter a aten√ß√£o.",
            twist: "Constr√≥i uma expectativa e a quebra com uma revela√ß√£o surpreendente no final.",
            documentary: "Constr√≥i um argumento com fatos, evid√™ncias e uma narra√ß√£o autorit√°ria. Perfeito para v√≠deos expositivos.",
            underdog_victory: "Mostra algu√©m com limita√ß√µes que venceu contra tudo e todos. Gera alta conex√£o emocional.",
            discovery_mentor: "Revela um grande segredo ou uma descoberta que mudou tudo. Posi√ß√£o de autoridade.",
            if_not_found_create: "Conta a hist√≥ria de origem de um produto ou servi√ßo criado a partir de uma necessidade pessoal.",
            pas: "Foca em um problema que o p√∫blico tem, agita a dor e apresenta a solu√ß√£o. Perfeito para vendas diretas.",
            bab: "Mostra um cen√°rio 'antes' (o problema), um 'depois' (o resultado ideal) e seu conte√∫do como 'a ponte' para chegar l√°."
        };

        /**
         * Atualiza as op√ß√µes do seletor de Estrutura da Narrativa
         * com base no Objetivo da Narrativa selecionado.
         */
        const updateNarrativeStructureOptions = () => {
            const goal = elements.narrativeGoal.value;
            const structureSelect = elements.narrativeStructure;
            const tooltip = elements.narrativeStructureTooltip;
            
            structureSelect.innerHTML = ''; // Limpa as op√ß√µes atuais

            const structures = narrativeStructures[goal];
            for (const key in structures) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = structures[key];
                structureSelect.appendChild(option);
            }
            
            // Atualiza o tooltip principal para refletir a nova sele√ß√£o
            updateMainTooltip();
        };

        /**
         * Atualiza o conte√∫do do tooltip principal com as descri√ß√µes
         * das estruturas narrativas atualmente vis√≠veis.
         */
        const updateMainTooltip = () => {
            const goal = elements.narrativeGoal.value;
            const tooltip = elements.narrativeStructureTooltip;
            const structures = narrativeStructures[goal];
            
            let tooltipContent = '';
            for (const key in structures) {
                tooltipContent += `${structures[key]}: ${narrativeTooltips[key]}

`;
            }
            
            tooltip.setAttribute('data-tooltip', tooltipContent.trim());
        };

        // --- FIM DO NOVO M√ìDULO DE NARRATIVA ---
    
        /**
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
         * Constr√≥i o contexto base do prompt com base nos inputs do usu√°rio.
         * @returns {string} O contexto do prompt.
         */
        const getBasePromptContext = () => {
            const channelName = elements.channelName.value.trim();
            const videoTheme = elements.videoTheme.value.trim();
            const targetAudience = elements.targetAudience.value.trim();
            const language = elements.languageSelect.value;
            const languageStyle = elements.languageStyle.value;
            const videoObjective = elements.videoObjective.value;
            const videoDuration = elements.videoDuration.value;
            const speakingPace = elements.speakingPace.value;
<<<<<<< HEAD
            const narrativeStyle = elements.narrativeStyle.value;
=======
            // --- MUDAN√áA AQUI: L√™ o valor da nova estrutura ---
            const narrativeStyle = elements.narrativeStructure.value; 
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            const videoDescription = elements.videoDescription.value.trim();
            const centralQuestion = elements.centralQuestion.value.trim();
            const emotionalArc = elements.emotionalArc.value.trim();
            const viralElements = elements.viralElements.value.trim();
            const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
            const imageStyleSelect = elements.imageStyleSelect.value;
            const customImageStyle = elements.customImageStyle.value.trim();

            let context = `
            You are an expert YouTube scriptwriter for the channel "${channelName}".
            Your goal is to create highly engaging and viral video content.
            
            Video Theme: "${videoTheme}"
            Target Audience: "${targetAudience}"
            Language: "${language}"
            Language Style: "${languageStyle}"
            Video Objective: "${videoObjective}"
            Desired Duration: "${videoDuration}"
            Speaking Pace: "${speakingPace}"
            Narrative Style: "${narrativeStyle}"
            `;

            if (videoDescription) { context += `\nInspiration/Context: "${videoDescription}"`; }
            if (centralQuestion) { context += `\nCentral Question to guide the entire script: "${centralQuestion}"`; }
            if (emotionalArc) { context += `\nEmotional Arc: "${emotionalArc}"`; }
            if (viralElements) { context += `\nViral Elements to incorporate: "${viralElements}"`; }
            if (imageDescriptionEngine) { context += `\nImage Description Instructions: "${imageDescriptionEngine}"`; }
            
<<<<<<< HEAD
            // --- IN√çCIO DA CORRE√á√ÉO ---
            // Agora usa a constante CINEMATIC_STYLE_BLOCK para consist√™ncia
=======
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            if (imageStyleSelect === 'cinematic') {
                context += `\nImage Style: ${CINEMATIC_STYLE_BLOCK}`;
            } else if (imageStyleSelect === 'custom' && customImageStyle) {
                context += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
            }
<<<<<<< HEAD
            // --- FIM DA CORRE√á√ÉO ---

            return context;
        };

=======

            return context;
        };
    
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
        /**
         * Constr√≥i o prompt espec√≠fico para cada se√ß√£o do roteiro ou tipo de conte√∫do.
         * @param {string} sectionName - O nome da se√ß√£o (ex: 'intro', 'titles_thumbnails').
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o para o prompt.
         * @param {string|null} outlineDirective - Uma diretriz espec√≠fica do esbo√ßo estrat√©gico para esta se√ß√£o.
         * @returns {{prompt: string, maxTokens: number}} O prompt e o limite de tokens.
         */
        const constructScriptPrompt = (sectionName, sectionTitle, outlineDirective = null) => {
            const baseContext = getBasePromptContext();
            const videoDuration = elements.videoDuration.value;
            const selectedLanguage = elements.languageSelect.value;
<<<<<<< HEAD
            const narrativeStyle = elements.narrativeStyle.value;

=======
            const narrativeStyle = elements.narrativeStructure.value; // Changed to narrativeStructure
            
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            // --- VERS√ÉO FINAL COM FORMATA√á√ÉO CORRETA ---
            let prompt = `${baseContext}

You are a master screenwriter, a true virtuoso of words. Your task is to write the **${sectionTitle}** section of the script.

**Your writing must be magnetic and professional. Follow these core principles:**
1.  **Dynamic Rhythm and Pacing:** Write with a natural, captivating cadence. Use a mix of short, punchy sentences for impact and longer, flowing sentences for description and atmosphere. Avoid monotony at all costs.
2.  **"Show, Don't Tell" on a Deeper Level:** Don't just state facts. Use vivid, sensory language to paint a picture in the viewer's mind. Evoke emotions and create a tangible experience through your words.
3.  **Human Connection:** Weave the information into a narrative that connects with the viewer on a personal level. Use "you" to speak directly to them. Ground abstract concepts in relatable human experiences and emotions.
4.  **Rhetorical Techniques:** Intelligently use rhetorical questions, powerful analogies, and striking metaphors to make the content more memorable and thought-provoking.
5.  **Hook Reinforcement:** If there is a central question, subtly remind the viewer of the mystery or the promise made in the introduction to keep them hooked and eager for the resolution.
`;
            // --- FIM DO BLOCO CORRIGIDO ---

            let maxTokens = 2000;

            if (outlineDirective) {
                prompt += `\n\n**IMPORTANT STRATEGIC GUIDELINE:** For this specific section, you MUST follow this strategic plan: "${outlineDirective}"`;
            }

            prompt += `\n\nIMPORTANT: Do NOT include any scene descriptions, visual/audio cues (e.g., [SHOT], (Camera pan), (Music swells)), or speaker labels (e.g., "Narrator:", "Host:") in the generated script content. Provide only the spoken text.`;
            prompt += `\n\nABSOLUTELY NO META-COMMENTS. Do not add any explanatory text about the script itself. Your entire response must be ONLY the text to be spoken in the video, and nothing else.`;

            if (elements.centralQuestion.value.trim()) {
                prompt += `\nIf a 'Central Question' is provided, ensure every section of the script (Introduction, Development, Climax) directly contributes to exploring or answering this question. The entire video must revolve around this central theme.`;
            }

            switch (narrativeStyle) {
                case 'documentary':
                    prompt += `\n\nNARRATIVE STYLE: Use a 'Documentary' structure.
                    - **Introduction:** Start with a powerful, factual statement or a thought-provoking question that establishes the central theme. Present the "thesis" of the documentary.
                    - **Development:** Build the narrative by presenting evidence, data, and historical context in a logical sequence. Structure it like an investigation, revealing information progressively. Use language that suggests authority and credibility (e.g., "Evidence suggests...", "Historical records show...", "Experts believe...").
                    - **Climax:** Present the most compelling piece of evidence or the central conclusion of your argument. This should be the moment where the "thesis" from the introduction is proven or deeply explored.
                    - **Conclusion:** Summarize the key findings and arguments. End with a broader reflection on the implications of the topic, leaving the viewer with a new understanding or perspective.`;
                    break;
                case 'mystery_loop':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Mystery/Open Loop' structure.
                    - In the **Introduction**, present a compelling central question or mystery and promise the answer by the end.
                    - In the **Development**, build suspense by exploring clues and theories, occasionally reminding the viewer of the central question.
                    - In the **Climax**, deliver the satisfying answer to the question posed in the introduction.`;
                    break;
                case 'pas':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Problem-Agitate-Solution' structure.
                    - Frame the **Introduction** around a clear 'Problem' that the audience can relate to.
                    - Use the first part of the **Development** to 'Agitate' this problem, explaining its importance and complexity.
                    - Frame the rest of the **Development** and the **Climax** as the 'Solution' or the revealing insight that addresses the initial problem.`;
                    break;
                case 'twist':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'False Climax & Twist' structure.
                    - In the **Development**, build evidence towards a seemingly obvious conclusion (the 'false climax').
                    - In the **Climax**, introduce a surprising new piece of information or a counter-argument that completely changes the expected outcome (the 'twist').
                    - The **Conclusion** should reflect on the implications of this new, unexpected truth.`;
                    break;
                case 'heros_journey':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Hero's Journey' structure.
                    - **Introduction:** Present the 'Ordinary World' and the 'Call to Adventure'. Introduce the central character or concept.
                    - **Development:** This is the 'Special World'. Describe the trials, allies, and enemies. Build the character's transformation through challenges.
                    - **Climax:** The 'Ordeal' or the final battle. The moment of greatest tension and the hero's ultimate test.
                    - **Conclusion:** The 'Return with the Elixir'. Show the resolution, what was learned, and how the 'Ordinary World' has changed because of the journey.`;
                    break;
<<<<<<< HEAD
                case 'before_after_bridge':
=======
                case 'bab': // Changed from before_after_bridge
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Before-After-Bridge' (BAB) structure.
                    - **Introduction (Before):** Describe the 'Before' state. A world without the knowledge or solution you're about to present. Paint a picture of the problem or the lack of understanding.
                    - **Development (After):** Describe the 'After' state. A desirable world where the problem is solved or the knowledge is revealed. Show the benefits and the ideal outcome.
                    - **Climax & Conclusion (The Bridge):** Present your content as 'The Bridge'. Explain how your video's information is the exact path to get from the 'Before' state to the 'After' state. This is the solution, the 'how-to'.`;
                    break;
<<<<<<< HEAD
=======
                case 'pixar_spine':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Pixar Spine' structure.
                    - **Introduction:** Once upon a time there was... Every day...
                    - **Development:** Until one day... Because of this... Because of this...
                    - **Climax:** Until finally...
                    - **Conclusion:** And ever since then... And the moral of the story is...`;
                    break;
                case 'underdog_victory':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Underdog Victory' structure.
                    - **Introduction:** Introduce the protagonist (or concept) as an underdog, facing significant challenges or disadvantages.
                    - **Development:** Detail the struggles, setbacks, and the overwhelming odds against the underdog. Build empathy and tension.
                    - **Climax:** The moment of triumph where the underdog overcomes the odds through perseverance, ingenuity, or unexpected help.
                    - **Conclusion:** Reflect on the victory, its impact, and the lessons learned. Emphasize the inspiring message of overcoming adversity.`;
                    break;
                case 'discovery_mentor':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Great Discovery / Secret Mentor' structure.
                    - **Introduction:** Set up a common problem or a widespread misunderstanding. Hint at a deeper, hidden truth or a solution that few know about.
                    - **Development:** Introduce the "discovery" ‚Äì a new piece of information, a hidden technique, or a secret method. This is often revealed by a "mentor" figure (which can be the channel itself, or a historical figure/concept). Explain how this discovery challenges conventional wisdom.
                    - **Climax:** The "aha!" moment where the full implications of the discovery are revealed, providing a profound solution or a new way of thinking.
                    - **Conclusion:** Reinforce the power of this new knowledge and how it can transform the viewer's understanding or approach to the problem. Encourage them to apply this newfound wisdom.`;
                    break;
                case 'if_not_found_create':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'If Not Found, I Created It' (Origin Story) structure.
                    - **Introduction:** Describe a personal problem, frustration, or unmet need that the creator (or the subject of the video) experienced.
                    - **Development:** Detail the journey of trying to find a solution, facing obstacles, and realizing that no adequate solution existed. This leads to the decision to create something new.
                    - **Climax:** The moment of creation or breakthrough ‚Äì the development of the unique product, service, or idea that solves the original problem.
                    - **Conclusion:** Showcase the success and impact of the creation, demonstrating how it effectively addresses the initial need and benefits others. Emphasize the innovation and the journey of bringing it to life.`;
                    break;
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            }

            // A linha abaixo foi REMOVIDA por ser redundante
            // prompt += `\n\nIMPORTANT WRITING STYLE: Use the 'Show, Don't Tell' principle...`;

            switch (sectionName) {
                case 'outline': // New case for strategic outline
                    prompt = `${baseContext}

Voc√™ √© um mestre roteirista e estrategista de conte√∫do. Sua tarefa √© criar um "beat sheet" ou um esbo√ßo estrat√©gico detalhado para o v√≠deo. Analise todos os par√¢metros fornecidos (tema, p√∫blico, estilo narrativo, etc.) para criar a estrutura mais impactante poss√≠vel.

Responda APENAS com um objeto JSON. O objeto deve conter chaves para cada parte principal do roteiro: "introduction", "development", "climax", "conclusion", e "cta".

O valor de cada chave deve ser uma string descrevendo o objetivo, o conte√∫do e a emo√ß√£o daquela se√ß√£o espec√≠fica. Seja conciso, mas estrat√©gico.

Exemplo de formato JSON esperado:
{
  "introduction": "Come√ßar com uma pergunta ret√≥rica chocante sobre a mortalidade, seguida por uma promessa de que a hist√≥ria de L√°zaro det√©m uma resposta inesperada. Gancho emocional: curiosidade e um toque de medo existencial.",
  "development": "Construir a narrativa explorando o luto das irm√£s de L√°zaro, humanizando a hist√≥ria. Apresentar a chegada tardia de Jesus como um ponto de tens√£o e d√∫vida. Foco na emo√ß√£o de perda antes do milagre.",
  "climax": "O momento de maior tens√£o no t√∫mulo. Descrever a ordem de Jesus com autoridade e o espanto da multid√£o. O milagre deve ser o pico emocional e visual do v√≠deo.",
  "conclusion": "Resumir a li√ß√£o: o milagre n√£o √© sobre desafiar a morte, mas sobre o poder da f√©. Conectar a hist√≥ria de L√°zaro √† jornada de f√© pessoal do espectador.",
  "cta": "Fazer uma chamada para a√ß√£o suave, pedindo para o espectador compartilhar sua pr√≥pria hist√≥ria de supera√ß√£o ou f√© nos coment√°rios, criando uma comunidade."
}
`;
                    maxTokens = 1500;
                    break;
                case 'intro':
                    prompt += `
<<<<<<< HEAD
                    The introduction should hook the viewer immediately, clearly state the video's intriguing question or mystery, and set the stage for what's to come. It must be captivating and create curiosity. For a "${videoDuration}" video, make this introduction appropriate in length and detail.
=======
                    The introduction must hook the viewer immediately, clearly state the video's intriguing question or mystery, and set the stage for what's to come. It must be captivating and create intense curiosity. For a "${videoDuration}" video, make this introduction appropriate in length and detail.
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 1** of the story. Your introduction should serve as the 'Inciting Incident', clearly presenting the central question or mystery that will drive the video. Establish the 'Normal World' of the topic before introducing the core conflict.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'development':
                    prompt += `
<<<<<<< HEAD
                    The development section should delve into the core topic, presenting facts, arguments, and historical context. It should maintain a strong narrative flow, building suspense and providing compelling information. Break down complex ideas into easily digestible parts. For a "${videoDuration}" video, ensure this section is comprehensive but also flows well, adapting its length to the desired duration.
=======
                    The development must delve into the core topic, presenting facts, arguments, and historical context. It must maintain a strong narrative flow, building suspense and providing compelling information. Break down complex ideas into easily digestible parts. For a "${videoDuration}" video, ensure this section is comprehensive but also flows well, adapting its length to the desired duration.
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 2** of the story. Your goal is to raise the stakes. Present compelling evidence but also introduce obstacles and counter-arguments. Build towards a major revelation or turning point (the Midpoint).`;
                    }
                    maxTokens = 1500;
                    break;
                case 'climax':
                    prompt += `
<<<<<<< HEAD
                    The climax should be the most impactful part of the video, revealing key insights, surprising twists, or the most compelling evidence related to the video theme. It should be dramatic and leave the viewer with a sense of awe or profound understanding. For a "${videoDuration}" video, make this climax impactful and well-paced.
=======
                    The climax must be the most impactful part of the video, revealing key insights, surprising twists, or the most compelling evidence related to the video theme. It should be dramatic and leave the viewer with a sense of awe or profound understanding. For a "${videoDuration}" video, make this climax impactful and well-paced.
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    `;
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'conclusion':
                    prompt += `
<<<<<<< HEAD
                    The conclusion should summarize the main points, provide a final thought or reflection, and leave the viewer with a lasting impression. Ensure the conclusion is complete and well-rounded, providing a sense of closure. For a "${videoDuration}" video, make this conclusion concise yet impactful.
=======
                    The conclusion must summarize the main points, provide a final thought or reflection, and leave the viewer with a lasting impression. Ensure the conclusion is complete and well-rounded, providing a sense of closure. For a "${videoDuration}" video, make this conclusion concise yet impactful.
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    `;
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'cta':
                    prompt += `
<<<<<<< HEAD
                    The Call to Action (CTA) should be clear and concise, encouraging viewers to subscribe, like, comment, share, or engage with other content. Make it compelling and natural within the video's flow. For a "${videoDuration}" video, keep this CTA direct and effective.
=======
                    The Call to Action (CTA) must be clear and concise, encouraging viewers to subscribe, like, comment, share, or engage with other content. Make it compelling and natural within the video's flow. For a "${videoDuration}" video, keep this CTA direct and effective.
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    `;
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 200;
                    break;
                case 'titles_thumbnails':
<<<<<<< HEAD
=======
                    // --- CORRE√á√ÉO DO TYPO ---
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    prompt = `${baseContext}
Generate 5 highly clickable and viral YouTube video titles and 5 compelling thumbnail ideas.

IMPORTANT: Respond ONLY with a valid JSON object. Do not include any other text, preambles, or explanations outside of the JSON structure itself.

The JSON object must have two top-level keys:
1.  "titles": An array of strings.
<<<<<<< HEAD
2.  "thumbnails": Anatah array of objects, where each object has a "title" (string) and a "description" (string) key. Each description should focus on strong visual elements, emotions, and clear text overlays.
=======
2.  "thumbnails": An array of objects, where each object has a "title" (string) and a "description" (string) key. Each description should focus on strong visual elements, emotions, and clear text overlays.
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5

The final output MUST be only the JSON code, like this example:
{
  "titles": [
    "The Shocking Truth About the Ark of the Covenant",
    "Was the Ark of the Covenant Finally Discovered?",
    "This Ancient Secret Could Change History Forever",
    "Biblical Mystery: The Ark's Final Location Revealed",
    "They Found It? The Search for the Lost Ark Ends Here"
  ],
  "thumbnails": [
    {
      "title": "FOUND?",
      "description": "A dramatic image of an ancient, glowing chest half-buried in a dark cave, with an astonished archaeologist looking on."
    },
    {
      "title": "TOP SECRET",
      "description": "A collage showing a faded ancient map, a secret biblical text, and a satellite image pointing to a location in Ethiopia."
    },
    {
      "title": "HISTORY CHANGED",
      "description": "A visually stunning image of the Ark of the Covenant radiating golden light inside a reconstructed Solomon's Temple."
    }
  ]
}
`;
                    maxTokens = 800;
                    break;
                case 'description':
                    prompt = `${baseContext}\n\nGenerate a compelling YouTube video description (around 150-200 words) that summarizes the video, includes relevant keywords for SEO, and encourages engagement. Include a strong hook, a brief overview of the content, and a call to action. Also, suggest 10 relevant hashtags.
                    Output format:
                    Description:
                    [Your description here]

                    Hashtags:
                    #hashtag1 #hashtag2 ...
                    `;
                    maxTokens = 700;
                    break;
                default:
                    maxTokens = 1000;
                    break;
            }
            return { prompt, maxTokens };
        };

        /**
<<<<<<< HEAD
         * Faz uma chamada √† API Groq atrav√©s de uma fun√ß√£o Netlify.
         * @param {string} prompt - O prompt a ser enviado para a IA.
         * @param {number} maxTokens - O n√∫mero m√°ximo de tokens para a resposta.
         * @returns {Promise<string>} A resposta bruta da IA.
         * @throws {Error} Se a chamada √† API falhar.
         */
        const callGroqAPI = async (prompt, maxTokens) => {
            const proxyUrl = "/.netlify/functions/groq"; // Endpoint do proxy

            const payload = {
                prompt: prompt,
                maxTokens: maxTokens
            };

            const request = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetch(proxyUrl, request);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Erro desconhecido do servidor proxy.' } }));
                    throw new Error(`Erro na API via Proxy: ${errorData.error?.message || 'Erro do servidor'}`);
                }
                const result = await response.json();
                const rawContent = result.choices?.[0]?.message?.content;
                if (rawContent) { return rawContent; }
                else { throw new Error("Resposta inesperada da API Groq."); }
            } catch (error) {
                console.error("Fetch da API via Netlify Function falhou:", error);
                window.showToast(`Falha na API: ${error.message}`);
                throw error;
           }
        };

        /**
         * Valida os inputs essenciais antes de gerar conte√∫do.
         * @returns {boolean} True se os inputs s√£o v√°lidos, caso contr√°rio, false.
         */
        const validateInputs = () => {
            if (!elements.channelName.value.trim()) {
                window.showToast("Por favor, insira o nome do canal.");
                return false;
            }
            if (!elements.videoTheme.value.trim()) {
                window.showToast("Por favor, insira o tema do v√≠deo.");
                return false;
            }
            if (!elements.videoDescription.value.trim()) {
                window.showToast("Por favor, insira a descri√ß√£o do v√≠deo (para inspira√ß√£o).");
                return false;
            }
            if (!elements.videoDuration.value || elements.videoDuration.value === "") {
                window.showToast("Por favor, selecione a Dura√ß√£o Desejada do v√≠deo.");
                return false;
            }
            return true;
        };

        /**
         * Itera sobre todas as se√ß√µes do roteiro na ordem correta
         * e renumera globalmente todas as cenas.
         */
        const reNumberAllScenes = () => {
            let globalSceneCounter = 1;
            const sectionOrder = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'];

            sectionOrder.forEach(sectionId => {
                const promptBlocks = document.querySelectorAll(`#${sectionId} .individual-prompt-block`);
                
                promptBlocks.forEach(block => {
                    const timeElement = block.querySelector('.prompt-time');
                    if (timeElement) {
                        // Pega apenas a parte do tempo, ignorando a contagem de cena antiga
                        const timePart = timeElement.textContent.split(' - ')[0];
                        
                        // Atualiza o elemento com a nova contagem global
                        timeElement.textContent = `${timePart} - Cena ${String(globalSceneCounter).padStart(2, '0')}`;
                        globalSceneCounter++;
                    }
                });
            });
        };

        // ==========================================================
        // ================== FUN√á√ïES PRINCIPAIS ====================
        // ==========================================================

        /**
         * Lida com a gera√ß√£o de uma se√ß√£o espec√≠fica do roteiro.
         * @param {HTMLElement} button - O bot√£o que acionou a gera√ß√£o.
         * @param {string} sectionName - O nome da se√ß√£o (ex: 'intro').
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o para exibi√ß√£o.
         * @param {string} elementId - O ID do elemento HTML onde o conte√∫do ser√° inserido (ex: 'intro').
         */
        const handleGenerateSection = async (button, sectionName, sectionTitle, elementId) => {
            if (!validateInputs()) return;
            
            // Logo no in√≠cio da fun√ß√£o
            if (!strategicOutline) {
                window.showToast("Crie o Esbo√ßo Estrat√©gico primeiro!");
                return;
            }

            showLoading(button);
            try {
                // Pega a diretriz espec√≠fica para esta se√ß√£o do nosso esbo√ßo global
                const directive = strategicOutline[sectionName]; 
                
                const { prompt, maxTokens } = constructScriptPrompt(sectionName, sectionTitle, directive);
                let result = await callGroqAPI(prompt, maxTokens);
                
                // Limpeza espec√≠fica de metadados da IA
                result = result.replace(/^Here's (?:the|a potential) \*\*[\w\s]+\*\* (?:section of the video script|for the video script):\s*\n*\s*$/gm, '');
                result = result.replace(/^(?:Host|Narrator)(?:\s*\(.*?\))?:\s*/gm, '');
                result = result.replace(/^\*\*[\w\s]+\*\*$/gm, '');
                result = result.replace(/^\s*(?:\*\*?\[.*?\]\*\*?|\(.*?\))\s*$/gm, '');
                result = result.replace(/^\s*[\r\n]+/gm, '');

                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);

                const targetSectionElement = document.getElementById(`${elementId}Section`);
                if (targetSectionElement) {
                    const sectionHtml = generateSectionHtmlContent(elementId, sectionTitle, result);
                    targetSectionElement.innerHTML = sectionHtml;
                    const accordionItem = targetSectionElement.querySelector('.accordion-item');
                    if(accordionItem) accordionItem.classList.add('animate-fade-in');
                } else {
                    console.error(`Target section element with ID '${elementId}Section' not found.`);
                    window.showToast("Erro interno: Se√ß√£o do roteiro n√£o encontrada.");
                    return;
                }
                
                markButtonAsCompleted(button.id);
                updateButtonStates();

            } catch (error) {
                window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
                console.error(`Error generating ${sectionTitle}.`, error);
            } finally {
                hideLoading(button);
            }
        };

        /**
         * Re-gera o conte√∫do de uma se√ß√£o espec√≠fica do roteiro.
         * Chamada pelos bot√µes "Re-gerar" dentro das se√ß√µes.
         * @param {string} sectionName - O nome da se√ß√£o (ex: 'intro').
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o.
         * @param {string} elementId - O ID do elemento HTML da se√ß√£o.
         */
        window.regenerateSection = (sectionName, sectionTitle, elementId) => {
            const mainButtonIdMap = {
                'intro': 'generateIntroBtn',
                'development': 'generateDevelopmentBtn',
                'climax': 'climaxBtn',
                'conclusion': 'conclusionBtn',
                'cta': 'generateCTABtn'
            };
            const buttonId = mainButtonIdMap[sectionName];
            if (buttonId) {
                const button = document.getElementById(buttonId);
                handleGenerateSection(button, sectionName, sectionTitle, elementId);
            }
        };

        /**
         * Gera prompts de imagem para uma se√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionElementId - O ID do elemento HTML da se√ß√£o (ex: 'introSection').
         */
        window.generatePromptsForSection = async (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            const scriptContentElement = sectionElement.querySelector('.generated-content-wrapper');
            const promptContainer = sectionElement.querySelector('.prompt-container');
            
            if (!scriptContentElement || !scriptContentElement.textContent.trim()) {
                window.showToast("Por favor, gere o conte√∫do do roteiro desta se√ß√£o primeiro.");
                return;
            }

            const scriptContent = scriptContentElement.textContent; // Corrected to use scriptContentElement
            
            promptContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

            const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
            const imageStyleSelect = elements.imageStyleSelect.value;
            const customImageStyle = elements.customImageStyle.value.trim();
            let selectedStyleBlock = '';

            let prompt = `Voc√™ √© um Diretor de Arte e Artista de Storyboard. Sua tarefa √© ler o trecho do roteiro e criar descri√ß√µes de imagem **est√°ticas e poderosas** que capturem a ess√™ncia de cada momento.

**REGRA ABSOLUTA: N√ÉO descreva movimentos de c√¢mera, cortes ou enquadramentos (ex: 'close-up de', 'c√¢mera foca em', 'corte para'). Descreva APENAS o conte√∫do visual da cena, como se fosse uma fotografia ou uma pintura.**

**RITMO DIN√ÇMICO:** O seu objetivo √© criar um prompt a cada **15 a 25 segundos de narra√ß√£o**, aproximadamente. Leia v√°rias frases, entenda o tempo, e s√≥ ent√£o escolha o momento mais impactante para criar UM prompt.

**IMAGEM INICIAL INEGOCI√ÅVEL:** O primeiro prompt **DEVE OBRIGATORIAMENTE** corresponder √† **PRIMEIRA FRASE COMPLETA** do roteiro.

Encontre os pontos de virada ou as imagens mentais mais fortes e transforme-os em descri√ß√µes visuais ricas.

Responda APENAS com um array JSON de objetos (com chaves "scriptPhrase" e "imageDescription").

Trecho do roteiro:
---${scriptContent}
---`;
            
            if (imageDescriptionEngine) {
                prompt += `\n\nAlso, ensure the image descriptions incorporate the following quality instructions: "${imageDescriptionEngine}"`;
            }

            if (imageStyleSelect === 'cinematic') {
                // Use the constant directly
                prompt += `\n\nApply a cinematic film still style to these image descriptions: ${CINEMATIC_STYLE_BLOCK}`;
                selectedStyleBlock = CINEMATIC_STYLE_BLOCK;
            } else if (imageStyleSelect === 'custom' && customImageStyle) {
                prompt += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
                selectedStyleBlock = customImageStyle;
            }

            try {
                const rawResult = await callGroqAPI(prompt, 4000);
                const cleanedText = cleanGeneratedText(rawResult, true);
                let prompts = [];
                if (cleanedText) {
                    try {
                        prompts = JSON.parse(cleanedText);
                        if (!Array.isArray(prompts)) {
                            console.warn("AI returned non-array JSON, attempting to convert.");
                            prompts = [prompts];
                        }
                    } catch (e) {
                        window.showToast("Erro ao analisar JSON de prompts de imagem. Verifique o console.");
                        console.error("Erro ao analisar JSON de prompts de imagem:", e);
                        prompts = [];
                    }
                } else {
                    window.showToast("Erro: IA n√£o retornou prompts ou o formato est√° incorreto para esta se√ß√£o.");
                }
                
                // --- MUDAN√áA NA L√ìGICA DE DADOS ---
                // Agora n√£o precisamos mais da propriedade 'sequence'
                let accumulatedTimeSeconds = 1; 
                allImagePrompts[sectionElementId] = prompts.map((p, i) => {
                    const time = accumulatedTimeSeconds;
                    accumulatedTimeSeconds += 20;
                    const mins = Math.floor(time / 60);
                    const secs = Math.floor(time % 60);
                    return { 
                        ...p, 
                        time: `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`,
                        styleBlock: selectedStyleBlock
                    };
                });

                promptContainer.innerHTML = '';
                if (allImagePrompts[sectionElementId] && allImagePrompts[sectionElementId].length > 0) {
                    allImagePrompts[sectionElementId].forEach((promptData, index) => {
                        const styleBlockContent = promptData.styleBlock || '';
                        // --- MUDAN√áA NA L√ìGICA DE DISPLAY ---
                        // Geramos o HTML com um placeholder simples para a contagem
                        const promptHtml = `
                            <div class="individual-prompt-block card-background">
                                <div class="flex items-center justify-between mb-2">
                                    <p class="prompt-time">${promptData.time} - Cena 00</p> 
                                    <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${index}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${index}').textContent); window.showCopyFeedback(this)">Copiar</button>
                                </div>
                                <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                                <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                                <p id="prompt-content-${sectionElementId}-${index}" class="prompt-description-content">${promptData.imageDescription}</p>
                                <pre id="style-block-${sectionElementId}-${index}" class="text-xs p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                            </div>
                        `;
                        promptContainer.innerHTML += promptHtml;
                    });
                } else {
                    promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta se√ß√£o.</p>';
                }
                
                // --- CHAMADA DA NOVA FUN√á√ÉO "MAESTRO" ---
                reNumberAllScenes();
                
                updateButtonStates();
            } catch (error) {
                promptContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar prompts: ${error.message}</p>`;
                console.error(`Error generating prompts for section ${sectionElementId}.`, error);
            }
        };

        /**
         * Sugere trilhas sonoras para uma se√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionId - O ID do elemento HTML da se√ß√£o (ex: 'introSection').
         */
        window.suggestSoundtrack = async (sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const scriptContent = sectionElement.querySelector('.generated-content-wrapper').textContent; // Updated selector
            const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
            
            if (!scriptContent) {
                window.showToast("Gere o roteiro para esta se√ß√£o primeiro.");
                return;
            }

            soundtrackContainer.innerHTML = `<div class="loading-spinner-small"></div>`; // Mostra um spinner

            const prompt = `Voc√™ √© um especialista em prompts para IAs de gera√ß√£o de m√∫sica (como Suno/Udio). Sua tarefa √© analisar o seguinte trecho de roteiro e criar 3 prompts de texto distintos e detalhados.

**REGRAS DE FORMATA√á√ÉO (N√ÉO NEGOCI√ÅVEIS):**1.  Sua resposta DEVE SER um array JSON v√°lido.2.  O array deve conter EXATAMENTE 3 strings.3.  CADA string deve ser um par√°grafo √∫nico, bem escrito e descritivo, pronto para ser colado em uma IA de m√∫sica. N√ÉO use chaves, colchetes ou qualquer outra sintaxe de objeto DENTRO da string do prompt.

**EXEMPLO DE RESPOSTA PERFEITA:**
["Generate an epic, cinematic orchestral piece in the style of Hans Zimmer... No vocals or percussion, focus on the emotional intensity of the strings and piano.","Create a contemplative, melancholic ambient track with a slow, mournful tempo... No bright or cheerful notes, focus on the darker, more introspective tones.","Craft an uplifting, inspirational electronic piece with a moderate tempo... avoid any jarring or harsh sounds, focusing on the soaring, inspirational quality of the melody."
]

Agora, use o roteiro abaixo como inspira√ß√£o para criar 3 prompts seguindo EXATAMENTE este formato.

Trecho do roteiro para analisar:
---
${scriptContent}
---`;
            
            try {
                const rawResult = await callGroqAPI(prompt, 500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const suggestions = JSON.parse(cleanedResult);

                // Adiciona tratamento de erro para garantir que suggestions √© um array de strings
                if (!Array.isArray(suggestions) || !suggestions.every(s => typeof s === 'string')) {
                    throw new Error("A IA retornou um formato de trilha sonora inesperado. Esperava um array de strings.");
                }

                soundtrackContainer.innerHTML = ''; // Limpa o spinner
                if (suggestions && suggestions.length > 0) {
                    // --- IN√çCIO DA MUDAN√áA PRINCIPAL ---
                    // Agora envolvemos a lista em um div com as classes corretas para ter um fundo e padding.
                    let suggestionsHtml = '<div class="card-background p-4 rounded-lg shadow-inner">';
                    suggestionsHtml += '<ul class="soundtrack-list">';
                    suggestions.forEach(suggestion => {
                        suggestionsHtml += `<li>${suggestion}</li>`;
                    });
                    suggestionsHtml += '</ul>';
                    suggestionsHtml += '</div>'; // Fecha o novo div
                    // --- FIM DA MUDAN√áA PRINCIPAL ---

                    soundtrackContainer.innerHTML = suggestionsHtml;
                } else {
                    soundtrackContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhuma sugest√£o de trilha sonora foi gerada.</p>';
                }
            } catch (error) {
                soundtrackContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugest√µes: ${error.message}</p>`;
            }
        };

        /**
=======
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
         * Gera t√≠tulos de v√≠deo e ideias de thumbnail.
         */
        const generateTitlesAndThumbnails = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateTitlesAndThumbnailsBtn);
            try {
                const { prompt, maxTokens } = constructScriptPrompt('titles_thumbnails');
                const result = await callGroqAPI(prompt, maxTokens);
                const cleanedResult = cleanGeneratedText(result, true);
                
                if (!cleanedResult) throw new Error("A IA n√£o retornou um JSON v√°lido.");
                
                const parsedContent = JSON.parse(cleanedResult);
                generatedTitlesAndThumbnails = parsedContent;

                const targetContentElement = document.getElementById('titlesThumbnailsContent');
                if (targetContentElement) {
                    const titlesListHtml = parsedContent.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                    const thumbnailsListHtml = parsedContent.thumbnails.map((thumb, index) => `
                        <div class="${index === 0 ? '' : 'thumbnail-item-separator'}"> 
                            <p class="font-semibold">"${thumb.title}"</p>
                            <p class="text-sm leading-tight">Descri√ß√£o: ${thumb.description}</p>
                        </div>
                    `).join('');

                    targetContentElement.innerHTML = `
                        <div class="space-y-4 text-sm">
                            <div>
                                <h4 class="font-bold text-base mb-2">Sugest√µes de T√≠tulos:</h4>
                                <div class="p-3 card-background rounded-md space-y-2">${titlesListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeTitles()">Analisar CTR</button>
                                    <div id="ctrAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                            <div>
                                <h4 class="font-bold text-base mb-2">Ideias de Thumbnail:</h4>
                                <div class="p-3 card-background rounded-md space-y-3">${thumbnailsListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeThumbnails()">Analisar Thumbnails</button>
                                    <div id="thumbnailAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    markButtonAsCompleted(buttons.generateTitlesAndThumbnailsBtn.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar T√≠tulos: ${error.message}`);
                console.error("Error generating Titles/Thumbnails.", error);
            } finally {
                hideLoading(buttons.generateTitlesAndThumbnailsBtn);
                updateButtonStates();
            }
        };
<<<<<<< HEAD

        /**
         * Analisa o potencial de clique (CTR) dos t√≠tulos gerados.
         */
        window.analyzeTitles = async () => {
            if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.titles || generatedTitlesAndThumbnails.titles.length === 0) {
                window.showToast("Gere os t√≠tulos primeiro!");
                return;
            }

            const resultContainer = document.getElementById('ctrAnalysisResult');
            resultContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

            const titlesString = generatedTitlesAndThumbnails.titles.join('\n');
            
            const prompt = `Voc√™ √© um especialista em marketing de conte√∫do para o YouTube. Analise a seguinte lista de t√≠tulos de v√≠deo. Para cada um, forne√ßa uma "nota de CTR" de 0 a 10 (onde 10 √© um clique quase garantido) e uma sugest√£o curta e objetiva para melhor√°-lo, focando em curiosidade, urg√™ncia e benef√≠cio claro.

            Responda APENAS com um array JSON. Cada objeto no array deve ter as chaves "titulo_original", "nota_ctr" e "sugestao_melhora".

            T√≠tulos para analisar:
            ---
            ${titlesString}
            ---`;

            try {
                const rawResult = await callGroqAPI(prompt, 2000);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const analysis = JSON.parse(cleanedResult);

                let analysisHtml = '<div class="space-y-4">';
                analysis.forEach(item => {
                    analysisHtml += `
                        <div class="p-3 card-background rounded-md shadow-sm">
                            <p class="font-semibold text-gray-800 dark:text-gray-200">${item.titulo_original}</p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de CTR:</strong> <span class="text-indigo-500 font-bold">${item.nota_ctr} / 10</span></p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugest√£o:</strong> ${item.sugestao_melhora}</p>
                        </div>
                    `;
                });
                analysisHtml += '</div>';
                resultContainer.innerHTML = analysisHtml;

            } catch (error) {
                resultContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao analisar os t√≠tulos: ${error.message}</p>`;
            }
        };

        /**
         * Analisa o potencial de clique (CTR) das ideias de thumbnail geradas.
         */
        window.analyzeThumbnails = async () => {
            if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.thumbnails || generatedTitlesAndThumbnails.thumbnails.length === 0) {
                window.showToast("Gere as ideias de thumbnail primeiro!");
                return;
            }

            const resultContainer = document.getElementById('thumbnailAnalysisResult');
            resultContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

            const thumbnailsString = generatedTitlesAndThumbnails.thumbnails.map(t => `T√≠tulo: ${t.title}, Descri√ß√£o: ${t.description}`).join('\n---\n');
            
            // --- IN√çCIO DA CORRE√á√ÉO NO PROMPT ---
            const prompt = `Voc√™ √© um Diretor de Arte e especialista em YouTube. Analise a seguinte lista de ideias para thumbnails. Para cada uma, forne√ßa uma "nota de potencial visual" de 0 a 10 (onde 10 √© uma imagem irresist√≠vel) e uma sugest√£o curta para maximizar o impacto visual, focando em contraste, emo√ß√£o facial, clareza e curiosidade.

            Responda APENAS com um array JSON. Cada objeto no array deve ter as chaves "titulo", "nota_visual" e "sugestao_melhora". A chave "titulo" DEVE conter o t√≠tulo original da ideia que voc√™ analisou.

            Ideias para analisar:
            ---
            ${thumbnailsString}
            ---`;
            // --- FIM DA CORRE√á√ÉO NO PROMPT ---

            try {
                const rawResult = await callGroqAPI(prompt, 2500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const analysis = JSON.parse(cleanedResult);

                let analysisHtml = '<div class="space-y-4">';
                analysis.forEach(item => {
                    // --- IN√çCIO DA CORRE√á√ÉO NA RENDERIZA√á√ÉO ---
                    analysisHtml += `
                        <div class="p-3 card-background rounded-md shadow-sm">
                            <p class="font-semibold text-gray-800 dark:text-gray-200">"${item.titulo || 'Ideia Sem T√≠tulo'}"</p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de Potencial Visual:</strong> <span class="text-indigo-500 font-bold">${item.nota_visual} / 10</span></p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugest√£o:</strong> ${item.sugestao_melhora}</p>
                        </div>
                    `;
                    // --- FIM DA CORRE√á√ÉO NA RENDERIZA√á√ÉO ---
                });
                analysisHtml += '</div>';
                resultContainer.innerHTML = analysisHtml;

            } catch (error) {
                resultContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao analisar as thumbnails: ${error.message}</p>`;
            }
        };
=======
    
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
        /**
         * Gera a descri√ß√£o do v√≠deo e hashtags.
         */
        const generateVideoDescription = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateDescriptionBtn);
            try {
<<<<<<< HEAD
                let result = await callGroqAPI(constructScriptPrompt('description').prompt, constructScriptPrompt('description').maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result); // <-- REINTRODUZIMOS A LIMPEZA!
=======
                const { prompt, maxTokens } = constructScriptPrompt('description');
                let result = await callGroqAPI(prompt, maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                
                const targetContentElement = document.getElementById('videoDescriptionContent');
                if (targetContentElement) {
                    targetContentElement.innerHTML = `<div class="p-3 text-sm card-background rounded-md whitespace-pre-wrap">${result}</div>`;
                    markButtonAsCompleted(buttons.generateDescriptionBtn.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar Descri√ß√£o: ${error.message}`);
                console.error("Error generating Video Description.", error);
            } finally {
                hideLoading(buttons.generateDescriptionBtn);
                updateButtonStates();
            }
        };

        /**
<<<<<<< HEAD
         * Gera o esbo√ßo estrat√©gico do roteiro.
         */
        const generateStrategicOutline = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateOutlineBtn);
            const outlineContentDiv = elements.outlineContent;
            outlineContentDiv.innerHTML = `<div class="loading-spinner-small mx-auto"></div>`;

            try {
                const { prompt, maxTokens } = constructScriptPrompt('outline', 'Esbo√ßo Estrat√©gico');
                const result = await callGroqAPI(prompt, maxTokens); // Use maxTokens from constructScriptPrompt
                const cleanedResult = cleanGeneratedText(result, true);

                if (!cleanedResult) throw new Error("A IA n√£o retornou um JSON v√°lido para o esbo√ßo.");

                strategicOutline = JSON.parse(cleanedResult); // Armazena o esbo√ßo globalmente
                
                // Formata o esbo√ßo para exibi√ß√£o com t√≠tulos traduzidos
                const titleTranslations = {
                    'introduction': 'Introdu√ß√£o',
                    'development': 'Desenvolvimento',
                    'climax': 'Cl√≠max',
                    'conclusion': 'Conclus√£o',
                    'cta': 'CTA'
                };
                let outlineHtml = '<ul class="list-disc list-inside space-y-2 text-sm">';
                for (const key in strategicOutline) {
                    // Busca a tradu√ß√£o no nosso dicion√°rio, ou usa a chave original capitalizada como fallback
                    const translatedTitle = titleTranslations[key] || (key.charAt(0).toUpperCase() + key.slice(1));
                    
                    outlineHtml += `<li><strong class="font-semibold">${translatedTitle}:</strong> ${strategicOutline[key]}</li>`;
                }
                outlineHtml += '</ul>';
                outlineContentDiv.innerHTML = outlineHtml;

                // REMOVIDO: Habilita os bot√µes de gera√ß√£o de se√ß√£o
                // A l√≥gica agora est√° na fun√ß√£o handleGenerateSection para exibir um alerta.

                markButtonAsCompleted(buttons.generateOutlineBtn.id);

            } catch (error) {
                window.showToast(`Falha ao gerar Esbo√ßo: ${error.message}`);
                console.error("Error generating Outline.", error);
                outlineContentDiv.innerHTML = `<div class="asset-card-placeholder text-red-500">Erro ao gerar o esbo√ßo. Tente novamente.</div>`;
            } finally {
                hideLoading(buttons.generateOutlineBtn);
                updateButtonStates();
            }
        };


        /**
=======
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
         * Realiza o download do roteiro como PDF.
         */
        const downloadPdf = async () => {
            // 1. Criar um container tempor√°rio para a impress√£o
            let printContainer = document.createElement('div');
            printContainer.id = 'print-container';

            // 2. Coletar e formatar TODO o conte√∫do que queremos imprimir
            let htmlToPrint = `<h1 style="text-align: center; font-size: 22pt; margin-bottom: 24px;">${elements.videoTheme.value}</h1>`;

            // Adicionar o esbo√ßo estrat√©gico
            if (strategicOutline) {
                const titleTranslations = {
                    'introduction': 'Introdu√ß√£o',
                    'development': 'Desenvolvimento',
                    'climax': 'Cl√≠max',
                    'conclusion': 'Conclus√£o',
                    'cta': 'CTA'
                };
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Esbo√ßo Estrat√©gico</div>
                        <div class="print-section-content">
                            <ul style="list-style-type: disc; padding-left: 20px;">`;
                for (const key in strategicOutline) {
                    const translatedTitle = titleTranslations[key] || (key.charAt(0).toUpperCase() + key.slice(1));
                    htmlToPrint += `<li><strong>${translatedTitle}:</strong> ${strategicOutline[key]}</li>`;
                }
                htmlToPrint += `</ul></div></div>`;
            }

            // Adicionar o roteiro principal
            document.querySelectorAll('#scriptSectionsContainer .accordion-item').forEach(item => {
                const title = item.querySelector('h3')?.textContent;
                const content = item.querySelector('.generated-content-wrapper')?.textContent;
                if (title && content) {
                    htmlToPrint += `
                        <div class="print-section">
                            <div class="print-section-title">${title}</div>
                            <div class="print-section-content"><pre>${content}</pre></div>
                        </div>`;
                }
            });
            
            // Adicionar Descri√ß√£o e Hashtags
            const videoDescriptionContent = document.getElementById('videoDescriptionContent');
            if (videoDescriptionContent && videoDescriptionContent.textContent.trim() !== 'Clique em \'Gerar\' para ver a descri√ß√£o') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Descri√ß√£o & Hashtags</div>
                        <div class="print-section-content">${videoDescriptionContent.innerHTML}</div>
                    </div>`;
            }

            // Adicionar T√≠tulos e Thumbnails
            const titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent');
            if (titlesThumbnailsContent && titlesThumbnailsContent.textContent.trim() !== 'Clique em \'Gerar\' para ver as sugest√µes') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">T√≠tulos & Thumbnails</div>
                        <div class="print-section-content">${titlesThumbnailsContent.innerHTML}</div>
                    </div>`;
            }

            // 3. Injetar o HTML no container e adicion√°-lo ao body
            printContainer.innerHTML = htmlToPrint;
            document.body.appendChild(printContainer);

            // 4. Chamar a impress√£o
            window.print();

            // 5. Remover o container tempor√°rio ap√≥s a impress√£o (com um pequeno atraso para garantir a renderiza√ß√£o)
            setTimeout(() => {
                document.body.removeChild(printContainer);
            }, 500); // 500ms de atraso
        };

        /**
         * Reseta o estado da aplica√ß√£o para um novo roteiro.
         */
        const resetApplicationState = () => {
            elements.videoTheme.value = '';
            elements.videoDescription.value = '';
            elements.centralQuestion.value = '';
            elements.emotionalArc.value = '';
            elements.viralElements.value = '';
            elements.imageDescriptionEngine.value = '';
            elements.imageStyleSelect.value = 'cinematic';
            elements.customImageStyle.value = '';
            toggleCustomImageStyleVisibility();
<<<<<<< HEAD
            elements.narrativeStyle.value = 'direct';
=======
            // elements.narrativeStyle.value = 'direct'; // REMOVIDO
            elements.narrativeGoal.value = 'storytelling'; // Reset new narrative selects
            updateNarrativeStructureOptions(); // Update structure options
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            elements.videoDuration.value = '';

            // Limpar a coluna de roteiro
            document.querySelectorAll('#scriptColumn > .script-section').forEach(sec => {
                sec.innerHTML = '';
                sec.classList.remove('animate-fade-in'); // Remove a classe de anima√ß√£o ao resetar
            });
            // Limpar o cart√£o do esbo√ßo
            elements.outlineContent.innerHTML = `<div class="asset-card-placeholder">Clique em 'Criar Esbo√ßo' para a IA planejar a estrutura do roteiro.</div>`;
            strategicOutline = null; // Reseta o esbo√ßo estrat√©gico

            // Limpar os cart√µes de recursos e restaurar os placeholders
            document.getElementById('titlesThumbnailsContent').innerHTML = '<div class="asset-card-placeholder">Clique em \'Gerar\' para ver as sugest√µes</div>';
            document.getElementById('videoDescriptionContent').innerHTML = '<div class="asset-card-placeholder">Clique em \'Gerar\' para ver a descri√ß√£o</div>';
            // Removed storyboardContent reset
<<<<<<< HEAD
=======
            // document.getElementById('repurposeOutput').innerHTML = '<!-- O conte√∫do gerado ser√° injetado aqui -->'; // REMOVIDO
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5

            allImagePrompts = {}; // Limpa todos os prompts de imagem
            generatedTitlesAndThumbnails = null;
            
            resetCompletionIcons();
            updateButtonStates();
            updateProgressBar(); 

            // Esconder o dashboard at√© que um novo conte√∫do seja gerado
            elements.projectDashboard.classList.add('hidden');

            window.showToast("Pronto para um novo roteiro!");
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        /**
         * Exporta o estado atual do projeto para um arquivo JSON.
         */
        const exportProject = () => {
            const projectData = {
                inputs: {},
                outputs: {},
                memory: {
                    allImagePrompts: allImagePrompts,
                    generatedTitlesAndThumbnails: generatedTitlesAndThumbnails,
                    strategicOutline: strategicOutline // Exporta o esbo√ßo
                }
            };

            // Salva o estado dos inputs
            for (const key in elements) {
                if (elements[key] && typeof elements[key].value !== 'undefined') {
                    projectData.inputs[key] = elements[key].value;
                }
            }
            // Salva o conte√∫do gerado (HTML interno das se√ß√µes)
            const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'];
            scriptSectionIds.forEach(id => {
                const sectionElement = document.getElementById(id);
                if (sectionElement) {
                    projectData.outputs[id] = sectionElement.innerHTML;
                }
            });

            // Salva o conte√∫do do esbo√ßo
            projectData.outputs.strategicOutlineContent = elements.outlineContent.innerHTML;

            // Salva o conte√∫do dos cart√µes de recursos
            projectData.outputs.titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent').innerHTML;
            projectData.outputs.videoDescriptionContent = document.getElementById('videoDescriptionContent').innerHTML;
<<<<<<< HEAD
=======
            // projectData.outputs.repurposeOutput = document.getElementById('repurposeOutput').innerHTML; // REMOVIDO
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            // Removed storyboardContent export
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            const fileName = elements.videoTheme.value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro_viral';
            downloadAnchorNode.setAttribute("download", `${fileName}_projeto.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            window.showToast("Projeto exportado com sucesso!");
        };

        /**
         * Renderiza os prompts de imagem para uma se√ß√£o espec√≠fica na UI.
         * Usado ap√≥s carregar um projeto.
         * @param {string} sectionElementId - O ID do elemento HTML da se√ß√£o.
         */
        const renderImagePromptsForSection = (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            if (!sectionElement) return;

            const promptContainer = sectionElement.querySelector('.prompt-container');
            if (!promptContainer) return;

            promptContainer.innerHTML = ''; // Limpa prompts existentes

            const promptsData = allImagePrompts[sectionElementId];
            if (promptsData && promptsData.length > 0) {
                promptsData.forEach((promptData, index) => { // Added index here for ID
                    const styleBlockContent = promptData.styleBlock || '';
                    const promptHtml = `
                        <div class="individual-prompt-block card-background">
                            <div class="flex items-center justify-between mb-2">
                                <p class="prompt-time">${promptData.time} - Cena 00</p>
                                <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${index}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${index}').textContent); window.showCopyFeedback(this)">Copiar</button>
                            </div>
                            <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                            <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                            <p id="prompt-content-${sectionElementId}-${index}" class="prompt-description-content">${promptData.imageDescription}</p>
                            <pre id="style-block-${sectionElementId}-${index}" class="text-xs p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                        </div>
                    `;
                    promptContainer.innerHTML += promptHtml;
                });
            } else {
                promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta se√ß√£o.</p>';
            }
        };

        /**
         * Importa um projeto de um arquivo JSON.
         * @param {Event} event - O evento de mudan√ßa do input de arquivo.
         */
        const importProject = (event) => {
            const file = event.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    resetApplicationState();

                    for (const key in projectData.inputs) {
                        if (elements[key] && typeof elements[key].value !== 'undefined') {
                            elements[key].value = projectData.inputs[key];
                        }
                    }

                    const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'];
                    scriptSectionIds.forEach(id => {
                        const sectionElement = document.getElementById(id);
                        if (sectionElement && projectData.outputs[id]) {
                            sectionElement.innerHTML = projectData.outputs[id];
                            sectionElement.classList.remove('hidden');
                            sectionElement.classList.add('animate-fade-in');
                        }
                    });

                    if (projectData.outputs.strategicOutlineContent) {
                        elements.outlineContent.innerHTML = projectData.outputs.strategicOutlineContent;
                    }
                    strategicOutline = projectData.memory.strategicOutline || null;

                    if (projectData.outputs.titlesThumbnailsContent) {
                        document.getElementById('titlesThumbnailsContent').innerHTML = projectData.outputs.titlesThumbnailsContent;
                    }
                    if (projectData.outputs.videoDescriptionContent) {
                        document.getElementById('videoDescriptionContent').innerHTML = projectData.outputs.videoDescriptionContent;
                    }
<<<<<<< HEAD
=======
                    // if (projectData.outputs.repurposeOutput) { // REMOVIDO
                    //     document.getElementById('repurposeOutput').innerHTML = projectData.outputs.repurposeOutput;
                    // }
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                    
                    allImagePrompts = projectData.memory.allImagePrompts || {};
                    generatedTitlesAndThumbnails = projectData.memory.generatedTitlesAndThumbnails || null;

                    updateButtonStates();
                    
                    if (elements.outlineContent.textContent.trim().length > 100) markButtonAsCompleted('generateOutlineBtn');
                    if (document.getElementById('introSection').innerHTML.trim()) markButtonAsCompleted('generateIntroBtn');
                    if (document.getElementById('developmentSection').innerHTML.trim()) markButtonAsCompleted('generateDevelopmentBtn');
                    if (document.getElementById('climaxSection').innerHTML.trim()) markButtonAsCompleted('climaxBtn');
                    if (document.getElementById('conclusionSection').innerHTML.trim()) markButtonAsCompleted('conclusionBtn');
                    if (document.getElementById('ctaSection').innerHTML.trim()) markButtonAsCompleted('generateCTABtn');
                    if (document.getElementById('videoDescriptionContent').innerHTML.includes('Hashtags')) markButtonAsCompleted('generateDescriptionBtn');
                    if (document.getElementById('titlesThumbnailsContent').innerHTML.includes('Analisar CTR')) markButtonAsCompleted('generateTitlesAndThumbnailsBtn');

                    // Re-renderiza os prompts de imagem para todas as se√ß√µes
                    for (const sectionId in allImagePrompts) {
                        if (allImagePrompts.hasOwnProperty(sectionId)) {
                            renderImagePromptsForSection(sectionId);
                        }
                    }
                    // --- CHAMADA DA NOVA FUN√á√ÉO "MAESTRO" ---
                    // Garante a renumera√ß√£o correta ao importar um projeto.
                    reNumberAllScenes();

                    updateProgressBar(); 
                    elements.projectDashboard.classList.remove('hidden');
                    window.showToast("Projeto importado com sucesso!");

                } catch (err) {
                    window.showToast("Erro: Arquivo de projeto inv√°lido ou corrompido.");
                    console.error("Erro ao importar projeto:", err);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        };

        /**
         * Analisa o tema e a descri√ß√£o do v√≠deo para definir a estrat√©gia de conte√∫do.
         */
        const analyzeAndSetStrategy = async () => {
            const theme = elements.videoTheme.value.trim();
            const description = elements.videoDescription.value.trim();

            if (!theme || !description) {
                window.showToast("Por favor, preencha o Tema e a Descri√ß√£o do V√≠deo.");
                return;
            }

            const button = buttons.analyzeStrategyBtn;
            showLoading(button);

<<<<<<< HEAD
            // Op√ß√µes v√°lidas para cada campo (precisamos disso para a IA)
            const languageStyleOptions = Array.from(elements.languageStyle.options).map(o => o.value).join(', ');
            const videoObjectiveOptions = Array.from(elements.videoObjective.options).map(o => o.value).join(', ');
            const narrativeStyleOptions = Array.from(elements.narrativeStyle.options).map(o => o.value).join(', ');

=======
            const languageStyleOptions = Array.from(elements.languageStyle.options).map(o => o.value).join(', ');
            const videoObjectiveOptions = Array.from(elements.videoObjective.options).map(o => o.value).join(', ');
            // const narrativeStyleOptions = Array.from(elements.narrativeStyle.options).map(o => o.value).join(', '); // REMOVIDO
            // Usar as chaves dos objetos narrativeStructures para construir a lista de op√ß√µes v√°lidas
            const narrativeStructureOptions = Object.keys(narrativeStructures.storytelling).concat(Object.keys(narrativeStructures.storyselling)).join(', ');


            // --- IN√çCIO DA CORRE√á√ÉO NO PROMPT ---
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
            const prompt = `Voc√™ √© um Estrategista de Conte√∫do de IA para o YouTube. Sua tarefa √© analisar o tema e a descri√ß√£o de um v√≠deo e definir a melhor estrat√©gia de conte√∫do para ele.

            Tema do V√≠deo: "${theme}"
            Descri√ß√£o do V√≠deo: "${description}"

            Com base nisso, preencha os seguintes campos. Responda APENAS com um objeto JSON v√°lido.

            O objeto JSON deve ter as seguintes chaves:
            1.  "target_audience": (string) Descreva em uma frase o p√∫blico-alvo ideal para este v√≠deo.
            2.  "language_style": (string) Escolha o melhor estilo de linguagem da seguinte lista: [${languageStyleOptions}].
<<<<<<< HEAD
            3.  "video_objective": (string) Analise o tema e escolha o objetivo principal do v√≠deo. Sua resposta para esta chave DEVE SER UMA correspond√™ncia EXATA de uma das seguintes op√ß√µes: [${videoObjectiveOptions}].
            4.  "narrative_style": (string) Escolha a estrutura narrativa mais impactante da seguinte lista: [${narrativeStyleOptions}].
            5.  "central_question": (string) Formule a pergunta central mais intrigante que o v√≠deo deve responder.
            6.  "emotional_arc": (string) Descreva o arco emocional ideal em uma frase curta (Ex: Curiosidade -> Tens√£o -> Revela√ß√£o -> Inspira√ß√£o).

            Analise profundamente o tema e a descri√ß√£o para fazer as escolhas mais coesas e eficazes.`;
=======
            3.  "video_objective": (string) Analise o tema e escolha o objetivo principal do v√≠deo. **Sua resposta para esta chave DEVE SER UMA correspond√™ncia EXATA de uma das seguintes op√ß√µes, sem qualquer altera√ß√£o:** [${videoObjectiveOptions}].
            4.  "narrative_goal": (string) Escolha o objetivo principal da narrativa. Sua resposta DEVE SER UMA correspond√™ncia EXATA de uma das seguintes op√ß√µes: "storytelling" ou "storyselling".
            5.  "narrative_structure": (string) Escolha a estrutura narrativa mais impactante da seguinte lista: [${narrativeStructureOptions}]. Sua resposta DEVE SER UMA correspond√™ncia EXATA de uma das op√ß√µes v√°lidas para o "narrative_goal" escolhido.
            6.  "central_question": (string) Formule a pergunta central mais intrigante que o v√≠deo deve responder.
            7.  "emotional_arc": (string) Descreva o arco emocional ideal em uma frase curta (Ex: Curiosidade -> Tens√£o -> Revela√ß√£o -> Inspira√ß√£o).

            Analise profundamente o tema e a descri√ß√£o para fazer as escolhas mais coesas e eficazes.`;
            // --- FIM DA CORRE√á√ÉO NO PROMPT ---
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5

            try {
                const rawResult = await callGroqAPI(prompt, 1000);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const strategy = JSON.parse(cleanedResult);

<<<<<<< HEAD
                // Preenche os campos da interface com a resposta da IA
=======
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                if(strategy.target_audience) elements.targetAudience.value = strategy.target_audience;
                if(strategy.language_style) elements.languageStyle.value = strategy.language_style;
                
                if (strategy.video_objective) {
                    const objectiveSelect = elements.videoObjective;
<<<<<<< HEAD
                    const returnedValue = strategy.video_objective;
                    
                    // Cria um array com todos os valores v√°lidos das op√ß√µes
                    const validOptions = Array.from(objectiveSelect.options).map(opt => opt.value);
                    
                    // Verifica se o valor retornado pela IA est√° na nossa lista de op√ß√µes v√°lidas
                    if (validOptions.includes(returnedValue)) {
                        objectiveSelect.value = returnedValue;
                    } else {
                        // Se n√£o for v√°lido, define um padr√£o seguro (ex: 'informar')
=======
                    const returnedValue = strategy.video_objective.trim(); // Adiciona .trim() para seguran√ßa
                    
                    const validOptions = Array.from(objectiveSelect.options).map(opt => opt.value);
                    
                    if (validOptions.includes(returnedValue)) {
                        objectiveSelect.value = returnedValue;
                    } else {
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                        console.warn(`IA retornou um 'video_objective' inv√°lido: '${returnedValue}'. Usando o padr√£o 'informar'.`);
                        objectiveSelect.value = 'informar'; 
                    }
                }

<<<<<<< HEAD
                if(strategy.narrative_style) elements.narrativeStyle.value = strategy.narrative_style; // CORRIGIDO AQUI
=======
                // --- IN√çCIO DA MUDAN√áA AQUI: Define os novos selects ---
                if (strategy.narrative_goal) {
                    const goalSelect = elements.narrativeGoal;
                    const returnedGoal = strategy.narrative_goal.trim();
                    if (['storytelling', 'storyselling'].includes(returnedGoal)) {
                        goalSelect.value = returnedGoal;
                        updateNarrativeStructureOptions(); // Atualiza as op√ß√µes de estrutura com base no objetivo
                    } else {
                        console.warn(`IA retornou um 'narrative_goal' inv√°lido: '${returnedGoal}'. Usando o padr√£o 'storytelling'.`);
                        goalSelect.value = 'storytelling';
                        updateNarrativeStructureOptions();
                    }
                }

                if (strategy.narrative_structure) {
                    const structureSelect = elements.narrativeStructure;
                    const returnedStructure = strategy.narrative_structure.trim();
                    // Verifica se a estrutura retornada √© v√°lida para o objetivo selecionado
                    const currentGoalStructures = narrativeStructures[elements.narrativeGoal.value];
                    if (currentGoalStructures && Object.keys(currentGoalStructures).includes(returnedStructure)) {
                        structureSelect.value = returnedStructure;
                    } else {
                        console.warn(`IA retornou uma 'narrative_structure' inv√°lida para o objetivo atual: '${returnedStructure}'. Usando o padr√£o da primeira op√ß√£o.`);
                        // Define a primeira op√ß√£o v√°lida como padr√£o
                        structureSelect.value = Object.keys(currentGoalStructures)[0];
                    }
                }
                // --- FIM DA MUDAN√áA AQUI ---

>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
                if(strategy.central_question) elements.centralQuestion.value = strategy.central_question;
                if(strategy.emotional_arc) elements.emotionalArc.value = strategy.emotional_arc;

                window.showToast("Estrat√©gia definida com sucesso!");
<<<<<<< HEAD
                elements.projectDashboard.classList.remove('hidden'); // Show dashboard after strategy is set
=======
                elements.projectDashboard.classList.remove('hidden');
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5

            } catch (error) {
                window.showToast(`Falha ao definir estrat√©gia: ${error.message}`);
                console.error("Erro na an√°lise estrat√©gica:", error);
            } finally {
                hideLoading(button);
            }
        };
<<<<<<< HEAD
=======
    
        /**
         * Gera o esbo√ßo estrat√©gico do roteiro.
         */
        const generateStrategicOutline = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateOutlineBtn);
            const outlineContentDiv = elements.outlineContent;
            outlineContentDiv.innerHTML = `<div class="loading-spinner-small mx-auto"></div>`;

            try {
                const { prompt, maxTokens } = constructScriptPrompt('outline', 'Esbo√ßo Estrat√©gico');
                const result = await callGroqAPI(prompt, maxTokens);
                const cleanedResult = cleanGeneratedText(result, true);

                if (!cleanedResult) throw new Error("A IA n√£o retornou um JSON v√°lido para o esbo√ßo.");

                strategicOutline = JSON.parse(cleanedResult);

                // Formata o esbo√ßo para exibi√ß√£o com t√≠tulos traduzidos
                const titleTranslations = {
                    'introduction': 'Introdu√ß√£o',
                    'development': 'Desenvolvimento',
                    'climax': 'Cl√≠max',
                    'conclusion': 'Conclus√£o',
                    'cta': 'CTA'
                };
                let outlineHtml = '<ul class="list-disc list-inside space-y-2 text-sm">';
                for (const key in strategicOutline) {
                    const translatedTitle = titleTranslations[key] || (key.charAt(0).toUpperCase() + key.slice(1));
                    
                    outlineHtml += `<li><strong class="font-semibold">${translatedTitle}:</strong> ${strategicOutline[key]}</li>`;
                }
                outlineHtml += '</ul>';
                outlineContentDiv.innerHTML = outlineHtml;

                markButtonAsCompleted(buttons.generateOutlineBtn.id);

            } catch (error) {
                window.showToast(`Falha ao gerar Esbo√ßo: ${error.message}`);
                console.error("Error generating Outline.", error);
                outlineContentDiv.innerHTML = `<div class="asset-card-placeholder text-red-500">Erro ao gerar o esbo√ßo. Tente novamente.</div>`;
            } finally {
                hideLoading(buttons.generateOutlineBtn);
                updateButtonStates();
            }
        };
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5

        /**
         * Controla a visibilidade e o conte√∫do da barra de a√ß√µes flutuante com base na rolagem.
         */
        window.handleFloatingActionBar = () => {
            const mainActions = document.getElementById('mainActions');
            const quickActions = document.getElementById('quickActions');
            const projectDashboard = document.getElementById('projectDashboard'); // Changed from scriptOutput
            
            if (!projectDashboard) return;

            const actionBar = elements.floatingActionBar;
            // Ponto de gatilho para a barra flutuante (um pouco antes da √°rea de output)
            const triggerPoint = projectDashboard.offsetTop - actionBar.offsetHeight - 50; // 50px de buffer

            if (window.scrollY > triggerPoint) {
                // Se rolou para a √°rea de resultados, mostra a barra e as A√ß√µes R√°pidas
                actionBar.classList.add('visible');
                mainActions.classList.add('hidden');
                quickActions.classList.remove('hidden');
            } else if (window.scrollY > 150) { // Um pequeno buffer para n√£o aparecer imediatamente no topo
                // Se rolou um pouco, mas n√£o chegou nos resultados, mostra a barra com as A√ß√µes Principais
                actionBar.classList.add('visible');
                mainActions.classList.remove('hidden');
                quickActions.classList.add('hidden');
            } else {
                // Se est√° no topo, esconde a barra
                actionBar.classList.remove('visible');
            }
        };

        /**
         * Alterna o estado de um acorde√£o (abrir/fechar).
         * @param {string} bodyId - O ID do corpo do acorde√£o.
         * @param {string} arrowId - O ID do √≠cone de seta do acorde√£o.
         */
        window.toggleAccordion = (bodyId, arrowId) => {
            const body = document.getElementById(bodyId);
            const arrow = document.getElementById(arrowId);
            if (body && arrow) {
                body.classList.toggle('open');
                arrow.classList.toggle('open');
                // Adiciona ou remove a classe 'active' no elemento pai do cabe√ßalho
                arrow.closest('.accordion-header').classList.toggle('active');
            }
        };

        // ==========================================================
        // NOVA FUN√á√ÉO PARA ATUALIZAR A BARRA DE PROGRESO
        // ==========================================================
        const updateProgressBar = () => {
            // Lista de todas as tarefas que contam para o progresso
            const taskButtonIds = [
                'generateOutlineBtn', // Added outline button
                'generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 
                'conclusionBtn', 'generateCTABtn', 'generateDescriptionBtn', 
                'generateTitlesAndThumbnailsBtn' 
            ];
            const totalTasks = taskButtonIds.length;

            let completedTasks = 0;
            taskButtonIds.forEach(id => {
                const button = document.getElementById(id);
                // Check if the button is marked as success (meaning content was generated)
                if (button && button.classList.contains('btn-success')) {
                    completedTasks++;
                }
            });

            const percentage = Math.round((completedTasks / totalTasks) * 100);

            // Atualiza a UI
            if (elements.progressBar && elements.progressText) {
                elements.progressBar.style.width = `${percentage}%`;
                elements.progressText.textContent = `${percentage}%`;

                if (percentage === 100) {
                    elements.progressBar.textContent = "Projeto Pronto!"; // Atualiza o texto diretamente na barra
                    elements.progressBar.style.backgroundColor = 'var(--primary-color)';
                } else {
                     // Garante que a cor volte ao verde se n√£o for 100%
                    elements.progressBar.style.backgroundColor = 'var(--success-color)';
                }
            }
        };

        // ==========================================================
<<<<<<< HEAD
        // ================== INICIALIZA√á√ÉO =======================
        // ==========================================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Initializing app."); 
            
            // Adiciona as novas refer√™ncias de elementos
            elements.progressBar = document.getElementById('progressBar');
            elements.progressText = document.getElementById('progressText');
            elements.projectDashboard = document.getElementById('projectDashboard'); // New reference
            elements.outlineContent = document.getElementById('outlineContent'); // New reference for outline content

            // Configura os event listeners para os bot√µes
            const setupClick = (originalId) => {
                const floatBtn = document.getElementById(`float_${originalId}`);
                if (floatBtn) {
                    floatBtn.addEventListener('click', () => {
                        document.getElementById(originalId).click();
                    });
                }
            };

            // Conecta os bot√µes flutuantes aos originais
            // Iterar sobre todos os bot√µes que t√™m um flutuante correspondente
            const allButtonIds = Object.keys(buttons);
            allButtonIds.forEach(id => {
                // Exclui o bot√£o do modo zen da barra flutuante, pois ele foi movido
                if (id.startsWith('generate') || id.startsWith('climax') || id.startsWith('conclusion') || id.startsWith('cta') || id.startsWith('download') || id.startsWith('reset') || id.startsWith('export') || id.startsWith('import')) {
                    setupClick(id);
                }
            });
            
            // Adiciona os listeners de a√ß√£o aos bot√µes originais
            if (buttons.generateOutlineBtn) buttons.generateOutlineBtn.addEventListener('click', generateStrategicOutline); // New listener for outline
            if (buttons.generateIntroBtn) buttons.generateIntroBtn.addEventListener('click', () => handleGenerateSection(buttons.generateIntroBtn, 'intro', 'Introdu√ß√£o', 'intro'));
            if (buttons.generateDevelopmentBtn) buttons.generateDevelopmentBtn.addEventListener('click', () => handleGenerateSection(buttons.generateDevelopmentBtn, 'development', 'Desenvolvimento', 'development'));
            if (buttons.climaxBtn) buttons.climaxBtn.addEventListener('click', () => handleGenerateSection(buttons.climaxBtn, 'climax', 'Cl√≠max', 'climax'));
            if (buttons.conclusionBtn) buttons.conclusionBtn.addEventListener('click', () => handleGenerateSection(buttons.conclusionBtn, 'conclusion', 'Conclus√£o', 'conclusion'));
            if (buttons.generateCTABtn) buttons.generateCTABtn.addEventListener('click', () => handleGenerateSection(buttons.generateCTABtn, 'cta', 'Chamada para A√ß√£o', 'cta'));
            if (buttons.generateTitlesAndThumbnailsBtn) buttons.generateTitlesAndThumbnailsBtn.addEventListener('click', generateTitlesAndThumbnails);
            if (buttons.generateDescriptionBtn) buttons.generateDescriptionBtn.addEventListener('click', generateVideoDescription);
            // Removed storyboard button listener
            if (buttons.resetScriptBtn) buttons.resetScriptBtn.addEventListener('click', resetApplicationState);
            if (buttons.downloadPdfBtn) buttons.downloadPdfBtn.addEventListener('click', downloadPdf); // Changed to window.print()
            if (buttons.exportProjectBtn) buttons.exportProjectBtn.addEventListener('click', exportProject); // Listener para o bot√£o de exportar
            
            // Outros listeners
            if (buttons.fullScreenAlertCloseBtn) buttons.fullScreenAlertCloseBtn.addEventListener('click', hideFullScreenAlert); // CORRIGIDO AQUI
            if (elements.imageStyleSelect) elements.imageStyleSelect.addEventListener('change', toggleCustomImageStyleVisibility);
            
            // NOVO C√ìDIGO √Ä PROVA DE BALAS PARA O MODO ESCURO
            const darkModeButton = document.getElementById('darkModeToggle');
            if (darkModeButton) {
                darkModeButton.addEventListener('click', () => {
                    const moonIcon = document.getElementById('moonIcon');
                    const sunIcon = document.getElementById('sunIcon');
                    
                    // Alterna a classe 'dark' no body
                    document.body.classList.toggle('dark');

                    // Verifica se o modo escuro est√° ATIVO agora
                    if (document.body.classList.contains('dark')) {
                        // Se SIM, esconde a lua, mostra o sol, e salva no localStorage
                        if (moonIcon) moonIcon.classList.add('hidden');
                        if (sunIcon) sunIcon.classList.remove('hidden');
                        localStorage.setItem('darkMode', 'enabled');
                    } else {
                        // Se N√ÉO, esconde o sol, mostra a lua, e salva no localStorage
                        if (moonIcon) moonIcon.classList.remove('hidden');
                        if (sunIcon) sunIcon.classList.add('hidden'); // This was moonIcon.classList.add('hidden');
                        localStorage.setItem('darkMode', 'disabled');
                    }
                });
            }
            // Adicione esta linha dentro do DOMContentLoaded, fora de qualquer listener
            if (localStorage.getItem('darkMode') === 'enabled') {
                const moonIcon = document.getElementById('moonIcon');
                const sunIcon = document.getElementById('sunIcon');
                document.body.classList.add('dark');
                if (moonIcon) moonIcon.classList.add('hidden');
                if (sunIcon) sunIcon.classList.remove('hidden');
            }

            if (buttons.analyzeStrategyBtn) buttons.analyzeStrategyBtn.addEventListener('click', analyzeAndSetStrategy);
            if (buttons.importProjectBtn) {
                buttons.importProjectBtn.addEventListener('click', () => elements.importFileInput.click());
                elements.importFileInput.addEventListener('change', importProject);
            }

            // L√≥gica para o Modo Zen
            const zenModeBtn = document.getElementById('toggleZenModeBtn');
            if (zenModeBtn) {
                zenModeBtn.addEventListener('click', () => {
                    document.body.classList.toggle('zen-mode');
                });
            }

            const exitZenModeBtn = document.getElementById('exitZenModeBtn');
            if (exitZenModeBtn) {
                exitZenModeBtn.addEventListener('click', () => {
                    document.body.classList.remove('zen-mode');
                });
            }

            // Define o estado inicial dos bot√µes
            updateButtonStates();
            // Adiciona o listener de rolagem para a barra flutuante
            window.addEventListener('scroll', window.handleFloatingActionBar);
            updateProgressBar(); 
        });
    </script>
</body>
</html>
=======
        // ================== FUN√á√ïES PRINCIPAIS ====================
        // ==========================================================
        /**
         * Valida os inputs essenciais antes de chamar a API.
         * @returns {boolean} True se os inputs forem v√°lidos, false caso contr√°rio.
         */
        const validateInputs = () => {
            const requiredInputs = [
                { id: 'channelName', name: 'Nome do Canal' },
                { id: 'videoTheme', name: 'Tema do V√≠deo' }
            ];

            for (const input of requiredInputs) {
                if (!elements[input.id] || elements[input.id].value.trim() === '') {
                    showFullScreenAlert(`Por favor, preencha o campo "${input.name}" para continuar.`);
                    return false;
                }
            }
            return true;
        };

        /**
         * Gera uma se√ß√£o do roteiro (Introdu√ß√£o, Desenvolvimento, Cl√≠max, Conclus√£o, CTA).
         * @param {HTMLElement} button - O bot√£o que acionou a gera√ß√£o.
         * @param {string} sectionType - O tipo de se√ß√£o (ex: 'intro', 'development').
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o para exibi√ß√£o.
         * @param {string} outlineKey - A chave correspondente no objeto strategicOutline.
         */
        const handleGenerateSection = async (button, sectionType, sectionTitle, outlineKey) => {
            if (!validateInputs()) return;

            // Verifica se o esbo√ßo estrat√©gico foi gerado
            if (!strategicOutline) {
                showFullScreenAlert("Por favor, gere o 'Esbo√ßo Estrat√©gico' primeiro.");
                return;
            }

            showLoading(button);
            const sectionElement = document.getElementById(`${sectionType}Section`);
            const outlineDirective = strategicOutline[outlineKey] || null;

            try {
                const { prompt, maxTokens } = constructScriptPrompt(sectionType, sectionTitle, outlineDirective);
                let result = await callGroqAPI(prompt, maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);

                if (sectionElement) {
                    sectionElement.innerHTML = generateSectionHtmlContent(`${sectionType}Section`, sectionTitle, result);
                    sectionElement.classList.remove('hidden');
                    sectionElement.classList.add('animate-fade-in');
                    markButtonAsCompleted(button.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
                console.error(`Error generating ${sectionTitle}.`, error);
            } finally {
                hideLoading(button);
                updateButtonStates();
            }
        };

        /**
         * Re-gera uma se√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionId - O ID do elemento HTML da se√ß√£o.
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o.
         * @param {string} outlineKey - A chave correspondente no objeto strategicOutline.
         */
        window.regenerateSection = async (sectionId, sectionTitle, outlineKey) => {
            const sectionElement = document.getElementById(sectionId);
            const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
            const originalContent = contentWrapper ? contentWrapper.innerHTML : '';

            // Temporariamente mostra um spinner dentro da se√ß√£o
            if (contentWrapper) {
                contentWrapper.innerHTML = `<div class="loading-spinner-small mx-auto"></div>`;
            }

            // Desabilita todos os bot√µes de gera√ß√£o durante a re-gera√ß√£o
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = true; });

            const outlineDirective = strategicOutline[outlineKey] || null;

            try {
                const { prompt, maxTokens } = constructScriptPrompt(sectionId.replace('Section', ''), sectionTitle, outlineDirective);
                let result = await callGroqAPI(prompt, maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);

                if (contentWrapper) {
                    contentWrapper.innerHTML = `<p class="whitespace-pre-wrap">${result}</p>`;
                }
                window.showToast(`${sectionTitle} re-gerada!`);
            } catch (error) {
                window.showToast(`Falha ao re-gerar ${sectionTitle}: ${error.message}`);
                console.error(`Error regenerating ${sectionTitle}.`, error);
                if (contentWrapper) {
                    contentWrapper.innerHTML = originalContent; // Restaura o conte√∫do original em caso de erro
                }
            } finally {
                // Reabilita todos os bot√µes ap√≥s a re-gera√ß√£o
                Object.values(buttons).forEach(btn => { if(btn) btn.disabled = false; });
                updateButtonStates();
            }
        };

        /**
         * Gera prompts de imagem para uma se√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionElementId - O ID do elemento HTML da se√ß√£o.
         */
        window.generatePromptsForSection = async (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            if (!sectionElement) return;

            const scriptContent = sectionElement.querySelector('.generated-content-wrapper')?.textContent;
            if (!scriptContent) {
                window.showToast("Por favor, gere o roteiro desta se√ß√£o primeiro.");
                return;
            }

            const promptContainer = sectionElement.querySelector('.prompt-container');
            if (promptContainer) {
                promptContainer.innerHTML = `<div class="loading-spinner-small mx-auto"></div>`;
            }

            // Desabilita todos os bot√µes de gera√ß√£o durante a gera√ß√£o de prompts
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = true; });

            const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
            const imageStyleSelect = elements.imageStyleSelect.value;
            const customImageStyle = elements.customImageStyle.value.trim();
            const selectedLanguage = elements.languageSelect.value;

            let styleBlock = '';
            if (imageStyleSelect === 'cinematic') {
                styleBlock = CINEMATIC_STYLE_BLOCK;
            } else if (imageStyleSelect === 'custom' && customImageStyle) {
                styleBlock = customImageStyle;
            }

            const prompt = `
            You are an AI specialized in generating detailed image prompts for video scenes.
            Analyze the following script section and generate 5 distinct image prompts.
            
            For each prompt, include:
            - A timestamp (e.g., "00:05").
            - The exact script phrase that corresponds to the visual.
            - A detailed visual description (the image prompt itself).
            
            Apply the following instructions for image descriptions: "${imageDescriptionEngine}".
            ${styleBlock ? `\nApply this visual style: ${styleBlock}` : ''}
            
            Respond ONLY with a valid JSON array of objects. Each object must have "time", "scriptPhrase", and "imageDescription" keys.
            
            Example JSON format:
            [
              {
                "time": "00:05",
                "scriptPhrase": "Imagine a vast, empty desert...",
                "imageDescription": "A wide shot of an endless, golden desert under a scorching sun. The sand dunes stretch to the horizon. Cinematic, high-resolution."
              },
              {
                "time": "00:10",
                "scriptPhrase": "A lone traveler struggles against the wind.",
                "imageDescription": "Close-up of a cloaked figure, face obscured, battling a strong sandstorm. Their clothes are tattered. Cinematic, detailed."
              }
            ]
            
            Script Section:
            "${scriptContent}"

            IMPORTANT: The 'imageDescription' should be a standalone prompt, ready to be used by an image generation AI. Do NOT include any meta-comments or conversational text outside the JSON.
            IMPORTANT: The response for this section MUST be in ${selectedLanguage}.
            `;

            try {
                const result = await callGroroqAPI(prompt, 1500);
                const cleanedResult = cleanGeneratedText(result, true);
                const parsedPrompts = JSON.parse(cleanedResult);

                allImagePrompts[sectionElementId] = parsedPrompts.map(p => ({ ...p, styleBlock })); // Store with style block

                promptContainer.innerHTML = ''; // Clear loading spinner
                parsedPrompts.forEach((promptData, index) => { // Added index here for ID
                    const promptHtml = `
                        <div class="individual-prompt-block card-background">
                            <div class="flex items-center justify-between mb-2">
                                <p class="prompt-time">${promptData.time} - Cena <span class="scene-number">00</span></p>
                                <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${index}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${index}').textContent); window.showCopyFeedback(this)">Copiar</button>
                            </div>
                            <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                            <p class="prompt-description-label">${imageDescriptionLabels[selectedLanguage] || 'Image Description:'}</p>
                            <p id="prompt-content-${sectionElementId}-${index}" class="prompt-description-content">${promptData.imageDescription}</p>
                            <pre id="style-block-${sectionElementId}-${index}" class="text-xs p-2 rounded-md overflow-auto">${styleBlock}</pre>
                        </div>
                    `;
                    promptContainer.innerHTML += promptHtml;
                });

                reNumberAllScenes(); // Renumber scenes after generation
                window.showToast("Prompts de imagem gerados!");
            } catch (error) {
                window.showToast(`Falha ao gerar prompts de imagem: ${error.message}`);
                console.error("Error generating image prompts.", error);
                if (promptContainer) {
                    promptContainer.innerHTML = `<p class="text-red-500">Erro ao gerar prompts. Tente novamente.</p>`;
                }
            } finally {
                // Reabilita todos os bot√µes
                Object.values(buttons).forEach(btn => { if(btn) btn.disabled = false; });
                updateButtonStates();
            }
        };

        /**
         * Sugere trilha sonora para uma se√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionElementId - O ID do elemento HTML da se√ß√£o.
         */
        window.suggestSoundtrack = async (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            if (!sectionElement) return;

            const scriptContent = sectionElement.querySelector('.generated-content-wrapper')?.textContent;
            if (!scriptContent) {
                window.showToast("Por favor, gere o roteiro desta se√ß√£o primeiro.");
                return;
            }

            const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
            if (soundtrackContainer) {
                soundtrackContainer.innerHTML = `<div class="loading-spinner-small mx-auto"></div>`;
            }

            // Desabilita todos os bot√µes de gera√ß√£o durante a gera√ß√£o de trilha sonora
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = true; });

            const prompt = `
            You are an AI specialized in suggesting background music for video segments.
            Analyze the following script section and suggest 3-5 suitable background music styles/genres or specific moods.
            For each suggestion, briefly explain why it fits the mood or content of the script.

            Respond ONLY with a valid JSON array of objects. Each object must have "genre" and "reason" keys.

            Example JSON format:
            [
              {
                "genre": "Epic Orchestral",
                "reason": "For moments of grand revelation and awe, building a sense of wonder."
              },
              {
                "genre": "Suspenseful Ambient",
                "reason": "To create tension and mystery during the exploration of unknown facts."
              }
            ]

            Script Section:
            "${scriptContent}"

            IMPORTANT: Do NOT include any meta-comments or conversational text outside the JSON.
            `;

            try {
                const result = await callGroqAPI(prompt, 500);
                const cleanedResult = cleanGeneratedText(result, true);
                const parsedSoundtrack = JSON.parse(cleanedResult);

                soundtrackContainer.innerHTML = ''; // Clear loading spinner
                let soundtrackHtml = '<ul class="soundtrack-list">';
                parsedSoundtrack.forEach(item => {
                    soundtrackHtml += `<li><strong>${item.genre}:</strong> ${item.reason}</li>`;
                });
                soundtrackHtml += '</ul>';
                soundtrackContainer.innerHTML = soundtrackHtml;

                window.showToast("Sugest√µes de trilha sonora geradas!");
            } catch (error) {
                window.showToast(`Falha ao sugerir trilha sonora: ${error.message}`);
                console.error("Error generating soundtrack suggestions.", error);
                if (soundtrackContainer) {
                    soundtrackContainer.innerHTML = `<p class="text-red-500">Erro ao gerar sugest√µes. Tente novamente.</p>`;
                }
            } finally {
                // Reabilita todos os bot√µes
                Object.values(buttons).forEach(btn => { if(btn) btn.disabled = false; });
                updateButtonStates();
            }
        };

        /**
         * Renumera todas as cenas de imagem em todas as se√ß√µes.
         * Esta fun√ß√£o deve ser chamada sempre que prompts de imagem forem gerados ou importados.
         */
        const reNumberAllScenes = () => {
            let sceneCounter = 1;
            const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'];

            scriptSectionIds.forEach(sectionId => {
                const sectionElement = document.getElementById(sectionId);
                if (sectionElement) {
                    const sceneNumberSpans = sectionElement.querySelectorAll('.prompt-time .scene-number');
                    sceneNumberSpans.forEach(span => {
                        span.textContent = String(sceneCounter++).padStart(2, '0');
                    });
                }
            });
        };

        /**
         * Fun√ß√£o dummy para simular a chamada √† API Groq.
         * Em um ambiente real, esta fun√ß√£o faria uma requisi√ß√£o HTTP para a API Groq.
         * @param {string} prompt - O prompt a ser enviado para a IA.
         * @param {number} maxTokens - O n√∫mero m√°ximo de tokens a serem gerados.
         * @returns {Promise<string>} Uma promessa que resolve com o texto gerado pela IA.
         */
        const callGroqAPI = async (prompt, maxTokens) => {
            console.log("Chamando Groq API com prompt:", prompt);
            // Simula√ß√£o de atraso da API
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Simula√ß√£o de respostas da IA
            if (prompt.includes("beat sheet") || prompt.includes("esbo√ßo estrat√©gico")) {
                return `{
                    "introduction": "Come√ßar com uma pergunta ret√≥rica chocante sobre a mortalidade, seguida por uma promessa de que a hist√≥ria de L√°zaro det√©m uma resposta inesperada. Gancho emocional: curiosidade e um toque de medo existencial.",
                    "development": "Construir a narrativa explorando o luto das irm√£s de L√°zaro, humanizando a hist√≥ria. Apresentar a chegada tardia de Jesus como um ponto de tens√£o e d√∫vida. Foco na emo√ß√£o de perda antes do milagre.",
                    "climax": "O momento de maior tens√£o no t√∫mulo. Descrever a ordem de Jesus com autoridade e o espanto da multid√£o. O milagre deve ser o pico emocional e visual do v√≠deo.",
                    "conclusion": "Resumir a li√ß√£o: o milagre n√£o √© sobre desafiar a morte, mas sobre o poder da f√©. Conectar a hist√≥ria de L√°zaro √† jornada de f√© pessoal do espectador.",
                    "cta": "Fazer uma chamada para a√ß√£o suave, pedindo para o espectador compartilhar sua pr√≥pria hist√≥ria de supera√ß√£o ou f√© nos coment√°rios, criando uma comunidade."
                }`;
            } else if (prompt.includes("video titles") && prompt.includes("thumbnail ideas")) {
                return `{
                  "titles": [
                    "A Arca da Alian√ßa: Onde Est√° AGORA?",
                    "O Segredo Milenar da Arca: Desvendado?",
                    "A Arca Perdida: A Verdade Chocante Revelada",
                    "Eles Encontraram a Arca da Alian√ßa? (IMPACTANTE)",
                    "Mist√©rio B√≠blico: A Arca e o Fim dos Tempos"
                  ],
                  "thumbnails": [
                    {
                      "title": "ENCONTRADA?",
                      "description": "Imagem dram√°tica de um ba√∫ antigo, brilhante, semi-enterrado em uma caverna escura, com um arque√≥logo chocado olhando. Efeito de luz m√≠stica."
                    },
                    {
                      "title": "O SEGREDO",
                      "description": "Colagem mostrando um mapa antigo desbotado, um texto b√≠blico secreto e uma imagem de sat√©lite apontando para um local na Eti√≥pia. Olhar misterioso."
                    },
                    {
                      "title": "HIST√ìRIA MUDOU",
                      "description": "Imagem visualmente deslumbrante da Arca da Alian√ßa irradiando luz dourada dentro de um Templo de Salom√£o reconstru√≠do. T√≠tulo em neon."
                    }
                  ]
                }`;
            } else if (prompt.includes("video description") && prompt.includes("hashtags")) {
                return `Description:
Neste v√≠deo, mergulhamos no mist√©rio da Arca da Alian√ßa, um dos artefatos mais enigm√°ticos da hist√≥ria b√≠blica. Exploramos as teorias mais fascinantes sobre seu paradeiro, desde lendas antigas at√© descobertas modernas. Ser√° que a Arca foi realmente encontrada? Prepare-se para uma jornada de f√©, hist√≥ria e revela√ß√µes que podem mudar sua perspectiva sobre o passado. Descubra os segredos que a Arca ainda guarda e as implica√ß√µes de sua poss√≠vel redescoberta para o mundo de hoje.

Hashtags:
#ArcaDaAlianca #MisteriosBiblicos #ArqueologiaBiblica #HistoriaAntiga #ProfeciasBiblicas #TeoriasDaConspiracao #Documentario #FeEHistoria #GrandesMisterios #DescobertasIncriveis`;
            } else if (prompt.includes("image prompts")) {
                return `[
                  {
                    "time": "00:05",
                    "scriptPhrase": "Desde os tempos mais remotos, a humanidade tem sido fascinada por mist√©rios que desafiam a l√≥gica e a compreens√£o.",
                    "imageDescription": "Uma cena panor√¢mica de uma biblioteca antiga e empoeirada, com tomos maci√ßos e pergaminhos enrolados em prateleiras altas. Poeira dan√ßando na luz que entra por uma janela alta. Estilo cinematogr√°fico, alta resolu√ß√£o."
                  },
                  {
                    "time": "00:15",
                    "scriptPhrase": "Mas poucos artefatos hist√≥ricos carregam tanto peso, tanto poder e tanto segredo quanto a lend√°ria Arca da Alian√ßa.",
                    "imageDescription": "Close-up dram√°tico de uma representa√ß√£o art√≠stica da Arca da Alian√ßa, com detalhes dourados brilhando. Luz intensa vinda de dentro da Arca, criando um brilho misterioso. Estilo cinematogr√°fico, fotorrealista."
                  },
                  {
                    "time": "00:25",
                    "scriptPhrase": "Onde ela est√°? Foi realmente encontrada? E o que aconteceria se seus segredos fossem revelados ao mundo?",
                    "imageDescription": "Uma sequ√™ncia r√°pida de tr√™s imagens: 1) Um mapa antigo com um 'X' misterioso, 2) Uma m√£o enluvada escavando algo na terra, 3) Uma multid√£o de pessoas olhando para cima com express√µes de espanto e admira√ß√£o. Estilo cinematogr√°fico, cores vibrantes."
                  },
                  {
                    "time": "00:35",
                    "scriptPhrase": "Prepare-se para uma jornada que transcende o tempo, a f√© e a pr√≥pria ci√™ncia.",
                    "imageDescription": "Uma figura solit√°ria, vista por tr√°s, em p√© na entrada de uma caverna escura e imponente, com um feixe de luz penetrando a escurid√£o. A figura parece estar prestes a embarcar em uma aventura. Estilo cinematogr√°fico, ilumina√ß√£o dram√°tica."
                  },
                  {
                    "time": "00:45",
                    "scriptPhrase": "A Arca da Alian√ßa: Onde est√° AGORA?",
                    "imageDescription": "Um close-up intenso do t√≠tulo 'A ARCA DA ALIAN√áA' em letras antigas e douradas, com a palavra 'AGORA?' piscando em neon vermelho ao fundo. Fundo escuro e misterioso. Estilo cinematogr√°fico, alta resolu√ß√£o."
                  }
                ]`;
            } else if (prompt.includes("background music")) {
                return `[
                  {
                    "genre": "Epic Orchestral / Aventura",
                    "reason": "Para construir uma sensa√ß√£o de grandiosidade e mist√©rio, ideal para a introdu√ß√£o e momentos de revela√ß√£o."
                  },
                  {
                    "genre": "Ambiental Suspense",
                    "reason": "Perfeito para as partes de desenvolvimento onde teorias e mist√©rios s√£o explorados, mantendo o espectador engajado."
                  },
                  {
                    "genre": "M√∫sica Sacra / Coral",
                    "reason": "Para momentos de reflex√£o sobre a f√© e o significado espiritual da Arca, adicionando uma camada de rever√™ncia."
                  }
                ]`;
            } else if (prompt.includes("Introdu√ß√£o")) {
                return `Desde os tempos mais remotos, a humanidade tem sido fascinada por mist√©rios que desafiam a l√≥gica e a compreens√£o. Hist√≥rias de artefatos perdidos, segredos antigos e poderes divinos permeiam nossas culturas. Mas poucos objetos hist√≥ricos carregam tanto peso, tanto poder e tanto segredo quanto a lend√°ria Arca da Alian√ßa. Onde ela est√°? Foi realmente encontrada? E o que aconteceria se seus segredos fossem revelados ao mundo? Prepare-se para uma jornada que transcende o tempo, a f√© e a pr√≥pria ci√™ncia. A Arca da Alian√ßa: Onde est√° AGORA?`;
            } else if (prompt.includes("Desenvolvimento")) {
                return `A Arca da Alian√ßa, descrita em detalhes no livro do √äxodo, n√£o era apenas um ba√∫ sagrado. Era o trono de Deus na Terra, contendo as t√°buas dos Dez Mandamentos, o cajado de Ar√£o que floresceu e um pote de man√°. Sua presen√ßa garantia vit√≥ria em batalhas e prosperidade, mas sua profana√ß√£o trazia desastre. Reis e ex√©rcitos tremiam diante de seu poder. Mas, em algum momento da hist√≥ria, a Arca desapareceu. Historiadores e arque√≥logos debatem seu destino: foi destru√≠da? Escondida? Ou levada para um novo lar secreto? A teoria mais proeminente sugere que a Arca foi levada para a Eti√≥pia, para a Igreja de Santa Maria de Si√£o, em Axum. Diz-se que ela est√° guardada por um monge que dedica sua vida a proteg√™-la, sendo o √∫nico que pode v√™-la. Essa narrativa, embora fascinante, √© cercada de ceticismo. N√£o h√° provas concretas que a confirmem, e a igreja et√≠ope pro√≠be qualquer tipo de verifica√ß√£o externa.`;
            } else if (prompt.includes("Cl√≠max")) {
                return `A busca pela Arca da Alian√ßa √© uma jornada de f√© e de ci√™ncia, de lendas e de fatos. Enquanto a Eti√≥pia mant√©m sua reivindica√ß√£o, outros pesquisadores apontam para locais como o Monte Nebo, na Jord√¢nia, ou at√© mesmo sob o Monte do Templo, em Jerusal√©m. Cada teoria, por mais improv√°vel que pare√ßa, alimenta a chama da esperan√ßa e da curiosidade. O que √© certo √© que o impacto da Arca na hist√≥ria e na f√© √© ineg√°vel. Sua aus√™ncia, por si s√≥, √© um mist√©rio que continua a nos desafiar, a nos fazer questionar e a nos inspirar a buscar respostas.`;
            } else if (prompt.includes("Conclus√£o")) {
                return `A Arca da Alian√ßa permanece um dos maiores enigmas da humanidade. Seja ela um artefato f√≠sico esperando para ser redescoberto, ou um s√≠mbolo poderoso da alian√ßa divina e da f√© inabal√°vel, sua hist√≥ria continua a ressoar atrav√©s dos s√©culos. O verdadeiro tesouro, talvez, n√£o esteja na posse de um objeto, mas na jornada de compreens√£o e na busca incessante pela verdade que a Arca inspira em cada um de n√≥s.`;
            } else if (prompt.includes("Chamada para A√ß√£o")) {
                return `E voc√™, o que pensa sobre o paradeiro da Arca da Alian√ßa? Compartilhe sua teoria nos coment√°rios abaixo! Se voc√™ gostou deste mergulho profundo na hist√≥ria e nos mist√©rios, n√£o se esque√ßa de deixar seu like, se inscrever no canal e ativar o sininho para n√£o perder os pr√≥ximos v√≠deos. At√© a pr√≥xima jornada!`;
            } else if (prompt.includes("P√∫blico-Alvo")) {
                return `{
                  "target_audience": "Pessoas Interessadas em Arqueologia B√≠blica e Hist√≥ria Antiga, Crist√£os e Pessoas de F√©, Entusiastas de Ci√™ncia e Ceticismo (com mente aberta), Curiosos em Geral e Amantes de Mist√©rios.",
                  "language_style": "inspirador",
                  "video_objective": "informar",
                  "narrative_goal": "storytelling",
                  "narrative_structure": "mystery_loop",
                  "central_question": "A Arca da Alian√ßa foi realmente encontrada? O que aconteceria se seus segredos fossem revelados ao mundo?",
                  "emotional_arc": "Come√ßar com curiosidade, construir para admira√ß√£o e suspense, e terminar com inspira√ß√£o e reflex√£o."
                }`;
            }

            return "Conte√∫do gerado pela IA (simulado).";
        };
>>>>>>> a15c69ad49be1cf4ec572c5bb85e7dc39da27bc5
