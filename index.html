<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros Virais v2.0 - O Painel do Projeto</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF para gera√ß√£o de PDF (ainda inclu√≠do, mas n√£o usado para download principal) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Fontes Google - Carlito para legibilidade -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Carlito:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üöÄ</text></svg>">
    <style>
        /* ========================================================== */
        /* ==================== ESTILOS GERAIS ==================== */
        /* ========================================================== */
        /* Vari√°veis CSS para cores consistentes e f√°cil manuten√ß√£o */
        :root {
            --primary-color: #4f46e5; /* Indigo-600 */
            --primary-hover: #4338ca; /* Indigo-700 */
            --secondary-bg: #e0e7ff; /* Indigo-100 */
            --secondary-text: #4338ca; /* Indigo-700 */
            --secondary-hover: #c7d2fe; /* Indigo-200 */
            --success-color: #10B981; /* Green-500 */
            --success-hover: #059669; /* Green-600 */
            --text-dark: #1f2937; /* Gray-800 */
            --text-medium: #4b5563; /* Gray-600 */
            --text-light: #6b7280; /* Gray-500 */
            --bg-light: #f9fafb; /* Gray-50 */
            --border-light: #e5e7eb; /* Gray-200 */
        }

        body {
            font-family: 'Carlito', sans-serif;
            background-color: #f0f2f5;
            color: var(--text-dark); /* Cor do texto padr√£o */
        }
        .container {
            max-width: 1024px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
        }
        .input-group label {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.5rem;
            display: block;
        }
        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1.5px solid var(--border-light);
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            background-color: var(--bg-light); /* Garante fundo claro */
            color: var(--text-dark); /* Garante texto escuro */
            border-color: var(--border-light); /* Garante borda clara */
        }
        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
            background-color: #ffffff;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: inline-flex; /* Para alinhar texto e spinner/√≠cone */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: none;
            white-space: nowrap; /* Evita que o texto do bot√£o quebre linha */
        }
        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-primary {
            background-color: var(--primary-color);
            color: #ffffff;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }
        .btn-secondary {
            background-color: var(--secondary-bg);
            color: var(--secondary-text);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--secondary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.15);
        }
        .btn-success {
            background-color: var(--success-color) !important; /* !important para sobrescrever */
            color: #ffffff !important;
        }
        .btn-success:hover:not(:disabled) {
            background-color: var(--success-hover) !important;
        }

        /* Loading Spinner */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        .btn-secondary .loading-spinner {
            border: 4px solid rgba(67, 56, 202, 0.2);
            border-left-color: var(--secondary-text);
        }
        .loading-spinner.hidden { display: none; }
        .button-text.hidden { display: none; }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Icone de Conclus√£o */
        /* REMOVIDO: .completion-icon { ... } */
        /* REMOVIDO: .completion-icon.hidden { display: none; } */

        /* ========================================================== */
        /* ==================== UI MELHORADA ====================== */
        /* ========================================================== */
        .accordion-item {
            border: 1px solid var(--border-light);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden; /* Garante que o conte√∫do escondido n√£o vaze */
            background-color: var(--bg-light);
        }
        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            cursor: pointer;
            user-select: none; /* Impede sele√ß√£o de texto ao clicar */
        }
        /* Estilo para o cabe√ßalho do acorde√£o ativo */
        .accordion-header.active {
            background-color: var(--secondary-bg);
        }
        .dark .accordion-header.active {
            background-color: #374151; /* Gray-700 */
        }
        .header-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .header-buttons {
            display: flex;
            gap: 0.5rem; /* Espa√ßamento entre os bot√µes de a√ß√£o */
        }
        .accordion-header h3 {
            margin-bottom: 0; /* Remove a margem padr√£o do h3 */
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-dark);
        }
        .accordion-arrow {
            transition: transform 0.3s ease-in-out;
        }
        .accordion-arrow.open {
            transform: rotate(180deg);
        }
        .accordion-body {
            max-height: 0; /* Escondido por padr√£o */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
            padding: 0 1.5rem; /* Padding vertical zero quando fechado */
        }
        .accordion-body.open {
            max-height: 5000px; /* Valor grande para "abrir" */
            padding: 1rem 1.5rem 1.5rem; /* Padding quando aberto */
        }
        .accordion-body .generated-content-wrapper[contenteditable="true"] {
            outline: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: box-shadow 0.2s, background-color 0.2s;
        }
        .accordion-body .generated-content-wrapper[contenteditable="true"]:focus {
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
            background-color: #eef2ff; /* Fundo levemente azulado ao editar */
        }

        /* Bot√µes de Copiar e Re-gerar dentro das se√ß√µes */
        .copy-btn, .regenerate-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            white-space: nowrap;
        }
        .copy-btn {
            background-color: var(--primary-color);
            color: #ffffff;
        }
        .copy-btn:hover {
            background-color: var(--primary-hover);
        }
        .regenerate-btn {
            background-color: var(--secondary-bg);
            color: var(--secondary-text);
        }
        .regenerate-btn:hover {
            background-color: var(--secondary-hover);
        }
        
        /* Se√ß√µes de Prompts e Trilha Sonora */
        .section-prompts, .section-soundtrack {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #d1d5db;
        }
        .btn-small {
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
        }
        .loading-spinner-small {
            border: 3px solid rgba(67, 56, 202, 0.2);
            border-left-color: var(--secondary-text);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }
        .individual-prompt-block {
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .prompt-time {
            font-size: 0.75rem;
            color: var(--primary-color);
            font-weight: 700;
        }
        .prompt-phrase {
            font-size: 0.875rem;
            color: var(--text-dark);
            font-weight: 700;
            line-height: 1.4;
        }
        .prompt-description-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-medium);
            margin-top: 0.5rem;
            border-top: 1px dashed var(--border-light);
            padding-top: 0.5rem;
        }
        .prompt-description-content {
            font-size: 0.9rem;
            color: var(--text-dark);
            line-height: 1.5;
        }
        pre {
            background-color: var(--bg-light);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-medium);
            overflow-x: auto; /* Para lidar com blocos de estilo longos */
            white-space: pre-wrap; /* Quebra linhas longas */
            word-break: break-all; /* Quebra palavras longas */
        }
        .soundtrack-list {
            list-style-type: disc;
            padding-left: 20px;
            font-size: 0.9rem;
            color: var(--text-dark);
        }
        .soundtrack-list li { margin-bottom: 0.5rem; }

        /* Separador para Thumbnails */
        .thumbnail-item-separator {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-light);
        }

        /* Toast Notification */
        #toastNotification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7); color: #fff; padding: 10px 20px;
            border-radius: 8px; font-size: 0.9rem; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1001; white-space: nowrap;
        }
        #toastNotification.toast-visible { opacity: 1; visibility: visible; }

        /* Alerta Full-Screen */
        #fullScreenAlertOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center;
            align-items: center; z-index: 1000; visibility: hidden; opacity: 0;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #fullScreenAlertOverlay.visible { visibility: visible; opacity: 1; }
        #fullScreenAlertBox {
            background-color: #ffffff; padding: 2.5rem; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); text-align: center; max-width: 500px;
            width: 90%; position: relative; transform: translateY(-20px);
            transition: transform 0.3s ease-out;
        }
        #fullScreenAlertOverlay.visible #fullScreenAlertBox { transform: translateY(0); }
        #fullScreenAlertBox p { font-size: 1.1rem; color: var(--text-dark); margin-bottom: 1.5rem; line-height: 1.6; }
        #fullScreenAlertBox button {
            background-color: var(--primary-color); color: #ffffff; padding: 0.75rem 1.5rem;
            border-radius: 8px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; border: none;
        }
        #fullScreenAlertBox button:hover { background-color: var(--primary-hover); }

        /* ========================================================== */
        /* ================= BARRA FLUTUANTE ====================== */
        /* ========================================================== */
        .floating-action-bar {
            position: fixed; top: 0; left: 0; width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 999; padding: 0.75rem 0;
            transform: translateY(-100%); opacity: 0; visibility: hidden;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .floating-action-bar.visible { transform: translateY(0); opacity: 1; visibility: visible; }
        .action-bar-content {
            max-width: 1024px; margin: 0 auto; padding: 0 2rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .action-bar-buttons-group {
            display: flex; align-items: center; gap: 0.75rem;
            width: 100%; /* Garante que o grupo ocupe o espa√ßo */
        }
        .action-bar-buttons-group.hidden { display: none; }
        .action-bar-buttons-group .action-bar-title {
            white-space: nowrap; /* Impede que o t√≠tulo quebre linha */
            font-weight: 600;
            color: var(--text-dark);
        }
        .action-bar-buttons-group .btn-container {
            display: flex; gap: 0.75rem; justify-content: flex-end; width: 100%;
        }
        .btn-container .btn {
            padding: 0.5rem 1rem; /* Um pouco menores */
            font-size: 0.875rem;
        }
        /* Corre√ß√£o para o espa√ßamento dos bot√µes clonados */
        .action-bar-buttons-group .btn-container .btn { margin-left: 0.75rem; }
        .action-bar-buttons-group .btn-container .btn:first-child { margin-left: 0; }

        /* ========================================================== */
        /* ======== ESTILOS PARA A BARRA DE PROGRESO ========= */
        /* ========================================================== */
        #progressBar {
            transition: width 0.5s ease-in-out; /* Anima√ß√£o suave do crescimento da barra */
            background-color: var(--success-color); /* Usa a nossa cor de sucesso verde! */
        }

        /* ========================================================== */
        /* ===== CORRE√á√ÉO DE COR DE TEXTO PARA MODO CLARO ===== */
        /* ========================================================== */
        /* REMOVIDO: body:not(.dark) #titlesThumbnailsSection .p-3 p { color: #374151; } */
        /* REMOVIDO: body:not(.dark) #titlesThumbnailsSection .font-semibold { color: #1f2937; } */

        /* ========================================================== */
        /* ==================== MODO ESCURO ======================= */
        /* ========================================================== */
        body.dark {
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        .dark .container, .dark .accordion-item {
            background-color: #1f2937; /* gray-800 */
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }
        .dark .accordion-item { border-color: #4b5563; }
        .dark .floating-action-bar { background-color: rgba(31, 41, 55, 0.9); }
        .dark .action-bar-title, .dark h3, .dark h4, .dark label, .dark p { color: #f3f4f6; }
        .dark .text-gray-500 { color: #9ca3af; }
        .dark .input-group label { color: #d1d5db; }
        .dark .input-group input,
        .dark .input-group select,
        .dark .input-group textarea {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
            color: #f9fafb; /* gray-50 */
        }
        .dark .input-group input:focus,
        .dark .input-group select:focus,
        .dark .input-group textarea:focus {
            border-color: #6366f1; /* indigo-500 */
            background-color: #4b5563; /* gray-600 */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        .dark .bg-indigo-50 { background-color: #374151 !important; }
        .dark .border-indigo-200 { border-color: #4b5563 !important; }
        .dark .text-indigo-800 { color: #a5b4fc !important; }
        .dark .bg-gray-50 { background-color: #374151 !important; }
        .dark .border-gray-200 { border-color: #4b5563 !important; }
        .dark .accordion-body .generated-content-wrapper[contenteditable="true"]:focus {
            background-color: #4b5563;
        }
        .dark .individual-prompt-block {
            background-color: #1f2937;
            border-color: #374151;
        }
        .dark .prompt-phrase { color: #f3f4f6; }
        .dark .prompt-description-label { color: #9ca3af; }
        .dark .prompt-description-content { color: #d1d5db; }
        .dark pre { background-color: #374151 !important; color: #d1d5db; }
        .dark #darkModeToggle { color: #9ca3af; }
        /* ========================================================== */
        /* ==================== ESTILOS TOOLTIP ===================== */
        /* ========================================================== */
        .tooltip {
            position: relative;
            cursor: help;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #e0e7ff; /* Indigo-100 */
            color: #4338ca; /* Indigo-700 */
            font-weight: bold;
            font-size: 0.8rem;
            border: 1px solid #c7d2fe;
        }
        .dark .tooltip {
            background-color: #4b5563; /* Gray-600 */
            color: #e5e7eb; /* Gray-200 */
            border-color: #374151; /* Gray-700 */
        }
        /* Esconde o tooltip por padr√£o */
        .tooltip::before, .tooltip::after {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            position: absolute;
            bottom: 150%; /* Posiciona acima do (?) */
            left: 50%;
            transform: translateX(-50%) translateY(10px); /* Come√ßa um pouco abaixo */
            z-index: 10;
        }
        /* Mostra o tooltip no hover */
        .tooltip:hover::before, .tooltip:hover::after {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0); /* Sube para a posi√ß√£o final */
        }
        /* Estilo da caixa de texto do tooltip */
        .tooltip::before {
            content: attr(data-tooltip); /* Pega o texto do atributo! */
            background-color: #1f2937; /* Gray-800 */
            color: #f9fafb; /* Gray-50 */
            padding: 0.75rem;
            border-radius: 8px;
            width: 300px; /* Largura do tooltip */
            text-align: left;
            white-space: pre-wrap; /* Respeita as quebras de linha do atributo */
            font-size: 0.85rem;
            line-height: 1.5;
            font-weight: normal;
        }
        .dark .tooltip::before {
            background-color: #374151; /* Gray-700 */
        }
        /* Estilo da setinha do tooltip */
        .tooltip::after {
            content: '';
            border-width: 6px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent; /* Seta aponta para baixo */
            margin-left: -6px; /* Centraliza a seta */
        }
        .dark .tooltip::after {
            border-color: #374151 transparent transparent transparent;
        }
        .dark .section-prompts, .dark .section-soundtrack { border-top-color: #4b5563; }
        .dark .soundtrack-list { color: #d1d5db; }

        /* Anima√ß√£o para surgimento suave das se√ß√µes */
        @keyframes fadeInSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .animate-fade-in {
            animation: fadeInSlideUp 0.5s ease-out forwards;
        }

        /* ========================================================== */
        /* =================== ESTILOS MODO FOCO ==================== */
        /* ========================================================== */
        /* Quando o modo foco est√° ativo, esconde esses elementos espec√≠ficos */
        body.zen-mode .floating-action-bar,
        body.zen-mode .container > h1,
        body.zen-mode .container > p,
        body.zen-mode #mainInputsGrid, /* Esconde a √°rea de inputs pelo seu ID */
        body.zen-mode #progressBarContainer,
        body.zen-mode #assetsColumn, /* Esconde a coluna de recursos inteira */
        body.zen-mode #strategicOutlineCard, /* Esconde o card do esbo√ßo */
        body.zen-mode #scriptGenerationControls { /* Esconde os controles de gera√ß√£o */
            display: none !important;
        }

        /* Ajusta o layout do container e da coluna do roteiro */
        body.zen-mode .container {
            max-width: 800px; /* Largura de leitura confort√°vel */
            padding-top: 2rem;
            padding-bottom: 2rem;
            box-shadow: none !important;
            background-color: transparent !important;
        }

        body.zen-mode #scriptColumn {
            max-height: none; /* Remove a altura m√°xima para ocupar a tela toda */
            grid-column: span 12 / span 12; /* Faz a coluna do roteiro ocupar 100% da largura */
        }

        /* Ajuste final para o Modo Foco */
        body.zen-mode {
            background-color: #ffffff !important; /* For√ßa o fundo a ser branco */
        }
        .dark body.zen-mode {
            background-color: #f9fafb !important; /* Um branco levemente acinzentado para o modo escuro */
        }
        /* Faz o texto no modo foco ser sempre preto, para contraste */
        body.zen-mode .dark .accordion-header h3,
        body.zen-mode .dark .generated-content-wrapper {
            color: var(--text-dark) !important;
        }
        
        /* ========================================================== */
        /* Estilos para a coluna de roteiro com controles fixos */
        /* ========================================================== */
        #scriptColumn {
            /* Define uma altura m√°xima para a coluna, para que a rolagem interna funcione */
            /* 'vh' √© a altura da viewport (tela vis√≠vel) */
            max-height: 90vh; 
        }
        #scriptSectionsContainer {
            /* Permite que este cont√™iner de acorde√µes ocupe todo o espa√ßo dispon√≠vel e role */
            flex-grow: 1;
            overflow-y: auto;
        }
        #scriptGenerationControls {
            /* Garante que os controles fiquem "colados" na parte inferior da coluna */
            position: sticky;
            bottom: 0;
            /* Fundo com transpar√™ncia para um efeito mais elegante ao rolar */
            background-color: rgba(238, 242, 255, 0.95); /* Indigo-50 com transpar√™ncia */
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 10; /* Garante que fique acima do conte√∫do que rola */
        }
        .dark #scriptGenerationControls {
            background-color: rgba(31, 41, 55, 0.95); /* Gray-800 com transpar√™ncia */
        }

        /* ========================================================== */
        /* =============== ESTILOS DE IMPRESS√ÉO (PDF) =============== */
        /* ========================================================== */
        @media print {
            /* Esconde tudo por padr√£o */
            body * {
                visibility: hidden;
            }

            /* Torna a √°rea de conte√∫do do roteiro e seus filhos vis√≠veis */
            #scriptColumn, #scriptColumn * {
                visibility: visible;
            }
            
            /* Garante que o conte√∫do ocupe toda a √°rea de impress√£o */
            #scriptColumn {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                padding: 2cm; /* Margens de um documento profissional */
                font-size: 12pt;
                line-height: 1.5;
            }
            
            /* Remove elementos desnecess√°rios da impress√£o */
            #scriptColumn h2, 
            #scriptColumn #strategicOutlineCard, 
            #scriptColumn #scriptGenerationControls,
            .accordion-header .header-buttons,
            .accordion-body .section-prompts,
            .accordion-body .section-soundtrack {
                display: none;
            }
            
            /* For√ßa os acorde√µes a ficarem abertos e sem bordas */
            .accordion-item, .accordion-header {
                border: none !important;
                box-shadow: none !important;
            }
            .accordion-body {
                max-height: none !important; /* Mostra todo o conte√∫do */
                padding: 0 !important;
                margin-bottom: 2rem; /* Espa√ßamento entre se√ß√µes */
            }
            .accordion-header h3 {
                font-size: 16pt;
                margin-bottom: 0.5rem;
            }
            .accordion-arrow {
                display: none;
            }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900">
    <!-- ========================================================== -->
    <!-- ===== BARRA FLUTUANTE COM BOT√ïES INDEPENDENTES ===== -->
    <!-- ========================================================== -->
    <div id="floatingActionBar" class="floating-action-bar">
        <div class="action-bar-content">
            <!-- Grupo de A√ß√µes Principais -->
            <div id="mainActions" class="action-bar-buttons-group">
                <span class="action-bar-title">Passo 1:</span>
                <div class="btn-container">
                    <button id="float_generateIntroBtn" class="btn btn-primary">Introdu√ß√£o</button>
                    <button id="float_generateDevelopmentBtn" class="btn btn-primary">Desenvolvimento</button>
                    <button id="float_climaxBtn" class="btn btn-primary">Cl√≠max</button>
                    <button id="float_conclusionBtn" class="btn btn-primary">Conclus√£o</button>
                    <button id="float_generateCTABtn" class="btn btn-primary">CTA</button>
                </div>
            </div>
            <!-- Grupo de A√ß√µes R√°pidas -->
            <div id="quickActions" class="action-bar-buttons-group hidden">
                <span class="action-bar-title">A√ß√µes R√°pidas:</span>
                 <div class="btn-container">
                    <button id="float_generateDescriptionBtn" class="btn btn-secondary">Descri√ß√£o</button>
                    <button id="float_generateTitlesAndThumbnailsBtn" class="btn btn-secondary">T√≠tulos</button>
                    <button id="float_downloadPdfBtn" class="btn btn-secondary">PDF</button>
                    <button id="float_resetScriptBtn" class="btn btn-secondary">Novo</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container relative">
        <div class="absolute top-4 right-4 flex items-center gap-2 z-[1001]">
            <button id="toggleZenModeBtn" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-gray-500 dark:text-gray-400" title="Modo Foco">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>
            </button>
            <button id="darkModeToggle" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-gray-500 dark:text-gray-400" title="Modo Escuro">
                <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m8.66-14.66l-.707.707M4.04 19.96l-.707.707M21 12h-1M4 12H3m16.66-7.96l-.707-.707M4.04 4.04l-.707-.707m11.314 0l-1.414 1.414M5.464 18.536l-1.414 1.414m12.728-1.414l-1.414-1.414m-9.9-9.9l-1.414-1.414M12 6a6 6 0 100 12 6 6 0 000-12z" /></svg>
            </button>
        </div>
        
        <h1 class="text-4xl font-extrabold text-center text-gray-800 dark:text-gray-100 mb-2">Gerador de Roteiros Virais v2.0</h1>
        <p class="text-center text-gray-500 dark:text-gray-400 mb-8">O seu painel de controle para conte√∫do de alto impacto.</p>
        
        <!-- Se√ß√£o de Inputs da Aplica√ß√£o -->
        <div id="mainInputsGrid" class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="input-group">
                <label for="channelName">Nome do Canal:</label>
                <input type="text" id="channelName" placeholder="Ex: The Biblical Unveiling" value="The Biblical Unveiling">
            </div>
            <div class="input-group">
                <label for="videoTheme">Tema do V√≠deo:</label>
                <input type="text" id="videoTheme" placeholder="Ex: A Arca da Alian√ßa Foi Encontrada?">
            </div>
             <div class="input-group md:col-span-2">
                <label for="videoDescription">Descri√ß√£o do V√≠deo (para inspira√ß√£o):</label>
                <textarea id="videoDescription" rows="4" placeholder="Cole uma breve descri√ß√£o do v√≠deo aqui para que a IA possa usar como inspira√ß√£o para o roteiro."></textarea>
            </div>

            <!-- Bot√£o de Estrat√©gia Autom√°tica com IA -->
            <div class="md:col-span-2 my-4 flex justify-center">
                <button id="analyzeStrategyBtn" class="btn btn-primary w-full md:w-1/2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M9.5 2.672a.5.5 0 1 0 1 0V.843a.5.5 0 0 0-1 0v1.829Zm4.5.035A.5.5 0 0 0 13.293 2L12 3.293a.5.5 0 1 0 .707.707L14 2.707a.5.5 0 0 0 0-.707ZM7.293 4A.5.5 0 1 0 8 3.293L6.707 2A.5.5 0 0 0 6 2.707L7.293 4Zm-.621 2.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L7.38 6.207a.5.5 0 0 0-.707 0ZM5.5 7a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Zm-1.829-1.5a.5.5 0 0 0-.707 0L2 6.793a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L3.707 7.5H3.5a.5.5 0 0 0 0-1h.207L2.707 5.5Zm-1 .707a.5.5 0 0 0-.707-.707L.707 6.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L1.293 7.5H1.5a.5.5 0 0 0 0-1h-.207L2.293 6.207Z"/><path d="M12.026 8.5H11a.5.5 0 0 0 0 1h1.026a.5.5 0 0 0 0-1Zm-1.633.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293Zm-3.134 3.367a.5.5 0 1 0-.707.707l1.293 1.293a.5.5 0 0 0 .707-.707l-1.293-1.293Zm1.633-.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293A.5.5 0 0 1 8.89 11.86Z"/></svg>
                    <span class="button-text">Definir Estrat√©gia com IA</span>
                    <div class="loading-spinner hidden"></div>
                </button>
            </div>
            
            <!-- Campos de Estrat√©gia Preenchidos pela IA -->
            <div class="input-group md:col-span-2">
                <label for="targetAudience">P√∫blico-Alvo:</label>
                <input type="text" id="targetAudience" value="Pessoas Interessadas em Arqueologia B√≠blica e Hist√≥ria Antiga, Crist√£os e Pessoas de F√©, Entusiastas de Ci√™ncia e Ceticismo (com mente aberta), Curiosos em Geral e Amantes de Mist√©rios." readonly>
            </div>
            <div class="input-group">
                <label for="languageSelect">Idioma do Roteiro:</label>
                <select id="languageSelect">
                    <option value="pt-br">Portugu√™s (Brasil)</option>
                    <option value="pt-pt">Portugu√™s (Portugal)</option>
                    <option value="en" selected>English</option>
                    <option value="es">Espa√±√£o</option>
                </select>
            </div>
            <div class="input-group">
                <label for="languageStyle">Estilo de Linguagem:</label>
                <select id="languageStyle">
                    <option value="formal">Formal</option>
                    <option value="informal">Informar</option>
                    <option value="emocional">Emocional</option>
                    <option value="tecnico">T√©cnico</option>
                    <option value="inspirador" selected>Inspirador</option>
                    <option value="humoristico">Humor√≠stico</option>
                </select>
            </div>
            <div class="input-group md:col-span-2">
                <label for="videoObjective">Objetivo do V√≠deo:</label>
                <select id="videoObjective">
                    <option value="informar" selected>Informar</option>
                    <option value="emocionar">Emocionar</option>
                    <option value="evangelizar">Evangelizar (criar defensores)</option>
                    <option value="vender">Vender</option>
                    <option value="entreter">Entreter</option>
                </select>
            </div>
            <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                <div class="input-group">
                    <label for="videoDuration">Dura√ß√£o Desejada:</label>
                    <select id="videoDuration">
                        <option value="">-- Selecione a Dura√ß√£o --</option>
                        <option value="short">Curto (~1-3 min)</option>
                        <option value="medium">M√©dio (~4-7 min)</option>
                        <option value="long">Longo (~8-12 min)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="speakingPace">Ritmo de Fala:</label>
                    <select id="speakingPace">
                        <option value="moderate" selected>Moderado</option>
                        <option value="slow">Lento</option> <!-- CORRIGIDO AQUI -->
                        <option value="fast">R√°pido</option>
                    </select>
                </div>
            </div>
            <div class="input-group md:col-span-2">
                <div class="flex items-center gap-2">
                    <label for="narrativeStyle">Estilo da Narrativa:</label>
                    <span class="tooltip"
                        data-tooltip="Direto e Informativo: Estrutura cl√°ssica de come√ßo, meio e fim. Ideal para document√°rios.&#10;&#10;Jornada do Her√≥i: Conta uma hist√≥ria de transforma√ß√£o e supera√ß√£o. √ìtimo para narrativas inspiradoras.&#10;&#10;Mist√©rio (Loop Aberto): Apresenta uma pergunta no in√≠cio e a responde no final. Excelente para reter a aten√ß√£o.&#10;&#10;Problema-Agita√ß√£o-Solu√ß√£o (PAS): Foca em um problema que o p√∫blico tem e apresenta a solu√ß√£o. Perfeito para v√≠deos de marketing e tutoriais.&#10;&#10;Antes-Depois-Ponte (BAB): Mostra um cen√°rio 'antes' (o problema), um 'depois' (o resultado ideal) e seu conte√∫do como 'a ponte' para chegar l√°.&#10;&#10;Narrativa com Virada (Twist): Constr√≥i uma expectativa e a quebra com uma revela√ß√£o surpreendente no final."
                    >
                        (?)
                    </span>
                </div>
                <select id="narrativeStyle">
                    <option value="direct" selected>Direto e Informativo (Padr√£o)</option>
                    <option value="heros_journey">Jornada do Her√≥i (Cl√°ssico)</option>
                    <option value="mystery_loop">Mist√©rio (com Loop Aberto)</option>
                    <option value="pas">Problema-Agita√ß√£o-Solu√ß√£o (PAS)</option>
                    <option value="before_after_bridge">Antes-Depois-Ponte (BAB)</option>
                    <option value="twist">Narrativa com Virada (Twist)</option>
                </select>
            </div>
            <div class="input-group md:col-span-2">
                <label for="centralQuestion">Pergunta Central (Opcional):</label>
                <textarea id="centralQuestion" rows="2" placeholder="Ex: A Arca da Alian√ßa Foi Encontrada?"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="emotionalArc">Arco Emocional Desejado (Opcional):</label>
                <textarea id="emotionalArc" rows="2" placeholder="Ex: Come√ßar com curiosidade, construir para admira√ß√£o, e terminar com inspira√ß√£o."></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="viralElements">Elementos Virais/Tend√™ncias (Opcional):</label>
                <textarea id="viralElements" rows="2" placeholder="Insira memes, frases, tend√™ncias ou palavras-chave em alta. Ex: 'o hype √© real', 'chocado', 'plot twist'"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="imageDescriptionEngine">Motor de Descri√ß√£o de Imagem:</label>
                <textarea id="imageDescriptionEngine" rows="2" placeholder="Ex: 'alta resolu√ß√£o', 'detalhado', 'fotorrealista', 'cores vibrantes'"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="imageStyleSelect">Motor de Qualidade de Imagem:</label>
                <select id="imageStyleSelect">
                    <option value="cinematic" selected>Cinematogr√°fico</option>
                    <option value="custom">Personalizado</option>
                    <option value="none">Nenhum</option>
                </select>
            </div>
            <div class="input-group md:col-span-2" id="customImageStyleContainer" style="display: none;">
                <label for="customImageStyle">Estilo Visual Personalizado:</label>
                <textarea id="customImageStyle" rows="5" placeholder="Cole aqui o seu bloco de estilo personalizado (ex: para cartoon, anime, etc.)."></textarea>
            </div>
        </div>

        <!-- ========================================================== -->
        <!-- ========= NOVA BARRA DE PROGRESO VISUAL ============= -->
        <!-- ========================================================== -->
        <div id="progressBarContainer" class="progress-bar-container mb-8">
            <div class="flex justify-between mb-1">
                <span class="text-base font-medium text-gray-700 dark:text-gray-300">Progresso do Projeto</span>
                <span id="progressText" class="text-sm font-medium text-gray-700 dark:text-gray-300">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>
        <!-- ========================================================== -->
       
        <!-- ========================================================== -->
        <!-- ===== NOVA √ÅREA DE SA√çDA: O PAINEL DO PROJETO ======== -->
        <!-- ========================================================== -->
        <div id="projectDashboard" class="hidden mt-12">
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
                
                <!-- Coluna Principal: Roteiro -->
                <div id="scriptColumn" class="lg:col-span-7 flex flex-col gap-4">
                    <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-200 border-b-2 border-indigo-200 dark:border-indigo-800 pb-2">Roteiro Principal</h2>

                    <!-- Cart√£o do Esbo√ßo Estrat√©gico (permanece no topo) -->
                    <div id="strategicOutlineCard" class="p-4 bg-white dark:bg-gray-800 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200">Esbo√ßo Estrat√©gico</h3>
                            <button id="generateOutlineBtn" class="btn btn-secondary btn-small">Criar Esbo√ßo</button>
                        </div>
                        <div id="outlineContent">
                             <div class="asset-card-placeholder text-sm">Clique em 'Criar Esbo√ßo' para a IA planejar a estrutura do roteiro.</div>
                        </div>
                    </div>

                    <!-- Novo Cont√™iner para os Acorde√µes que vai rolar -->
                    <div id="scriptSectionsContainer" class="flex-grow space-y-4 overflow-y-auto">
                        <div id="introSection" class="script-section"></div>
                        <div id="developmentSection" class="script-section"></div>
                        <div id="climaxSection" class="script-section"></div>
                        <div id="conclusionSection" class="script-section"></div>
                        <div id="ctaSection" class="script-section"></div>
                    </div>
                    
                    <!-- Controles de Gera√ß√£o, agora fixos no final da coluna -->
                    <div id="scriptGenerationControls" class="p-4 bg-indigo-50 dark:bg-gray-800 border-t-2 border-indigo-200 dark:border-gray-700 rounded-b-lg sticky bottom-0">
                        <h3 class="font-bold text-lg text-indigo-800 dark:text-indigo-300 mb-3 text-center">Gerar Se√ß√µes do Roteiro</h3>
                        <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                            <button id="generateIntroBtn" class="btn btn-primary btn-small">Introdu√ß√£o</button>
                            <button id="generateDevelopmentBtn" class="btn btn-primary btn-small">Desenvolvimento</button>
                            <button id="climaxBtn" class="btn btn-primary btn-small">Cl√≠max</button>
                            <button id="conclusionBtn" class="btn btn-primary btn-small">Conclus√£o</button>
                            <button id="generateCTABtn" class="btn btn-primary btn-small">CTA</button>
                        </div>
                    </div>
                </div>

                <!-- Coluna Lateral: Recursos e Metadados -->
                <div id="assetsColumn" class="lg:col-span-5 space-y-6">
                    <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-200 border-b-2 border-indigo-200 dark:border-indigo-800 pb-2">Recursos</h2>
                    
                    <!-- Cart√£o: Descri√ß√£o e Hashtags (AGORA PRIMEIRO) -->
                    <div class="p-4 bg-white dark:bg-gray-800 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200">Descri√ß√£o & Hashtags</h3>
                            <button id="generateDescriptionBtn" class="btn btn-secondary btn-small">Gerar</button>
                        </div>
                        <div id="videoDescriptionContent">
                             <div class="asset-card-placeholder">Clique em 'Gerar' para ver a descri√ß√£o</div>
                        </div>
                    </div>

                    <!-- Cart√£o: T√≠tulos e Thumbnails (AGORA EM SEGUNDO) -->
                    <div class="p-4 bg-white dark:bg-gray-800 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200">T√≠tulos & Thumbnails</h3>
                            <button id="generateTitlesAndThumbnailsBtn" class="btn btn-secondary btn-small">Gerar</button>
                        </div>
                        <div id="titlesThumbnailsContent">
                             <div class="asset-card-placeholder">Clique em 'Gerar' para ver as sugest√µes</div>
                        </div>
                    </div>

                    <!-- Cart√£o: Storyboard Visual (REMOVIDO) -->
                    <div id="storyboardContent" style="display: none;"></div>
                    
                    <!-- Cart√£o: Salvar e Exportar -->
                    <div class="p-4 bg-white dark:bg-gray-800 rounded-lg shadow-md">
                         <h3 class="font-bold text-lg text-gray-800 dark:text-gray-200 mb-3">Finalizar Projeto</h3>
                         <div class="grid grid-cols-2 gap-3">
                            <button id="exportProjectBtn" class="btn btn-secondary">Exportar</button>
                            <button id="importProjectBtn" class="btn btn-secondary">Importar</button>
                            <input type="file" id="importFileInput" class="hidden" accept=".json">
                            <button id="downloadPdfBtn" class="btn btn-secondary">PDF</button>
                            <button id="resetScriptBtn" class="btn btn-secondary">Novo</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Elementos de Feedback (Toast e Alerta) -->
    <div id="toastNotification" class="toast-notification"></div>
    <div id="fullScreenAlertOverlay">
        <div id="fullScreenAlertBox">
            <p id="fullScreenAlertMessage"></p>
            <button id="fullScreenAlertCloseBtn">Entendi</button>
        </div>
    </div>

    <script type="module">
        // ==========================================================
        // ==================== SETUP INICIAL =======================
        // ==========================================================
        // Vari√°veis de estado globais
        let generatedTitlesAndThumbnails = null;
        let allImagePrompts = {}; // Armazena prompts de imagem por se√ß√£o
        let strategicOutline = null; // Vari√°vel para armazenar o esbo√ßo estrat√©gico

        // Bloco de estilo cinematogr√°fico para prompts de imagem
        const CINEMATIC_STYLE_BLOCK = `
**[ESTILO CINEMATOGR√ÅFICO]**
**Style:** Cinematic film still, hyper-realistic, masterful cinematography. Shot on an Arri Alexa 65 with vintage anamorphic lenses. The composition is deliberate and powerful, using principles of photographic storytelling.
**Lighting:** Naturalistic and dramatic lighting. Strong use of light and shadow (chiaroscuro) to create depth and mood. The light source feels authentic to the environment, whether it's harsh sunlight, soft window light, or moody candlelight.
**Details & Textures:** Extreme attention to micro-details. Hyper-realistic textures are paramount: visible skin pores, fabric weaves, material imperfections (scratches on metal, weathering on stone, dust on surfaces). Every element feels tangible and real.
**Color & Mood:** Rich, cinematic color grading. The color palette is carefully controlled to enhance the story and emotion of the scene. The overall mood is immersive, evocative, and deeply atmospheric.
**Negative Prompt:** --no cgi, 3d, render, painting, illustration, animation, video game, digital art, cartoon
`;
        // Labels para descri√ß√£o de imagem em diferentes idiomas
        const imageDescriptionLabels = { 'pt-br': 'Descri√ß√£o da Imagem:', 'pt-pt': 'Descri√ß√£o da Imagem:', 'en': 'Image Description:' };

        // Mapeamento de elementos do DOM para acesso f√°cil
        const elements = {};
        const buttons = {};
        // Mapeia todos os elementos e bot√µes com ID
        document.querySelectorAll('[id]').forEach(el => {
            if (el.tagName === 'BUTTON') {
                buttons[el.id] = el;
            } else {
                elements[el.id] = el;
            }
        });

        // ==========================================================
        // ================== FUN√á√ïES DE UTILIDADE ==================
        // ==========================================================
        /**
         * Exibe uma notifica√ß√£o toast na parte inferior da tela.
         * @param {string} message - A mensagem a ser exibida.
         */
        window.showToast = (message) => {
            elements.toastNotification.textContent = message;
            elements.toastNotification.classList.add('toast-visible');
            setTimeout(() => {
                elements.toastNotification.classList.remove('toast-visible');
                setTimeout(() => { elements.toastNotification.textContent = ''; }, 300);
            }, 3000);
        };

        /**
         * Copia um texto para a √°rea de transfer√™ncia.
         * @param {string} text - O texto a ser copiado.
         */
        window.copyTextToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                window.showToast('Copiado!');
            } catch (err) {
                // Fallback para navegadores mais antigos ou contextos restritos (ex: iframes)
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                try {
                    document.execCommand('copy');
                    window.showToast('Copiado!');
                } finally {
                    document.body.removeChild(ta);
                }
            }
        };

        /**
         * Fornece feedback visual em um bot√£o ap√≥s uma a√ß√£o de c√≥pia.
         * @param {HTMLElement} buttonElement - O elemento do bot√£o que foi clicado.
         */
        window.showCopyFeedback = (buttonElement) => {
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = 'Copiado!';
            buttonElement.classList.add('btn-success');
            buttonElement.disabled = true; // Desabilita o bot√£o temporariamente

            setTimeout(() => {
                buttonElement.innerHTML = originalText;
                buttonElement.classList.remove('btn-success');
                buttonElement.disabled = false;
            }, 2000); // Reverte ap√≥s 2 segundos
        };

        /**
         * Mostra um spinner de carregamento e desabilita todos os bot√µes de gera√ß√£o.
         * @param {HTMLElement} button - O bot√£o que acionou o carregamento.
         */
        const showLoading = (button) => {
            // Desabilitar TODOS os bot√µes de gera√ß√£o para evitar rate limit
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = true; });
        
            const textSpan = button.querySelector('.button-text');
            const spinnerDiv = button.querySelector('.loading-spinner');

            if (textSpan) textSpan.classList.add('hidden');
            if (spinnerDiv) spinnerDiv.classList.remove('hidden');
        };

        /**
         * Esconde o spinner de carregamento e reabilita os bot√µes.
         * @param {HTMLElement} button - O bot√£o que estava em estado de carregamento.
         */
        const hideLoading = (button) => {
            // Habilita TODOS os bot√µes de gera√ß√£o novamente
            Object.values(buttons).forEach(btn => { if(btn) btn.disabled = false; });
            
            const spinnerDiv = button.querySelector('.loading-spinner');
            if (spinnerDiv) spinnerDiv.classList.add('hidden');
            
            const textSpan = button.querySelector('.button-text');
            if (textSpan) textSpan.classList.remove('hidden');

            updateButtonStates(); // Chama a fun√ß√£o centralizada para reavaliar o estado
        };

        /**
         * Marca um bot√£o (original e flutuante) como conclu√≠do (cor verde).
         * @param {string} originalId - O ID do bot√£o original.
         */
        const markButtonAsCompleted = (originalId) => {
            const originalButton = document.getElementById(originalId);
            const floatButton = document.getElementById(`float_${originalId}`);

            [originalButton, floatButton].forEach(btn => {
                if (btn) {
                    btn.classList.remove('btn-primary', 'btn-secondary');
                    btn.classList.add('btn-success');
                }
            });
            updateProgressBar(); // <-- ADICIONADO AQUI
        };

        /**
         * Reseta os √≠cones de conclus√£o de todos os bot√µes (original e flutuante) para suas cores padr√£o.
         */
        const resetCompletionIcons = () => {
            const passo1_buttons_ids = ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'];
            
            for (const buttonId in buttons) { // Iterar sobre todos os bot√µes
                const isPasso1 = passo1_buttons_ids.includes(buttonId);
                const originalButton = document.getElementById(buttonId);
                const floatButton = document.getElementById(`float_${buttonId}`);

                // Remove a classe de sucesso e adiciona a classe correta (primary/secondary)
                [originalButton, floatButton].forEach(btn => {
                    if (btn) {
                        btn.classList.remove('btn-success');
                        if (isPasso1) {
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-primary');
                        } else {
                            btn.classList.remove('btn-primary');
                            btn.classList.add('btn-secondary');
                        }
                    }
                });
            }
        };
        
        /**
         * Verifica se as se√ß√µes principais do roteiro foram geradas.
         * @returns {boolean} True se todas as se√ß√µes principais foram geradas, caso contr√°rio, false.
         */
        const isScriptComplete = () => {
            return ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'].every(id => {
                const section = document.getElementById(id);
                return section && !section.classList.contains('hidden') && section.querySelector('.generated-content-wrapper')?.textContent.trim() !== '';
            });
        };

        /**
         * Atualiza o estado de habilita√ß√£o/desabilita√ß√£o dos bot√µes com base no estado do roteiro.
         */
        const updateButtonStates = () => {
            const allMainScriptGenerated = isScriptComplete();
            // Verifica se h√° qualquer conte√∫do gerado para habilitar PDF e reset
            const hasAnyContent = document.querySelector('#scriptColumn .accordion-item') != null; // Updated selector for new dashboard

            // Bot√µes que dependem da conclus√£o do roteiro principal
            ['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn'].forEach(id => { 
                const originalBtn = document.getElementById(id);
                const floatBtn = document.getElementById(`float_${id}`);
                if (originalBtn) originalBtn.disabled = !allMainScriptGenerated;
                if (floatBtn) floatBtn.disabled = !allMainScriptGenerated;
            });
            
            // Bot√µes que dependem de qualquer conte√∫do gerado
            ['downloadPdfBtn'].forEach(id => {
                 const originalBtn = document.getElementById(id);
                 const floatBtn = document.getElementById(`float_${id}`);
                 if (originalBtn) originalBtn.disabled = !hasAnyContent;
                 if (floatBtn) floatBtn.disabled = !hasAnyContent;
            });

            // Bot√£o de reset sempre habilitado (ou desabilitado apenas se n√£o houver nada para resetar)
            const resetBtn = document.getElementById('resetScriptBtn');
            const floatResetBtn = document.getElementById('float_resetScriptBtn');
            if (resetBtn) resetBtn.disabled = false; // Ajuste conforme a necessidade de reset
            if (floatResetBtn) floatResetBtn.disabled = false;

            // REMOVIDO: Habilitar bot√µes de gera√ß√£o de roteiro se o esbo√ßo estiver pronto
            // A l√≥gica agora est√° na fun√ß√£o handleGenerateSection para exibir um alerta.
        };

        /**
         * Mostra um alerta em tela cheia com uma mensagem.
         * @param {string} message - A mensagem a ser exibida.
         */
        const showFullScreenAlert = (message) => {
            elements.fullScreenAlertMessage.textContent = message;
            elements.fullScreenAlertOverlay.classList.add('visible');
        };

        /** Esconde o alerta em tela cheia. */
        const hideFullScreenAlert = () => {
            elements.fullScreenAlertOverlay.classList.remove('visible');
        };

        /** Alterna a visibilidade do campo de estilo de imagem personalizado. */
        const toggleCustomImageStyleVisibility = () => {
            elements.customImageStyleContainer.style.display = elements.imageStyleSelect.value === 'custom' ? 'block' : 'none';
        };

        /**
         * Calcula o tempo de leitura estimado de um texto.
         * @param {string} text - O texto a ser analisado.
         * @returns {string} O tempo de leitura formatado (ex: "~1 min 15 seg").
         */
        const calculateReadingTime = (text) => {
            if (!text) return "";
            const wordsPerMinute = 150; // M√©dia para um ritmo de fala moderado
            const words = text.trim().split(/\s+/).length;
            const totalSeconds = (words / wordsPerMinute) * 60;
            
            if (totalSeconds < 1) return "";
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.round(totalSeconds % 60);
            
            let timeString = "~";
            if (minutes > 0) {
                timeString += ` ${minutes} min`;
            }
            if (seconds > 0) {
                timeString += ` ${seconds} seg`;
            }
            
            return timeString.trim();
        };

        /**
         * Gera o HTML para uma se√ß√£o do roteiro em formato de acorde√£o.
         * @param {string} sectionId - O ID da se√ß√£o (ex: 'intro', 'development').
         * @param {string} title - O t√≠tulo da se√ß√£o a ser exibido.
         * @param {string} content - O conte√∫do do roteiro para a se√ß√£o.
         * @param {object} options - Op√ß√µes para controlar a exibi√ß√£o de bot√µes (showPromptsButton, showSoundtrackButton).
         * @returns {string} O HTML completo da se√ß√£o.
         */
        const generateSectionHtmlContent = (sectionId, title, content, options = {}) => {
            // Define os valores padr√£o se n√£o forem fornecidos
            const { showPromptsButton = true, showSoundtrackButton = true } = options;
            
            const bodyId = `${sectionId}Body`;
            const arrowId = `${sectionId}Arrow`;

            const regenerateBtnHtml = `<button class="regenerate-btn" onclick="event.stopPropagation(); window.regenerateSection('${sectionId}', '${title}', '${sectionId}')" title="Re-gerar esta se√ß√£o">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                    <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
                </svg>
            </button>`;

            const copyBtnHtml = `<button class="copy-btn" onclick="event.stopPropagation(); copyTextToClipboard(document.getElementById('${bodyId}').querySelector('.generated-content-wrapper').textContent); window.showCopyFeedback(this)">Copiar</button>`;
            
            // Constr√≥i condicionalmente as se√ß√µes de prompt e trilha sonora
            const promptsSectionHtml = showPromptsButton ? `
                <div class="section-prompts">
                    <button class="btn btn-secondary btn-small" onclick="window.generatePromptsForSection('${sectionId}Section')">
                        Gerar Prompts de Imagem
                    </button>
                    <div class="prompt-container mt-4"></div>
                </div>
            ` : '';
            
            const soundtrackSectionHtml = showSoundtrackButton ? `
                <div class="section-soundtrack">
                    <button class="btn btn-secondary btn-small" onclick="window.suggestSoundtrack('${sectionId}Section')">
                        Sugerir Trilha Sonora
                    </button>
                    <div class="soundtrack-container mt-4"></div>
                </div>
            ` : '';

            // Removido o regenerateBtnHtml do header-buttons para a Descri√ß√£o do V√≠deo
            const headerButtonsHtml = (sectionId === 'videoDescriptionOutput' || sectionId === 'titlesThumbnails' || sectionId === 'strategicOutline') ?
                `${copyBtnHtml}` :
                `${regenerateBtnHtml} ${copyBtnHtml}`;

            return `<div class="accordion-item">
                        <div class="accordion-header" onclick="toggleAccordion('${bodyId}', '${arrowId}')">
                            <div class="header-content">
                                 <h3>${title}</h3>
                                 <span class="text-xs font-normal text-gray-400 dark:text-gray-500">${calculateReadingTime(content)}</span>
                                 <svg id="${arrowId}" class="accordion-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                                 </svg>
                            </div>
                            <div class="header-buttons">
                                ${headerButtonsHtml}
                            </div>
                        </div>
                        <div id="${bodyId}" class="accordion-body">
                            <div class="generated-content-wrapper" contenteditable="true">${content.startsWith('<div') ? content : `<p class="whitespace-pre-wrap">${content}</p>`}</div>
                            ${promptsSectionHtml}
                            ${soundtrackSectionHtml}
                        </div>
                    </div>`;
        };

        /**
         * Limpa o texto gerado pela IA, removendo metadados e extraindo JSON se necess√°rio.
         * @param {string} text - O texto bruto da IA.
         * @param {boolean} expectJson - Se true, tenta extrair e validar um JSON.
         * @returns {string|null} O texto limpo ou o JSON stringificado, ou null em caso de erro.
         */
        const cleanGeneratedText = (text, expectJson = false) => {
            if (!text) return null;

            if (expectJson) {
                // Encontra o primeiro colchete de abertura ou chave
                const firstBracket = text.indexOf('[');
                const firstBrace = text.indexOf('{');
                let startIndex = -1;

                if (firstBracket !== -1 && firstBrace !== -1) {
                    startIndex = Math.min(firstBracket, firstBrace);
                } else {
                    startIndex = Math.max(firstBracket, firstBrace);
                }
                
                if (startIndex === -1) {
                    console.error("N√£o foi poss√≠vel encontrar um in√≠cio de JSON ('{' ou '[') na resposta.", text);
                    return null;
                }

                // Determina o caractere de fechamento correspondente
                const startChar = text[startIndex];
                const endChar = startChar === '[' ? ']' : '}';

                // Encontra o √∫ltimo caractere de fechamento correspondente
                const endIndex = text.lastIndexOf(endChar);

                if (endIndex === -1) {
                    console.error(`JSON incompleto: caractere de fechamento '${endChar}' n√£o encontrado.`, text);
                    return null;
                }

                const jsonString = text.substring(startIndex, endIndex + 1);

                try {
                    JSON.parse(jsonString); // Valida o JSON
                    return jsonString;
                } catch (e) {
                    console.error("O JSON extra√≠do √© inv√°lido.", e.message, jsonString);
                    return null; // Retorna nulo se a valida√ß√£o falhar
                }
            }
            
            return text.trim();
        };

        /**
         * Remove coment√°rios meta da IA do texto gerado.
         * @param {string} text - O texto gerado pela IA.
         * @returns {string} O texto sem os coment√°rios meta.
         */
        const removeMetaComments = (text) => {
            if (!text) return text;
            let cleanedText = text;
            // Remove frases como "Here's the **Section** section..." ou "Here is a compelling..."
            const introPattern = /^(Here's|Here is)\s.*?\n/gim;
            cleanedText = cleanedText.replace(introPattern, '');
            return cleanedText.trim();
        };

        /**
         * Constr√≥i o contexto base do prompt com base nos inputs do usu√°rio.
         * @returns {string} O contexto do prompt.
         */
        const getBasePromptContext = () => {
            const channelName = elements.channelName.value.trim();
            const videoTheme = elements.videoTheme.value.trim();
            const targetAudience = elements.targetAudience.value.trim();
            const language = elements.languageSelect.value;
            const languageStyle = elements.languageStyle.value;
            const videoObjective = elements.videoObjective.value;
            const videoDuration = elements.videoDuration.value;
            const speakingPace = elements.speakingPace.value;
            const narrativeStyle = elements.narrativeStyle.value;
            const videoDescription = elements.videoDescription.value.trim();
            const centralQuestion = elements.centralQuestion.value.trim();
            const emotionalArc = elements.emotionalArc.value.trim();
            const viralElements = elements.viralElements.value.trim();
            const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
            const imageStyleSelect = elements.imageStyleSelect.value;
            const customImageStyle = elements.customImageStyle.value.trim();

            let context = `
            You are an expert YouTube scriptwriter for the channel "${channelName}".
            Your goal is to create highly engaging and viral video content.
            
            Video Theme: "${videoTheme}"
            Target Audience: "${targetAudience}"
            Language: "${language}"
            Language Style: "${languageStyle}"
            Video Objective: "${videoObjective}"
            Desired Duration: "${videoDuration}"
            Speaking Pace: "${speakingPace}"
            Narrative Style: "${narrativeStyle}"
            `;

            if (videoDescription) { context += `\nInspiration/Context: "${videoDescription}"`; }
            if (centralQuestion) { context += `\nCentral Question to guide the entire script: "${centralQuestion}"`; }
            if (emotionalArc) { context += `\nEmotional Arc: "${emotionalArc}"`; }
            if (viralElements) { context += `\nViral Elements to incorporate: "${viralElements}"`; }
            if (imageDescriptionEngine) { context += `\nImage Description Instructions: "${imageDescriptionEngine}"`; }
            
            if (imageStyleSelect === 'cinematic') {
                context += `\nImage Style: Cinematic film still, hyper-realistic, masterful cinematography. Shot on an Arri Alexa 65 with vintage anamorphic lenses. The composition is deliberate and powerful, using principles of photographic storytelling. Naturalistic and dramatic lighting. Strong use of light and shadow (chiaroscuro) to create depth and mood. Extreme attention to micro-details. Hyper-realistic textures are paramount: visible skin pores, fabric weaves, material imperfections. Rich, cinematic color grading. The overall mood is immersive, evocative, and deeply atmospheric.`;
            } else if (imageStyleSelect === 'custom' && customImageStyle) {
                context += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
            }

            return context;
        };

        /**
         * Constr√≥i o prompt espec√≠fico para cada se√ß√£o do roteiro ou tipo de conte√∫do.
         * @param {string} sectionName - O nome da se√ß√£o (ex: 'intro', 'titles_thumbnails').
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o para o prompt.
         * @param {string|null} outlineDirective - Uma diretriz espec√≠fica do esbo√ßo estrat√©gico para esta se√ß√£o.
         * @returns {{prompt: string, maxTokens: number}} O prompt e o limite de tokens.
         */
        const constructScriptPrompt = (sectionName, sectionTitle, outlineDirective = null) => {
            const baseContext = getBasePromptContext();
            const videoDuration = elements.videoDuration.value;
            const selectedLanguage = elements.languageSelect.value;
            const narrativeStyle = elements.narrativeStyle.value;

            let prompt = `${baseContext}\n\nGenerate the **${sectionTitle}** section of the video script. Focus on making it highly engaging and suitable for a viral video. Ensure the tone and content align with the channel and audience.`;
            let maxTokens = 2000;

            if (outlineDirective) {
                prompt += `\n\n**IMPORTANT STRATEGIC GUIDELINE:** For this specific section, you MUST follow this strategic plan: "${outlineDirective}"`;
            }

            prompt += `\n\nIMPORTANT: Do NOT include any scene descriptions, visual/audio cues (e.g., [SHOT], (Camera pan), (Music swells)), or speaker labels (e.g., "Narrator:", "Host:") in the generated script content. Provide only the spoken text.`;
            prompt += `\n\nABSOLUTELY NO META-COMMENTS. Do not add any explanatory text about the script itself. Your entire response must be ONLY the text to be spoken in the video, and nothing else.`;

            if (elements.centralQuestion.value.trim()) {
                prompt += `\nIf a 'Central Question' is provided, ensure every section of the script (Introduction, Development, Climax) directly contributes to exploring or answering this question. The entire video must revolve around this central theme.`;
            }

            switch (narrativeStyle) {
                case 'mystery_loop':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Mystery/Open Loop' structure.
                    - In the **Introduction**, present a compelling central question or mystery and promise the answer by the end.
                    - In the **Development**, build suspense by exploring clues and theories, occasionally reminding the viewer of the central question.
                    - In the **Climax**, deliver the satisfying answer to the question posed in the introduction.`;
                    break;
                case 'pas':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Problem-Agitate-Solution' structure.
                    - Frame the **Introduction** around a clear 'Problem' that the audience can relate to.
                    - Use the first part of the **Development** to 'Agitate' this problem, explaining its importance and complexity.
                    - Frame the rest of the **Development** and the **Climax** as the 'Solution' or the revealing insight that addresses the initial problem.`;
                    break;
                case 'twist':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'False Climax & Twist' structure.
                    - In the **Development**, build evidence towards a seemingly obvious conclusion (the 'false climax').
                    - In the **Climax**, introduce a surprising new piece of information or a counter-argument that completely changes the expected outcome (the 'twist').
                    - The **Conclusion** should reflect on the implications of this new, unexpected truth.`;
                    break;
                case 'heros_journey':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Hero's Journey' structure.
                    - **Introduction:** Present the 'Ordinary World' and the 'Call to Adventure'. Introduce the central character or concept.
                    - **Development:** This is the 'Special World'. Describe the trials, allies, and enemies. Build the character's transformation through challenges.
                    - **Climax:** The 'Ordeal' or the final battle. The moment of greatest tension and the hero's ultimate test.
                    - **Conclusion:** The 'Return with the Elixir'. Show the resolution, what was learned, and how the 'Ordinary World' has changed because of the journey.`;
                    break;
                case 'before_after_bridge':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Before-After-Bridge' (BAB) structure.
                    - **Introduction (Before):** Describe the 'Before' state. A world without the knowledge or solution you're about to present. Paint a picture of the problem or the lack of understanding.
                    - **Development (After):** Describe the 'After' state. A desirable world where the problem is solved or the knowledge is revealed. Show the benefits and the ideal outcome.
                    - **Climax & Conclusion (The Bridge):** Present your content as 'The Bridge'. Explain how your video's information is the exact path to get from the 'Before' state to the 'After' state. This is the solution, the 'how-to'.`;
                    break;
            }

            prompt += `\n\nIMPORTANT WRITING STYLE: Use the 'Show, Don't Tell' principle. Instead of stating facts plainly, use descriptive, evocative language to paint a picture in the viewer's mind. Create a sensory and visual experience through your words.`;

            switch (sectionName) {
                case 'outline': // New case for strategic outline
                    prompt = `${baseContext}

Voc√™ √© um mestre roteirista e estrategista de conte√∫do. Sua tarefa √© criar um "beat sheet" ou um esbo√ßo estrat√©gico detalhado para o v√≠deo. Analise todos os par√¢metros fornecidos (tema, p√∫blico, estilo narrativo, etc.) para criar a estrutura mais impactante poss√≠vel.

Responda APENAS com um objeto JSON. O objeto deve conter chaves para cada parte principal do roteiro: "introduction", "development", "climax", "conclusion", e "cta".

O valor de cada chave deve ser uma string descrevendo o objetivo, o conte√∫do e a emo√ß√£o daquela se√ß√£o espec√≠fica. Seja conciso, mas estrat√©gico.

Exemplo de formato JSON esperado:
{
  "introduction": "Come√ßar com uma pergunta ret√≥rica chocante sobre a mortalidade, seguida por uma promessa de que a hist√≥ria de L√°zaro det√©m uma resposta inesperada. Gancho emocional: curiosidade e um toque de medo existencial.",
  "development": "Construir a narrativa explorando o luto das irm√£s de L√°zaro, humanizando a hist√≥ria. Apresentar a chegada tardia de Jesus como um ponto de tens√£o e d√∫vida. Foco na emo√ß√£o de perda antes do milagre.",
  "climax": "O momento de maior tens√£o no t√∫mulo. Descrever a ordem de Jesus com autoridade e o espanto da multid√£o. O milagre deve ser o pico emocional e visual do v√≠deo.",
  "conclusion": "Resumir a li√ß√£o: o milagre n√£o √© sobre desafiar a morte, mas sobre o poder da f√©. Conectar a hist√≥ria de L√°zaro √† jornada de f√© pessoal do espectador.",
  "cta": "Fazer uma chamada para a√ß√£o suave, pedindo para o espectador compartilhar sua pr√≥pria hist√≥ria de supera√ß√£o ou f√© nos coment√°rios, criando uma comunidade."
}
`;
                    maxTokens = 1500;
                    break;
                case 'intro':
                    prompt += `
                    The introduction should hook the viewer immediately, clearly state the video's intriguing question or mystery, and set the stage for what's to come. It must be captivating and create curiosity. For a "${videoDuration}" video, make this introduction appropriate in length and detail.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 1** of the story. Your introduction should serve as the 'Inciting Incident', clearly presenting the central question or mystery that will drive the video. Establish the 'Normal World' of the topic before introducing the core conflict.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'development':
                    prompt += `
                    The development section should delve into the core topic, presenting facts, arguments, and historical context. It should maintain a strong narrative flow, building suspense and providing compelling information. Break down complex ideas into easily digestible parts. For a "${videoDuration}" video, ensure this section is comprehensive but also flows well, adapting its length to the desired duration.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 2** of the story. Your goal is to raise the stakes. Present compelling evidence but also introduce obstacles and counter-arguments. Build towards a major revelation or turning point (the Midpoint).`;
                    }
                    maxTokens = 1500;
                    break;
                case 'climax':
                    prompt += `
                    The climax should be the most impactful part of the video, revealing key insights, surprising twists, or the most compelling evidence related to the video theme. It should be dramatic and leave the viewer with a sense of awe or profound understanding. For a "${videoDuration}" video, make this climax impactful and well-paced.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is the peak of **Act 2**, leading into Act 3. Deliver the most impactful revelation or the resolution of the main conflict.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'conclusion':
                    prompt += `
                    The conclusion should summarize the main points, provide a final thought or reflection, and leave the viewer with a lasting impression. Ensure the conclusion is complete and well-rounded, providing a sense of closure. For a "${videoDuration}" video, make this conclusion concise yet impactful.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is **Act 3** of the story. Provide the final resolution and reflect on the implications of the video's journey.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 500;
                    break;
                case 'cta':
                    prompt += `
                    The Call to Action (CTA) should be clear and concise, encouraging viewers to subscribe, like, comment, share, or engage with other content. Make it compelling and natural within the video's flow. For a "${videoDuration}" video, keep this CTA direct and effective.
                    `;
                    if (narrativeStyle === 'direct') {
                        prompt += `\nThis is the final part of **Act 3**. Ensure a strong and clear call to action that naturally concludes the video's narrative.`;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = 200;
                    break;
                case 'titles_thumbnails':
                    prompt = `${baseContext}
Generate 5 highly clickable and viral YouTube video titles and 3 compelling thumbnail ideas.

IMPORTANT: Respond ONLY with a valid JSON object. Do not include any other text, preambles, or explanations outside of the JSON structure itself.

The JSON object must have two top-level keys:
1.  "titles": An array of strings.
2.  "thumbnails": An array of objects, where each object has a "title" (string) and a "description" (string) key.

The final output MUST be only the JSON code, like this example:
{
  "titles": [
    "The Shocking Truth About the Ark of the Covenant",
    "Was the Ark of the Covenant Finally Discovered?",
    "This Ancient Secret Could Change History Forever",
    "Biblical Mystery: The Ark's Final Location Revealed",
    "They Found It? The Search for the Lost Ark Ends Here"
  ],
  "thumbnails": [
    {
      "title": "FOUND?",
      "description": "A dramatic image of an ancient, glowing chest half-buried in a dark cave, with an astonished archaeologist looking on."
    },
    {
      "title": "TOP SECRET",
      "description": "A collage showing a faded ancient map, a secret biblical text, and a satellite image pointing to a location in Ethiopia."
    },
    {
      "title": "HISTORY CHANGED",
      "description": "A visually stunning image of the Ark of the Covenant radiating golden light inside a reconstructed Solomon's Temple."
    }
  ]
}
`;
                    maxTokens = 800;
                    break;
                case 'description':
                    prompt = `${baseContext}\n\nGenerate a compelling YouTube video description (around 150-200 words) that summarizes the video, includes relevant keywords for SEO, and encourages engagement. Include a strong hook, a brief overview of the content, and a call to action. Also, suggest 10 relevant hashtags.
                    Output format:
                    Description:
                    [Your description here]

                    Hashtags:
                    #hashtag1 #hashtag2 ...
                    `;
                    maxTokens = 700;
                    break;
                default:
                    maxTokens = 1000;
                    break;
            }
            return { prompt, maxTokens };
        };

        /**
         * Faz uma chamada √† API Groq atrav√©s de uma fun√ß√£o Netlify.
         * @param {string} prompt - O prompt a ser enviado para a IA.
         * @param {number} maxTokens - O n√∫mero m√°ximo de tokens para a resposta.
         * @returns {Promise<string>} A resposta bruta da IA.
         * @throws {Error} Se a chamada √† API falhar.
         */
        const callGroqAPI = async (prompt, maxTokens) => {
            const proxyUrl = "/.netlify/functions/groq"; // Endpoint do proxy

            const payload = {
                prompt: prompt,
                maxTokens: maxTokens
            };

            const request = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetch(proxyUrl, request);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Erro desconhecido do servidor proxy.' } }));
                    throw new Error(`Erro na API via Proxy: ${errorData.error?.message || 'Erro do servidor'}`);
                }
                const result = await response.json();
                const rawContent = result.choices?.[0]?.message?.content;
                if (rawContent) { return rawContent; }
                else { throw new Error("Resposta inesperada da API Groq."); }
            } catch (error) {
                console.error("Fetch da API via Netlify Function falhou:", error);
                window.showToast(`Falha na API: ${error.message}`);
                throw error;
           }
        };

        /**
         * Valida os inputs essenciais antes de gerar conte√∫do.
         * @returns {boolean} True se os inputs s√£o v√°lidos, caso contr√°rio, false.
         */
        const validateInputs = () => {
            if (!elements.channelName.value.trim()) {
                window.showToast("Por favor, insira o nome do canal.");
                return false;
            }
            if (!elements.videoTheme.value.trim()) {
                window.showToast("Por favor, insira o tema do v√≠deo.");
                return false;
            }
            if (!elements.videoDescription.value.trim()) {
                window.showToast("Por favor, insira a descri√ß√£o do v√≠deo (para inspira√ß√£o).");
                return false;
            }
            if (!elements.videoDuration.value || elements.videoDuration.value === "") {
                window.showToast("Por favor, selecione a Dura√ß√£o Desejada do v√≠deo.");
                return false;
            }
            return true;
        };

        // ==========================================================
        // ================== FUN√á√ïES PRINCIPAIS ====================
        // ==========================================================

        /**
         * Lida com a gera√ß√£o de uma se√ß√£o espec√≠fica do roteiro.
         * @param {HTMLElement} button - O bot√£o que acionou a gera√ß√£o.
         * @param {string} sectionName - O nome da se√ß√£o (ex: 'intro').
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o para exibi√ß√£o.
         * @param {string} elementId - O ID do elemento HTML onde o conte√∫do ser√° inserido (ex: 'intro').
         */
        const handleGenerateSection = async (button, sectionName, sectionTitle, elementId) => {
            if (!validateInputs()) return;
            
            // Logo no in√≠cio da fun√ß√£o
            if (!strategicOutline) {
                window.showToast("Crie o Esbo√ßo Estrat√©gico primeiro!");
                return;
            }

            showLoading(button);
            try {
                // Pega a diretriz espec√≠fica para esta se√ß√£o do nosso esbo√ßo global
                const directive = strategicOutline[sectionName]; 
                
                const { prompt, maxTokens } = constructScriptPrompt(sectionName, sectionTitle, directive);
                let result = await callGroqAPI(prompt, maxTokens);
                
                // Limpeza espec√≠fica de metadados da IA
                result = result.replace(/^Here's (?:the|a potential) \*\*[\w\s]+\*\* (?:section of the video script|for the video script):\s*\n*\s*$/gm, '');
                result = result.replace(/^(?:Host|Narrator)(?:\s*\(.*?\))?:\s*/gm, '');
                result = result.replace(/^\*\*[\w\s]+\*\*$/gm, '');
                result = result.replace(/^\s*(?:\*\*?\[.*?\]\*\*?|\(.*?\))\s*$/gm, '');
                result = result.replace(/^\s*[\r\n]+/gm, '');

                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);

                const targetSectionElement = document.getElementById(`${elementId}Section`);
                if (targetSectionElement) {
                    const sectionHtml = generateSectionHtmlContent(elementId, sectionTitle, result);
                    targetSectionElement.innerHTML = sectionHtml;
                    const accordionItem = targetSectionElement.querySelector('.accordion-item');
                    if(accordionItem) accordionItem.classList.add('animate-fade-in');
                } else {
                    console.error(`Target section element with ID '${elementId}Section' not found.`);
                    window.showToast("Erro interno: Se√ß√£o do roteiro n√£o encontrada.");
                    return;
                }
                
                markButtonAsCompleted(button.id);
                updateButtonStates();

            } catch (error) {
                window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
                console.error(`Error generating ${sectionTitle}.`, error);
            } finally {
                hideLoading(button);
            }
        };

        /**
         * Re-gera o conte√∫do de uma se√ß√£o espec√≠fica do roteiro.
         * Chamada pelos bot√µes "Re-gerar" dentro das se√ß√µes.
         * @param {string} sectionName - O nome da se√ß√£o (ex: 'intro').
         * @param {string} sectionTitle - O t√≠tulo da se√ß√£o.
         * @param {string} elementId - O ID do elemento HTML da se√ß√£o.
         */
        window.regenerateSection = (sectionName, sectionTitle, elementId) => {
            const mainButtonIdMap = {
                'intro': 'generateIntroBtn',
                'development': 'generateDevelopmentBtn',
                'climax': 'climaxBtn',
                'conclusion': 'conclusionBtn',
                'cta': 'generateCTABtn'
            };
            const buttonId = mainButtonIdMap[sectionName];
            if (buttonId) {
                const button = document.getElementById(buttonId);
                handleGenerateSection(button, sectionName, sectionTitle, elementId);
            }
        };

        /**
         * Gera prompts de imagem para uma se√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionElementId - O ID do elemento HTML da se√ß√£o (ex: 'introSection').
         */
        window.generatePromptsForSection = async (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            const scriptContentElement = sectionElement.querySelector('.generated-content-wrapper'); // Updated selector
            const promptContainer = sectionElement.querySelector('.prompt-container');
            
            if (!scriptContentElement || !scriptContentElement.textContent.trim()) {
                window.showToast("Por favor, gere o conte√∫do do roteiro desta se√ß√£o primeiro.");
                return;
            }

            const scriptContent = scriptContentElement.textContent;
            
            promptContainer.innerHTML = `<div class="loading-spinner-small"></div>`; // Mostra um spinner

            const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
            const imageStyleSelect = elements.imageStyleSelect.value;
            const customImageStyle = elements.customImageStyle.value.trim();
            let selectedStyleBlock = '';

            let prompt = `Voc√™ √© um diretor de v√≠deo. Sua tarefa √© ler o trecho de roteiro a seguir e criar prompts de imagem.

**SUA REGRA MAIS IMPORTANTE √© manter um ritmo din√¢mico.** N√£o crie uma imagem para cada frase. O objetivo √© criar um prompt a cada **15 a 25 segundos de narra√ß√£o**, aproximadamente. Isso significa que voc√™ deve LER v√°rias frases, entender o tempo de narra√ß√£o e s√≥ ent√£o escolher o momento mais impactante DENTRO desse bloco de tempo para criar UM prompt.

**IMAGEM INICIAL INEGOCI√ÅVEL:** O primeiro prompt de imagem que voc√™ criar **DEVE OBRIGATORIAMENTE** corresponder √† **PRIMEIRA FRASE COMPLETA** do trecho do roteiro. Sem exce√ß√µes. O v√≠deo precisa de um impacto visual imediato.

Encontre os pontos de virada ou as imagens mentais mais fortes dentro desses intervalos de tempo.

Responda APENAS com um array JSON de objetos (com chaves "scriptPhrase" e "imageDescription").

Trecho do roteiro:
---${scriptContent}
---`;
            
            if (imageDescriptionEngine) {
                prompt += `\n\nAlso, ensure the image descriptions incorporate the following quality instructions: "${imageDescriptionEngine}"`;
            }

            if (imageStyleSelect === 'cinematic') {
                const cinematicPromptPart = `Apply a cinematic film still style to these image descriptions: hyper-realistic, masterful cinematography, Arri Alexa 65, vintage anamorphic lenses, deliberate composition, dramatic naturalistic lighting, strong chiaroscuro, extreme attention to micro-details, hyper-realistic textures (skin pores, fabric weaves, material imperfections), rich cinematic color grading, immersive and evocative mood. Avoid cgi, 3d, render, painting, illustration, animation, video game, digital art, cartoon.`;
                prompt += `\n\n${cinematicPromptPart}`;
                selectedStyleBlock = CINEMATIC_STYLE_BLOCK;
            } else if (imageStyleSelect === 'custom' && customImageStyle) {
                prompt += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
                selectedStyleBlock = customImageStyle;
            }

            try {
                const rawResult = await callGroqAPI(prompt, 4000); // Aumentado para 4000 tokens para prompts de imagem
                const cleanedText = cleanGeneratedText(rawResult, true);
                let prompts = [];
                if (cleanedText) {
                    try {
                        prompts = JSON.parse(cleanedText);
                        if (!Array.isArray(prompts)) {
                            console.warn("AI returned non-array JSON, attempting to convert.");
                            prompts = [prompts];
                        }
                    } catch (e) {
                        window.showToast("Erro ao analisar JSON de prompts de imagem. Verifique o console.");
                        console.error("Erro ao analisar JSON de prompts de imagem:", e);
                        prompts = [];
                    }
                } else {
                    window.showToast("Erro: IA n√£o retornou prompts ou o formato est√° incorreto para esta se√ß√£o.");
                }

                // Armazena os prompts gerados na estrutura global
                let accumulatedTimeSeconds = 1; // Reinicia para cada se√ß√£o para c√°lculo de tempo
                allImagePrompts[sectionElementId] = prompts.map((p, i) => {
                    const time = accumulatedTimeSeconds;
                    accumulatedTimeSeconds += 20; // Estimativa de 20s por cena
                    const mins = Math.floor(time / 60);
                    const secs = Math.floor(time % 60);
                    return { 
                        ...p, 
                        time: `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`, 
                        sequence: String(i + 1).padStart(2, '0'),
                        styleBlock: selectedStyleBlock
                    };
                });

                promptContainer.innerHTML = ''; // Limpa o spinner
                if (allImagePrompts[sectionElementId] && allImagePrompts[sectionElementId].length > 0) {
                    allImagePrompts[sectionElementId].forEach(promptData => {
                        const styleBlockContent = promptData.styleBlock || '';
                        const promptHtml = `
                            <div class="individual-prompt-block">
                                <div class="flex items-center justify-between mb-2">
                                    <p class="prompt-time">${promptData.time} - Cena ${promptData.sequence}</p>
                                    <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${promptData.sequence}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${promptData.sequence}').textContent); window.showCopyFeedback(this)">Copiar</button>
                            </div>
                                <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                                <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                                <p id="prompt-content-${sectionElementId}-${promptData.sequence}" class="prompt-description-content">${promptData.imageDescription}</p>
                                <pre id="style-block-${sectionElementId}-${promptData.sequence}" class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                            </div>
                        `;
                        promptContainer.innerHTML += promptHtml;
                    });
                } else {
                    promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta se√ß√£o.</p>';
                }
                updateButtonStates(); // Atualiza o estado dos bot√µes ap√≥s gerar prompts
            } catch (error) {
                promptContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar prompts: ${error.message}</p>`;
                console.error(`Error generating prompts for section ${sectionElementId}.`, error);
            }
        };

        /**
         * Sugere trilhas sonoras para uma se√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionId - O ID do elemento HTML da se√ß√£o (ex: 'introSection').
         */
        window.suggestSoundtrack = async (sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const scriptContent = sectionElement.querySelector('.generated-content-wrapper').textContent; // Updated selector
            const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
            
            if (!scriptContent) {
                window.showToast("Gere o roteiro para esta se√ß√£o primeiro.");
                return;
            }

            soundtrackContainer.innerHTML = `<div class="loading-spinner-small"></div>`; // Mostra um spinner

            const prompt = `Voc√™ √© um especialista em prompts para IAs de gera√ß√£o de m√∫sica (como Suno/Udio). Sua tarefa √© analisar o seguinte trecho de roteiro e criar 3 prompts de texto distintos e detalhados.

**REGRAS DE FORMATA√á√ÉO (N√ÉO NEGOCI√ÅVEIS):**1.  Sua resposta DEVE SER um array JSON v√°lido.2.  O array deve conter EXATAMENTE 3 strings.3.  CADA string deve ser um par√°grafo √∫nico, bem escrito e descritivo, pronto para ser colado em uma IA de m√∫sica. N√ÉO use chaves, colchetes ou qualquer outra sintaxe de objeto DENTRO da string do prompt.

**EXEMPLO DE RESPOSTA PERFEITA:**
["Generate an epic, cinematic orchestral piece in the style of Hans Zimmer... No vocals or percussion, focus on the emotional intensity of the strings and piano.","Create a contemplative, melancholic ambient track with a slow, mournful tempo... No bright or cheerful notes, focus on the darker, more introspective tones.","Craft an uplifting, inspirational electronic piece with a moderate tempo... avoid any jarring or harsh sounds, focusing on the soaring, inspirational quality of the melody."
]

Agora, use o roteiro abaixo como inspira√ß√£o para criar 3 prompts seguindo EXATAMENTE este formato.

Trecho do roteiro para analisar:
---
${scriptContent}
---`;
            
            try {
                const rawResult = await callGroqAPI(prompt, 500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const suggestions = JSON.parse(cleanedResult);

                // Adiciona tratamento de erro para garantir que suggestions √© um array de strings
                if (!Array.isArray(suggestions) || !suggestions.every(s => typeof s === 'string')) {
                    throw new Error("A IA retornou um formato de trilha sonora inesperado. Esperava um array de strings.");
                }

                soundtrackContainer.innerHTML = ''; // Limpa o spinner
                if (suggestions && suggestions.length > 0) {
                    let suggestionsHtml = '<ul class="soundtrack-list">';
                    suggestions.forEach(suggestion => {
                        suggestionsHtml += `<li>${suggestion}</li>`;
                    });
                    suggestionsHtml += '</ul>';
                    soundtrackContainer.innerHTML = suggestionsHtml;
                } else {
                    soundtrackContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhuma sugest√£o de trilha sonora foi gerada.</p>';
                }
            } catch (error) {
                soundtrackContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugest√µes: ${error.message}</p>`;
            }
        };

        /**
         * Gera t√≠tulos de v√≠deo e ideias de thumbnail.
         */
        const generateTitlesAndThumbnails = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateTitlesAndThumbnailsBtn);
            try {
                const { prompt, maxTokens } = constructScriptPrompt('titles_thumbnails');
                const result = await callGroqAPI(prompt, maxTokens);
                const cleanedResult = cleanGeneratedText(result, true);
                
                if (!cleanedResult) throw new Error("A IA n√£o retornou um JSON v√°lido.");
                
                const parsedContent = JSON.parse(cleanedResult);
                generatedTitlesAndThumbnails = parsedContent;

                const targetContentElement = document.getElementById('titlesThumbnailsContent');
                if (targetContentElement) {
                    const titlesListHtml = parsedContent.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                    const thumbnailsListHtml = parsedContent.thumbnails.map((thumb, index) => `
                        <div class="${index === 0 ? '' : 'thumbnail-item-separator'}"> 
                            <p class="font-semibold">"${thumb.title}"</p>
                            <p class="text-sm leading-tight">Descri√ß√£o: ${thumb.description}</p>
                        </div>
                    `).join('');

                    targetContentElement.innerHTML = `
                        <div class="space-y-4 text-sm text-gray-700 dark:text-gray-300">
                            <div>
                                <h4 class="font-bold text-base mb-2">Sugest√µes de T√≠tulos:</h4>
                                <div class="p-3 bg-gray-50 dark:bg-gray-700/50 rounded-md space-y-2">${titlesListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeTitles()">Analisar CTR</button>
                                    <div id="ctrAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                            <div>
                                <h4 class="font-bold text-base mb-2">Ideias de Thumbnail:</h4>
                                <div class="p-3 bg-gray-50 dark:bg-gray-700/50 rounded-md space-y-3">${thumbnailsListHtml}</div>
                            </div>
                        </div>
                    `;
                    markButtonAsCompleted(buttons.generateTitlesAndThumbnailsBtn.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar T√≠tulos: ${error.message}`);
                console.error("Error generating Titles/Thumbnails.", error);
            } finally {
                hideLoading(buttons.generateTitlesAndThumbnailsBtn);
                updateButtonStates();
            }
        };

        /**
         * Analisa o potencial de clique (CTR) dos t√≠tulos gerados.
         */
        window.analyzeTitles = async () => {
            if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.titles || generatedTitlesAndThumbnails.titles.length === 0) {
                window.showToast("Gere os t√≠tulos primeiro!");
                return;
            }

            const resultContainer = document.getElementById('ctrAnalysisResult');
            resultContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

            const titlesString = generatedTitlesAndThumbnails.titles.join('\n');
            
            const prompt = `Voc√™ √© um especialista em marketing de conte√∫do para o YouTube. Analise a seguinte lista de t√≠tulos de v√≠deo. Para cada um, forne√ßa uma "nota de CTR" de 0 a 10 (onde 10 √© um clique quase garantido) e uma sugest√£o curta e objetiva para melhor√°-lo, focando em curiosidade, urg√™ncia e benef√≠cio claro.

            Responda APENAS com um array JSON. Cada objeto no array deve ter as chaves "titulo_original", "nota_ctr" e "sugestao_melhora".

            T√≠tulos para analisar:
            ---
            ${titlesString}
            ---`;

            try {
                const rawResult = await callGroqAPI(prompt, 2000);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const analysis = JSON.parse(cleanedResult);

                let analysisHtml = '<div class="space-y-4">';
                analysis.forEach(item => {
                    analysisHtml += `
                        <div class="p-3 border border-gray-200 rounded-md dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm">
                            <p class="font-semibold text-gray-800 dark:text-gray-200">${item.titulo_original}</p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de CTR:</strong> <span class="text-indigo-500 font-bold">${item.nota_ctr} / 10</span></p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugest√£o:</strong> ${item.sugestao_melhora}</p>
                        </div>
                    `;
                });
                analysisHtml += '</div>';
                resultContainer.innerHTML = analysisHtml;

            } catch (error) {
                resultContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao analisar os t√≠tulos: ${error.message}</p>`;
            }
        };

        /**
         * Gera a descri√ß√£o do v√≠deo e hashtags.
         */
        const generateVideoDescription = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateDescriptionBtn);
            try {
                const { prompt, maxTokens } = constructScriptPrompt('description');
                const result = cleanGeneratedText(await callGroqAPI(prompt, maxTokens), false);
                
                const targetContentElement = document.getElementById('videoDescriptionContent');
                if (targetContentElement) {
                    targetContentElement.innerHTML = `<div class="p-3 text-sm text-gray-700 dark:text-gray-300 bg-gray-50 dark:bg-gray-700/50 rounded-md whitespace-pre-wrap">${result}</div>`;
                    markButtonAsCompleted(buttons.generateDescriptionBtn.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar Descri√ß√£o: ${error.message}`);
                console.error("Error generating Video Description.", error);
            } finally {
                hideLoading(buttons.generateDescriptionBtn);
                updateButtonStates();
            }
        };

        /**
         * Gera o esbo√ßo estrat√©gico do roteiro.
         */
        const generateStrategicOutline = async () => {
            if (!validateInputs()) return;
            showLoading(buttons.generateOutlineBtn);
            const outlineContentDiv = elements.outlineContent;
            outlineContentDiv.innerHTML = `<div class="loading-spinner-small mx-auto"></div>`;

            try {
                const { prompt, maxTokens } = constructScriptPrompt('outline', 'Esbo√ßo Estrat√©gico');
                const result = await callGroqAPI(prompt, maxTokens); // Use maxTokens from constructScriptPrompt
                const cleanedResult = cleanGeneratedText(result, true);

                if (!cleanedResult) throw new Error("A IA n√£o retornou um JSON v√°lido para o esbo√ßo.");

                strategicOutline = JSON.parse(cleanedResult); // Armazena o esbo√ßo globalmente
                
                // Formata o esbo√ßo para exibi√ß√£o
                let outlineHtml = '<ul class="list-disc list-inside space-y-2 text-sm text-gray-700 dark:text-gray-300">';
                for (const key in strategicOutline) {
                    outlineHtml += `<li><strong class="font-semibold text-gray-800 dark:text-gray-200 capitalize">${key}:</strong> ${strategicOutline[key]}</li>`;
                }
                outlineHtml += '</ul>';
                outlineContentDiv.innerHTML = outlineHtml;

                // REMOVIDO: Habilita os bot√µes de gera√ß√£o de se√ß√£o
                // A l√≥gica agora est√° na fun√ß√£o handleGenerateSection para exibir um alerta.

                markButtonAsCompleted(buttons.generateOutlineBtn.id);

            } catch (error) {
                window.showToast(`Falha ao gerar Esbo√ßo: ${error.message}`);
                console.error("Error generating Outline.", error);
                outlineContentDiv.innerHTML = `<div class="asset-card-placeholder text-red-500">Erro ao gerar o esbo√ßo. Tente novamente.</div>`;
            } finally {
                hideLoading(buttons.generateOutlineBtn);
                updateButtonStates();
            }
        };


        /**
         * Realiza o download do roteiro como PDF.
         */
        const downloadPdf = async () => {
            // Apenas chama a fun√ß√£o de impress√£o nativa do navegador
            window.print();
        };

        /**
         * Reseta o estado da aplica√ß√£o para um novo roteiro.
         */
        const resetApplicationState = () => {
            elements.videoTheme.value = '';
            elements.videoDescription.value = '';
            elements.centralQuestion.value = '';
            elements.emotionalArc.value = '';
            elements.viralElements.value = '';
            elements.imageDescriptionEngine.value = '';
            elements.imageStyleSelect.value = 'cinematic';
            elements.customImageStyle.value = '';
            toggleCustomImageStyleVisibility();
            elements.narrativeStyle.value = 'direct';
            elements.videoDuration.value = '';

            // Limpar a coluna de roteiro
            document.querySelectorAll('#scriptColumn > .script-section').forEach(sec => {
                sec.innerHTML = '';
                sec.classList.remove('animate-fade-in'); // Remove a classe de anima√ß√£o ao resetar
            });
            // Limpar o cart√£o do esbo√ßo
            elements.outlineContent.innerHTML = `<div class="asset-card-placeholder text-sm">Clique em 'Criar Esbo√ßo' para a IA planejar a estrutura do roteiro.</div>`;
            strategicOutline = null; // Reseta o esbo√ßo estrat√©gico

            // Limpar os cart√µes de recursos e restaurar os placeholders
            document.getElementById('titlesThumbnailsContent').innerHTML = '<div class="asset-card-placeholder">Clique em \'Gerar\' para ver as sugest√µes</div>';
            document.getElementById('videoDescriptionContent').innerHTML = '<div class="asset-card-placeholder">Clique em \'Gerar\' para ver a descri√ß√£o</div>';
            // Removed storyboardContent reset

            allImagePrompts = {}; // Limpa todos os prompts de imagem
            generatedTitlesAndThumbnails = null;
            
            resetCompletionIcons();
            updateButtonStates();
            updateProgressBar(); 

            // Esconder o dashboard at√© que um novo conte√∫do seja gerado
            elements.projectDashboard.classList.add('hidden');

            window.showToast("Pronto para um novo roteiro!");
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        /**
         * Exporta o estado atual do projeto para um arquivo JSON.
         */
        const exportProject = () => {
            const projectData = {
                inputs: {},
                outputs: {},
                memory: {
                    allImagePrompts: allImagePrompts,
                    generatedTitlesAndThumbnails: generatedTitlesAndThumbnails,
                    strategicOutline: strategicOutline // Exporta o esbo√ßo
                }
            };

            // Salva o estado dos inputs
            for (const key in elements) {
                if (elements[key] && typeof elements[key].value !== 'undefined') {
                    projectData.inputs[key] = elements[key].value;
                }
            }
            // Salva o conte√∫do gerado (HTML interno das se√ß√µes)
            const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'];
            scriptSectionIds.forEach(id => {
                const sectionElement = document.getElementById(id);
                if (sectionElement) {
                    projectData.outputs[id] = sectionElement.innerHTML;
                }
            });

            // Salva o conte√∫do do esbo√ßo
            projectData.outputs.strategicOutlineContent = elements.outlineContent.innerHTML;

            // Salva o conte√∫do dos cart√µes de recursos
            projectData.outputs.titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent').innerHTML;
            projectData.outputs.videoDescriptionContent = document.getElementById('videoDescriptionContent').innerHTML;
            // Removed storyboardContent export
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            const fileName = elements.videoTheme.value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro_viral';
            downloadAnchorNode.setAttribute("download", `${fileName}_projeto.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            window.showToast("Projeto exportado com sucesso!");
        };

        /**
         * Renderiza os prompts de imagem para uma se√ß√£o espec√≠fica na UI.
         * Usado ap√≥s carregar um projeto.
         * @param {string} sectionElementId - O ID do elemento HTML da se√ß√£o.
         */
        const renderImagePromptsForSection = (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            if (!sectionElement) return;

            const promptContainer = sectionElement.querySelector('.prompt-container');
            if (!promptContainer) return;

            promptContainer.innerHTML = ''; // Limpa prompts existentes

            const promptsData = allImagePrompts[sectionElementId];
            if (promptsData && promptsData.length > 0) {
                promptsData.forEach(promptData => {
                    const styleBlockContent = promptData.styleBlock || '';
                    const promptHtml = `
                        <div class="individual-prompt-block">
                            <div class="flex items-center justify-between mb-2">
                                <p class="prompt-time">${promptData.time} - Cena ${promptData.sequence}</p>
                                <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${promptData.sequence}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${promptData.sequence}').textContent); window.showCopyFeedback(this)">Copiar</button>
                            </div>
                            <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                            <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                            <p id="prompt-content-${sectionElementId}-${promptData.sequence}" class="prompt-description-content">${promptData.imageDescription}</p>
                            <pre id="style-block-${sectionElementId}-${promptData.sequence}" class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                        </div>
                    `;
                    promptContainer.innerHTML += promptHtml;
                });
            } else {
                promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta se√ß√£o.</p>';
            }
        };

        /**
         * Importa um projeto de um arquivo JSON.
         * @param {Event} event - O evento de mudan√ßa do input de arquivo.
         */
        const importProject = (event) => {
            const file = event.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    resetApplicationState(); // Limpa o estado atual antes de importar

                    // Restaura os inputs
                    for (const key in projectData.inputs) {
                        if (elements[key] && typeof elements[key].value !== 'undefined') {
                            elements[key].value = projectData.inputs[key];
                        }
                    }

                    // Restaura o conte√∫do gerado nas se√ß√µes do roteiro
                    const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'];
                    scriptSectionIds.forEach(id => {
                        const sectionElement = document.getElementById(id);
                        if (sectionElement && projectData.outputs[id]) {
                            sectionElement.innerHTML = projectData.outputs[id];
                            sectionElement.classList.remove('hidden'); // Ensure it's visible if it has content
                            sectionElement.classList.add('animate-fade-in');
                        }
                    });

                    // Restore strategic outline content
                    if (projectData.outputs.strategicOutlineContent) {
                        elements.outlineContent.innerHTML = projectData.outputs.strategicOutlineContent;
                    }
                    strategicOutline = projectData.memory.strategicOutline || null; // Importa o esbo√ßo

                    // Restore content of the asset cards
                    if (projectData.outputs.titlesThumbnailsContent) {
                        document.getElementById('titlesThumbnailsContent').innerHTML = projectData.outputs.titlesThumbnailsContent;
                    }
                    if (projectData.outputs.videoDescriptionContent) {
                        document.getElementById('videoDescriptionContent').innerHTML = projectData.outputs.videoDescriptionContent;
                    }
                    // Removed storyboardContent import

                    // Restaura as vari√°veis de mem√≥ria
                    allImagePrompts = projectData.memory.allImagePrompts || {};
                    generatedTitlesAndThumbnails = projectData.memory.generatedTitlesAndThumbnails || null;

                    updateButtonStates();
                    
                    // Marca os bot√µes como conclu√≠dos se o conte√∫do existir
                    // Strategic Outline button
                    if (elements.outlineContent.textContent.trim() !== "Clique em 'Criar Esbo√ßo' para a IA planejar a estrutura do roteiro." && elements.outlineContent.textContent.trim() !== "N√£o foi poss√≠vel gerar o esbo√ßo. Tente novamente." && elements.outlineContent.textContent.trim() !== "Erro ao gerar.") {
                        markButtonAsCompleted('generateOutlineBtn');
                    }
                    // Script sections
                    if (document.getElementById('introSection').innerHTML.trim()) markButtonAsCompleted('generateIntroBtn');
                    if (document.getElementById('developmentSection').innerHTML.trim()) markButtonAsCompleted('generateDevelopmentBtn');
                    if (document.getElementById('climaxSection').innerHTML.trim()) markButtonAsCompleted('climaxBtn');
                    if (document.getElementById('conclusionSection').innerHTML.trim()) markButtonAsCompleted('conclusionBtn');
                    if (document.getElementById('ctaSection').innerHTML.trim()) markButtonAsCompleted('generateCTABtn');
                    // Asset buttons (check if content is not placeholder)
                    if (document.getElementById('videoDescriptionContent').innerHTML.trim() !== '<div class="asset-card-placeholder">Clique em \'Gerar\' para ver a descri√ß√£o</div>') markButtonAsCompleted('generateDescriptionBtn');
                    if (document.getElementById('titlesThumbnailsContent').innerHTML.trim() !== '<div class="asset-card-placeholder">Clique em \'Gerar\' para ver as sugest√µes</div>') markButtonAsCompleted('generateTitlesAndThumbnailsBtn');
                    // Removed storyboardContent check for completion


                    // Re-renderiza os prompts de imagem para todas as se√ß√µes
                    for (const sectionId in allImagePrompts) {
                        if (allImagePrompts.hasOwnProperty(sectionId)) {
                            renderImagePromptsForSection(sectionId);
                        }
                    }
                    updateProgressBar(); 
                    // Show dashboard after import
                    elements.projectDashboard.classList.remove('hidden');
                    window.showToast("Projeto importado com sucesso!");

                } catch (err) {
                    window.showToast("Erro: Arquivo de projeto inv√°lido ou corrompido.");
                    console.error("Erro ao importar projeto:", err);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Limpa o input para permitir importar o mesmo arquivo novamente
        };

        /**
         * Analisa o tema e a descri√ß√£o do v√≠deo para definir a estrat√©gia de conte√∫do.
         */
        const analyzeAndSetStrategy = async () => {
            const theme = elements.videoTheme.value.trim();
            const description = elements.videoDescription.value.trim();

            if (!theme || !description) {
                window.showToast("Por favor, preencha o Tema e a Descri√ß√£o do V√≠deo.");
                return;
            }

            const button = buttons.analyzeStrategyBtn;
            showLoading(button);

            // Op√ß√µes v√°lidas para cada campo (precisamos disso para a IA)
            const languageStyleOptions = Array.from(elements.languageStyle.options).map(o => o.value).join(', ');
            const videoObjectiveOptions = Array.from(elements.videoObjective.options).map(o => o.value).join(', ');
            const narrativeStyleOptions = Array.from(elements.narrativeStyle.options).map(o => o.value).join(', ');

            const prompt = `Voc√™ √© um Estrategista de Conte√∫do de IA para o YouTube. Sua tarefa √© analisar o tema e a descri√ß√£o de um v√≠deo e definir a melhor estrat√©gia de conte√∫do para ele.

            Tema do V√≠deo: "${theme}"
            Descri√ß√£o do V√≠deo: "${description}"

            Com base nisso, preencha os seguintes campos. Responda APENAS com um objeto JSON v√°lido.

            O objeto JSON deve ter as seguintes chaves:
            1.  "target_audience": (string) Descreva em uma frase o p√∫blico-alvo ideal para este v√≠deo.
            2.  "language_style": (string) Escolha o melhor estilo de linguagem da seguinte lista: [${languageStyleOptions}].
            3.  "video_objective": (string) Analise o tema e escolha o objetivo principal do v√≠deo. Sua resposta para esta chave DEVE SER UMA correspond√™ncia EXATA de uma das seguintes op√ß√µes: [${videoObjectiveOptions}].
            4.  "narrative_style": (string) Escolha a estrutura narrativa mais impactante da seguinte lista: [${narrativeStyleOptions}].
            5.  "central_question": (string) Formule a pergunta central mais intrigante que o v√≠deo deve responder.
            6.  "emotional_arc": (string) Descreva o arco emocional ideal em uma frase curta (Ex: Curiosidade -> Tens√£o -> Revela√ß√£o -> Inspira√ß√£o).

            Analise profundamente o tema e a descri√ß√£o para fazer as escolhas mais coesas e eficazes.`;

            try {
                const rawResult = await callGroqAPI(prompt, 1000);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const strategy = JSON.parse(cleanedResult);

                // Preenche os campos da interface com a resposta da IA
                if(strategy.target_audience) elements.targetAudience.value = strategy.target_audience;
                if(strategy.language_style) elements.languageStyle.value = strategy.language_style;
                
                if (strategy.video_objective) {
                    const objectiveSelect = elements.videoObjective;
                    const returnedValue = strategy.video_objective;
                    
                    // Cria um array com todos os valores v√°lidos das op√ß√µes
                    const validOptions = Array.from(objectiveSelect.options).map(opt => opt.value);
                    
                    // Verifica se o valor retornado pela IA est√° na nossa lista de op√ß√µes v√°lidas
                    if (validOptions.includes(returnedValue)) {
                        objectiveSelect.value = returnedValue;
                    } else {
                        // Se n√£o for v√°lido, define um padr√£o seguro (ex: 'informar')
                        console.warn(`IA retornou um 'video_objective' inv√°lido: '${returnedValue}'. Usando o padr√£o 'informar'.`);
                        objectiveSelect.value = 'informar'; 
                    }
                }

                if(strategy.narrative_style) elements.narrativeStyle.value = strategy.narrative_style; // CORRIGIDO AQUI
                if(strategy.central_question) elements.centralQuestion.value = strategy.central_question;
                if(strategy.emotional_arc) elements.emotionalArc.value = strategy.emotional_arc;

                window.showToast("Estrat√©gia definida com sucesso!");
                elements.projectDashboard.classList.remove('hidden'); // Show dashboard after strategy is set

            } catch (error) {
                window.showToast(`Falha ao definir estrat√©gia: ${error.message}`);
                console.error("Erro na an√°lise estrat√©gica:", error);
            } finally {
                hideLoading(button);
            }
        };

        /**
         * Controla a visibilidade e o conte√∫do da barra de a√ß√µes flutuante com base na rolagem.
         */
        window.handleFloatingActionBar = () => {
            const mainActions = document.getElementById('mainActions');
            const quickActions = document.getElementById('quickActions');
            const projectDashboard = document.getElementById('projectDashboard'); // Changed from scriptOutput
            
            if (!projectDashboard) return;

            const actionBar = elements.floatingActionBar;
            // Ponto de gatilho para a barra flutuante (um pouco antes da √°rea de output)
            const triggerPoint = projectDashboard.offsetTop - actionBar.offsetHeight - 50; // 50px de buffer

            if (window.scrollY > triggerPoint) {
                // Se rolou para a √°rea de resultados, mostra a barra e as A√ß√µes R√°pidas
                actionBar.classList.add('visible');
                mainActions.classList.add('hidden');
                quickActions.classList.remove('hidden');
            } else if (window.scrollY > 150) { // Um pequeno buffer para n√£o aparecer imediatamente no topo
                // Se rolou um pouco, mas n√£o chegou nos resultados, mostra a barra com as A√ß√µes Principais
                actionBar.classList.add('visible');
                mainActions.classList.remove('hidden');
                quickActions.classList.add('hidden');
            } else {
                // Se est√° no topo, esconde a barra
                actionBar.classList.remove('visible');
            }
        };

        /**
         * Alterna o estado de um acorde√£o (abrir/fechar).
         * @param {string} bodyId - O ID do corpo do acorde√£o.
         * @param {string} arrowId - O ID do √≠cone de seta do acorde√£o.
         */
        window.toggleAccordion = (bodyId, arrowId) => {
            const body = document.getElementById(bodyId);
            const arrow = document.getElementById(arrowId);
            if (body && arrow) {
                body.classList.toggle('open');
                arrow.classList.toggle('open');
                // Adiciona ou remove a classe 'active' no elemento pai do cabe√ßalho
                arrow.closest('.accordion-header').classList.toggle('active');
            }
        };

        // ==========================================================
        // NOVA FUN√á√ÉO PARA ATUALIZAR A BARRA DE PROGRESO
        // ==========================================================
        const updateProgressBar = () => {
            // Lista de todas as tarefas que contam para o progresso
            const taskButtonIds = [
                'generateOutlineBtn', // Added outline button
                'generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 
                'conclusionBtn', 'generateCTABtn', 'generateDescriptionBtn', 
                'generateTitlesAndThumbnailsBtn' 
            ];
            const totalTasks = taskButtonIds.length;

            let completedTasks = 0;
            taskButtonIds.forEach(id => {
                const button = document.getElementById(id);
                // Check if the button is marked as success (meaning content was generated)
                if (button && button.classList.contains('btn-success')) {
                    completedTasks++;
                }
            });

            const percentage = Math.round((completedTasks / totalTasks) * 100);

            // Atualiza a UI
            if (elements.progressBar && elements.progressText) {
                elements.progressBar.style.width = `${percentage}%`;
                elements.progressText.textContent = `${percentage}%`;

                if (percentage === 100) {
                    elements.progressBar.textContent = "Projeto Pronto!"; // Atualiza o texto diretamente na barra
                    elements.progressBar.style.backgroundColor = 'var(--primary-color)';
                } else {
                     // Garante que a cor volte ao verde se n√£o for 100%
                    elements.progressBar.style.backgroundColor = 'var(--success-color)';
                }
            }
        };

        // ==========================================================
        // ================== INICIALIZA√á√ÉO =======================
        // ==========================================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Initializing app."); 
            
            // Adiciona as novas refer√™ncias de elementos
            elements.progressBar = document.getElementById('progressBar');
            elements.progressText = document.getElementById('progressText');
            elements.projectDashboard = document.getElementById('projectDashboard'); // New reference
            elements.outlineContent = document.getElementById('outlineContent'); // New reference for outline content

            // Configura os event listeners para os bot√µes
            const setupClick = (originalId) => {
                const floatBtn = document.getElementById(`float_${originalId}`);
                if (floatBtn) {
                    floatBtn.addEventListener('click', () => {
                        document.getElementById(originalId).click();
                    });
                }
            };

            // Conecta os bot√µes flutuantes aos originais
            // Iterar sobre todos os bot√µes que t√™m um flutuante correspondente
            const allButtonIds = Object.keys(buttons);
            allButtonIds.forEach(id => {
                // Exclui o bot√£o do modo zen da barra flutuante, pois ele foi movido
                if (id.startsWith('generate') || id.startsWith('climax') || id.startsWith('conclusion') || id.startsWith('cta') || id.startsWith('download') || id.startsWith('reset') || id.startsWith('export') || id.startsWith('import')) {
                    setupClick(id);
                }
            });
            
            // Adiciona os listeners de a√ß√£o aos bot√µes originais
            if (buttons.generateOutlineBtn) buttons.generateOutlineBtn.addEventListener('click', generateStrategicOutline); // New listener for outline
            if (buttons.generateIntroBtn) buttons.generateIntroBtn.addEventListener('click', () => handleGenerateSection(buttons.generateIntroBtn, 'intro', 'Introdu√ß√£o', 'intro'));
            if (buttons.generateDevelopmentBtn) buttons.generateDevelopmentBtn.addEventListener('click', () => handleGenerateSection(buttons.generateDevelopmentBtn, 'development', 'Desenvolvimento', 'development'));
            if (buttons.climaxBtn) buttons.climaxBtn.addEventListener('click', () => handleGenerateSection(buttons.climaxBtn, 'climax', 'Cl√≠max', 'climax'));
            if (buttons.conclusionBtn) buttons.conclusionBtn.addEventListener('click', () => handleGenerateSection(buttons.conclusionBtn, 'conclusion', 'Conclus√£o', 'conclusion'));
            if (buttons.generateCTABtn) buttons.generateCTABtn.addEventListener('click', () => handleGenerateSection(buttons.generateCTABtn, 'cta', 'Chamada para A√ß√£o', 'cta'));
            if (buttons.generateTitlesAndThumbnailsBtn) buttons.generateTitlesAndThumbnailsBtn.addEventListener('click', generateTitlesAndThumbnails);
            if (buttons.generateDescriptionBtn) buttons.generateDescriptionBtn.addEventListener('click', generateVideoDescription);
            // Removed storyboard button listener
            if (buttons.resetScriptBtn) buttons.resetScriptBtn.addEventListener('click', resetApplicationState);
            if (buttons.downloadPdfBtn) buttons.downloadPdfBtn.addEventListener('click', downloadPdf); // Changed to window.print()
            if (buttons.exportProjectBtn) buttons.exportProjectBtn.addEventListener('click', exportProject); // Listener para o bot√£o de exportar
            
            // Outros listeners
            if (buttons.fullScreenAlertCloseBtn) buttons.fullScreenAlertCloseBtn.addEventListener('click', hideFullScreenAlert); // CORRIGIDO AQUI
            if (elements.imageStyleSelect) elements.imageStyleSelect.addEventListener('change', toggleCustomImageStyleVisibility);
            
            // NOVO C√ìDIGO √Ä PROVA DE BALAS PARA O MODO ESCURO
            const darkModeButton = document.getElementById('darkModeToggle');
            if (darkModeButton) {
                darkModeButton.addEventListener('click', () => {
                    const moonIcon = document.getElementById('moonIcon');
                    const sunIcon = document.getElementById('sunIcon');
                    
                    // Alterna a classe 'dark' no body
                    document.body.classList.toggle('dark');

                    // Verifica se o modo escuro est√° ATIVO agora
                    if (document.body.classList.contains('dark')) {
                        // Se SIM, esconde a lua, mostra o sol, e salva no localStorage
                        if (moonIcon) moonIcon.classList.add('hidden');
                        if (sunIcon) sunIcon.classList.remove('hidden');
                        localStorage.setItem('darkMode', 'enabled');
                    } else {
                        // Se N√ÉO, esconde o sol, mostra a lua, e salva no localStorage
                        if (moonIcon) moonIcon.classList.remove('hidden');
                        if (sunIcon) sunIcon.classList.add('hidden');
                        localStorage.setItem('darkMode', 'disabled');
                    }
                });
            }
            // Adicione esta linha dentro do DOMContentLoaded, fora de qualquer listener
            if (localStorage.getItem('darkMode') === 'enabled') {
                const moonIcon = document.getElementById('moonIcon');
                const sunIcon = document.getElementById('sunIcon');
                document.body.classList.add('dark');
                if (moonIcon) moonIcon.classList.add('hidden');
                if (sunIcon) sunIcon.classList.remove('hidden');
            }

            if (buttons.analyzeStrategyBtn) buttons.analyzeStrategyBtn.addEventListener('click', analyzeAndSetStrategy);
            if (buttons.importProjectBtn) {
                buttons.importProjectBtn.addEventListener('click', () => elements.importFileInput.click());
                elements.importFileInput.addEventListener('change', importProject);
            }

            // L√≥gica para o Modo Zen
            const zenModeBtn = document.getElementById('toggleZenModeBtn'); // Updated ID
            if (zenModeBtn) {
                zenModeBtn.addEventListener('click', () => {
                    document.body.classList.toggle('zen-mode');
                });
            }

            // NOVO - L√ìGICA PARA SAIR DO MODO FOCO
            document.body.addEventListener('click', function(event) {
                // Se o modo foco est√° ativo E o clique foi no fundo (diretamente no body)
                if (document.body.classList.contains('zen-mode') && event.target === document.body) {
                    document.body.classList.remove('zen-mode');
                }
            });

            // Define o estado inicial dos bot√µes
            updateButtonStates();
            // Adiciona o listener de rolagem para a barra flutuante
            window.addEventListener('scroll', window.handleFloatingActionBar);
            updateProgressBar(); 
        });
    </script>
</body>
</html>