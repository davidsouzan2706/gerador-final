<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros Virais v108</title>
    <!-- Tailwind CSS CDN - Not recommended for production, but fine for development/prototyping. -->
    <!-- For production, install as a PostCSS plugin or Tailwind CLI: https://tailwindcss.com/docs/installation -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- O bloco safelist foi removido, pois a abordagem de CSS puro será usada. -->
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- LINHAS A SEREM ADICIONADAS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Carlito:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Carlito', sans-serif; /* <-- ALTERAÇÃO AQUI */
            background-color: #f0f2f5;
        }
        .container {
            max-width: 1024px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
        }
        .input-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
            display: block;
        }
        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1.5px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            background-color: #f9fafb;
        }
        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #4f46e5; /* Indigo-600 */
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
            background-color: #ffffff;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: none;
        }
        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo-600 */
            color: #ffffff;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #4338ca; /* Indigo-700 */
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }
        .btn-secondary {
            background-color: #e0e7ff; /* Indigo-100 */
            color: #4338ca; /* Indigo-700 */
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #c7d2fe; /* Indigo-200 */
            transform: translateY(-2px);
            box-shadow: 0 44px 12px rgba(79, 70, 229, 0.15);
        }
        .script-section {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            /* white-space: pre-wrap; REMOVED THIS LINE */
            overflow-wrap: break-word;
            word-break: break-word;
            position: relative;
        }
        .script-section h3 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 1rem;
        }
        /* Updated .copy-btn for general use */
        .copy-btn {
            position: absolute;
            top: 1rem; /* Adjusted for consistency */
            right: 1rem; /* Adjusted for consistency */
            background-color: #4f46e5; /* Darker background */
            color: #ffffff; /* White text */
            border: none;
            border-radius: 6px;
            padding: 0.4rem 0.8rem; /* Smaller padding */
            font-size: 0.8rem; /* Smaller font size */
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-btn:hover {
            background-color: #3730a3; /* Darker hover */
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        .btn-secondary .loading-spinner {
            border: 4px solid rgba(67, 56, 202, 0.2);
            border-left-color: #4338ca;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Styles for the new toast notification */
        #toastNotification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1001;
            white-space: nowrap;
        }
        #toastNotification.toast-visible {
            opacity: 1;
            visibility: visible;
        }

        #userIdDisplay {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 0.8rem;
            color: #4338ca;
            background-color: #e0e7ff;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
        }
        .sub-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
        }
        .sub-section h4 {
            font-weight: 600;
            color: #4f46e5;
            margin-bottom: 0.5rem;
        }
        .individual-prompt-block { /* Adicionado estilo para prompts individuais */
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: #ffffff;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05); /* Subtle shadow */
        }
        /* Removed specific .individual-prompt-block .copy-btn as it's now covered by general .copy-btn */
        .prompt-phrase {
            font-size: 0.875rem; /* Reduced font size to sm */
            color: #1f2937;
            font-weight: 700; /* Kept bold */
            margin-bottom: 0rem; /* Reduced margin */
            line-height: 1.4; /* Adjusted line height for better readability */
            text-align: left; /* Aligned to left */
        }
        .prompt-time {
            font-size: 0.75rem; /* Reduced font size to xs */
            color: #4f46e5;
            font-weight: 700;
            margin-right: 0.5rem;
            text-align: left; /* Aligned to left */
        }
        .prompt-description-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #4b5563;
            margin-top: 0.5rem; /* Reduced spacing */
            border-top: 1px dashed #e5e7eb; /* Dashed line separator */
            padding-top: 0.5rem; /* Reduced padding */
        }
        .prompt-description-content {
            font-size: 0.9rem;
            color: #374151;
            line-height: 1.5;
            padding-right: 4rem; /* Para não sobrepor o botão de copiar */
            margin-bottom: 0.25rem; /* Reduced margin to make it closer to style block */
        }
        .completion-message {
            text-align: center;
            font-weight: 600;
            color: #4f46e5;
            margin-top: 1.5rem;
            padding: 1rem;
            border: 1px dashed #c7d2fe;
            border-radius: 8px;
            background-color: #eef2ff;
        }

        /* NEW: Styles for the full-screen alert */
        #fullScreenAlertOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Dark overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        #fullScreenAlertOverlay.visible {
            visibility: visible;
            opacity: 1;
        }

        #fullScreenAlertBox {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 500px;
            width: 90%;
            position: relative;
            transform: translateY(-20px); /* Slight animation on appear */
            transition: transform 0.3s ease-out;
        }

        #fullScreenAlertOverlay.visible #fullScreenAlertBox {
            transform: translateY(0);
        }

        #fullScreenAlertBox p {
            font-size: 1.1rem;
            color: #1f2937;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        #fullScreenAlertBox button {
            background-color: #4f46e5;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
        }

        #fullScreenAlertBox button:hover {
            background-color: #4338ca;
        }
        /* Style for the completion icon */
        .completion-icon {
            margin-left: 0.5rem; /* Space between text and icon */
            color: #10B981; /* Green-500 */
            font-size: 2.2em; /* Doubled from 1.1em to 2.2em, now controls SVG size */
            line-height: 1; /* Align vertically */
            display: inline-flex; /* Use flex to center SVG if needed */
            align-items: center;
            justify-content: center;
            /* Ensure the SVG scales with font-size */
            width: 1em; /* Make SVG width scale with font-size */
            height: 1em; /* Make SVG height scale with font-size */
        }
        .completion-icon.hidden {
            display: none;
        }
        /* Styles for button text and spinner */
        .button-text.hidden {
            display: none;
        }
        .loading-spinner.hidden {
            display: none;
        }

        /* ============== ADICIONE ESTA NOVA CLASSE AQUI ============== */
        .thumbnail-item-separator {
            margin-top: 1.5rem;    /* Equivalente ao mt-6 do Tailwind */
            padding-top: 1.5rem;   /* Equivalente ao pt-6 do Tailwind */
            border-top: 1px solid #e5e7eb; /* Equivalente ao border-t border-gray-200 */
        }

        /* Adicione no final do seu CSS */
        .script-section p[contenteditable="true"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
            background-color: #eef2ff; /* Um fundo levemente azulado */
        }

        /* Adicione no final do seu CSS */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .section-header h3 {
            margin-bottom: 0; /* Remove a margem do h3 para alinhar */
        }
        .header-buttons {
            display: flex;
            gap: 0.5rem;
            position: static; /* Remove o position:absolute dos botões */
        }
        .copy-btn, .regenerate-btn {
            position: static; /* Remove o position:absolute */
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
        }
        .regenerate-btn {
            background-color: #e0e7ff;
            color: #4338ca;
        }
        .regenerate-btn:hover {
            background-color: #c7d2fe;
        }
        .copy-btn {
            /* Estilos do copy-btn já existem, apenas confirmando */
            background-color: #4f46e5;
            color: #ffffff;
        }
        .copy-btn:hover {
            background-color: #3730a3;
        }

        /* ================== ESTILOS MODO ESCURO ================== */
        body.dark {
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        .dark .container {
            background-color: #1f2937; /* gray-800 */
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }
        .dark .text-gray-800 { color: #f9fafb; } /* gray-50 */
        .dark .text-gray-500 { color: #9ca3af; } /* gray-400 */
        .dark .input-group label { color: #d1d5db; } /* gray-300 */
        .dark .input-group input,
        .dark .input-group select,
        .dark .input-group textarea {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
            color: #f9fafb; /* gray-50 */
        }
        .dark .input-group input:focus,
        .dark .input-group select:focus,
        .dark .input-group textarea:focus {
            border-color: #6366f1; /* indigo-500 */
            background-color: #4b5563; /* gray-600 */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        .dark .bg-gray-50 {
            background-color: #374151 !important; /* gray-700 */
        }
        .dark .border-gray-200 {
            border-color: #4b5563 !important; /* gray-600 */
        }
        .dark .text-gray-700 { color: #e5e7eb; } /* gray-200 */
        .dark .script-section {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
        }
        .dark .script-section h3 { color: #f9fafb; } /* gray-50 */
        .dark .script-section p[contenteditable="true"]:focus {
            background-color: #4b5563; /* gray-600 */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        .dark .individual-prompt-block {
            background-color: #1f2937;
            border-color: #374151;
        }
        .dark .prompt-phrase { color: #f3f4f6; }
        .dark .prompt-description-label { color: #9ca3af; }
        .dark .prompt-description-content { color: #d1d5db; }
        .dark pre { background-color: #374151 !important; color: #d1d5db; }
        #darkModeToggle {
            color: #4b5563;
        }
        .dark #darkModeToggle {
            color: #9ca3af;
        }
        /* ======================================================= */
        /* ======== ADIÇÕES PARA POLIMENTO DO MODO ESCURO ======== */
        /* ======================================================= */
        /* Corrige a cor dos subtítulos (h4) dentro das seções */
        .dark .script-section h4 {
            color: #e5e7eb; /* gray-200 */
        }
        /* Corrige o fundo e o texto das caixas internas na seção de Títulos */
        .dark .p-3.border.border-gray-200 {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
        }
        /* Corrige a cor do texto dos títulos de vídeo gerados */
        .dark .p-3.border.border-gray-200 p {
            color: #d1d5db; /* gray-300 */
        }
        /* Corrige a cor do título da thumbnail (que está em negrito) */
        .dark .p-3.border.border-gray-200 .font-semibold {
            color: #f9fafb; /* gray-50 */
        }

        /* NOVOS ESTILOS PARA PROMPTS POR SEÇÃO */
        .section-prompts {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #d1d5db;
        }
        .dark .section-prompts {
            border-top-color: #4b5563;
        }
        .btn-small {
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
        }
        .loading-spinner-small {
            border: 3px solid rgba(67, 56, 202, 0.2);
            border-left-color: #4338ca;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }
        /* ========================================================== */
        /* ============== ESTILOS PARA OS TOOLTIPS ============== */
        /* ========================================================== */
        .tooltip {
            position: relative; /* Essencial para o posicionamento do balão */
            cursor: help; /* Muda o cursor para indicar que há ajuda */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #e0e7ff; /* Cor de fundo do ícone */
            color: #4f46e5; /* Cor do texto (?) */
            font-weight: 700;
            font-size: 12px;
            user-select: none; /* Impede que o texto (?) seja selecionado */
        }
        .dark .tooltip {
            background-color: #4b5563;
            color: #e5e7eb;
        }
        /* O balão do tooltip (invisível por padrão) */
        .tooltip::before, .tooltip::after {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 150%; /* Posiciona o balão acima do ícone */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            pointer-events: none; /* Impede que o balão bloqueie o mouse */
            z-index: 10;
        }
        /* O conteúdo do balão */
        .tooltip::before {
            content: attr(data-tooltip); /* Pega o texto do atributo data-tooltip */
            background-color: #1f2937; /* Fundo do balão */
            color: #ffffff;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 400;
            width: 280px; /* Largura do balão */
            line-height: 1.5;
            text-align: left;
            white-space: pre-wrap; /* <-- A MÁGICA ACONTECE AQUI */
        }
        /* A pequena seta para baixo */
        .tooltip::after {
            content: '';
            bottom: calc(150% - 10px); /* Posiciona a seta abaixo do balão */
            border-width: 5px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent;
        }
        /* Mostra o balão e a seta quando o mouse está sobre o ícone */
        .tooltip:hover::before, .tooltip:hover::after {
            opacity: 1;
            visibility: visible;
        }
        /* ========================================================== */
        /* ======== ESTILOS PARA SUGESTÕES DE TRILHA SONORA ======== */
        /* ========================================================== */
        .section-soundtrack {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #d1d5db;
        }
        .dark .section-soundtrack {
            border-top-color: #4b5563;
        }
        /* Estiliza a lista de sugestões */
        .soundtrack-list {
            list-style-type: disc; /* Adiciona bolinhas na lista */
            padding-left: 20px; /* Adiciona um recuo à lista */
            font-size: 0.9rem;
            color: #374151; /* Cor do texto no modo claro */
        }
        .soundtrack-list li {
            margin-bottom: 0.5rem; /* Espaçamento entre os itens da lista */
        }
        .dark .soundtrack-list {
            color: #d1d5db; /* Cor do texto no modo escuro */
        }
        /* ========================================================== */
        /* ======== ESTILOS PARA A BARRA DE AÇÕES FLUTUANTE ======== */
        /* ========================================================== */
        .floating-action-bar {
            position: fixed; /* Essencial para flutuar */
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px); /* Efeito de vidro fosco */
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 999; /* Garante que fique acima de tudo */
            padding: 0.75rem 0;
            
            /* Começa invisível e fora da tela */
            transform: translateY(-100%);
            opacity: 0;
            visibility: hidden;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .floating-action-bar.visible {
            transform: translateY(0); /* Fica visível e na posição correta */
            opacity: 1;
            visibility: visible;
        }
        .dark .floating-action-bar {
            background-color: rgba(31, 41, 55, 0.9); /* gray-800 com transparência */
        }
        .action-bar-content {
            max-width: 1024px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        /* Renomeie .action-bar-buttons para .action-bar-buttons-group */
        .action-bar-buttons-group {
            display: flex;
            align-items: center; /* Alinha o título e os botões */
            gap: 0.75rem;
            width: 100%; /* Garante que o grupo ocupe o espaço */
        }
        /* Oculta o grupo que tiver a classe 'hidden' */
        .action-bar-buttons-group.hidden {
            display: none;
        }
        /* Garante que o título e os botões se ajustem */
        .action-bar-buttons-group .action-bar-title {
            white-space: nowrap; /* Impede que o título quebre linha */
        }
        .action-bar-buttons-group .btn-clone-container {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end; /* Alinha os botões à direita */
            width: 100%;
        }

        /* Estilo para os botões clonados na barra */
        .action-bar-buttons-group .btn {
            padding: 0.5rem 1rem; /* Um pouco menores */
            font-size: 0.875rem;
        }
        /* Correção para o espaçamento dos botões clonados */
        .action-bar-buttons-group .btn-clone-container .btn {
            margin-left: 0.75rem; /* Equivalente ao 'gap' */
        }
        .action-bar-buttons-group .btn-clone-container .btn:first-child {
            margin-left: 0; /* Remove a margem do primeiro botão */
        }
    </style>
</head>
<body>
    <!-- ========================================================== -->
    <!-- =========== NOVA BARRA DE AÇÕES FLUTUANTE ============ -->
    <!-- ========================================================== -->
    <!-- NOVO HTML COM DUAS BARRAS -->
    <div id="floatingActionBar" class="floating-action-bar">
        <div class="action-bar-content">
            <!-- Barra para o Passo 1 -->
            <div id="mainActions" class="action-bar-buttons-group">
                <span class="action-bar-title">Passo 1:</span>
                <div class="btn-clone-container"></div>
            </div>
            <!-- Barra para os Passos 2 e 3 -->
            <div id="quickActions" class="action-bar-buttons-group hidden">
                <span class="action-bar-title">Ações Rápidas:</span>
                <div class="btn-clone-container"></div>
            </div>
        </div>
    </div>
    <!-- ========================================================== -->

    <div class="container relative">
        <div id="userIdDisplay" class="hidden"></div> <!-- User ID Display -->
        <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-2">Gerador de Roteiros Virais</h1>
        <!-- NOVO BOTÃO DE MODO ESCURO -->
        <div class="absolute top-4 right-4">
            <button id="darkModeToggle" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                <!-- Ícone da Lua -->
                <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                </svg>
                <!-- Ícone do Sol -->
                <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m8.66-14.66l-.707.707M4.04 19.96l-.707.707M21 12h-1M4 12H3m16.66-7.96l-.707-.707M4.04 4.04l-.707-.707" />
                </svg>
            </button>
        </div>
        <p class="text-center text-gray-500 mb-8">Crie conteúdo de alto impacto para o seu canal do YouTube.</p>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="input-group">
                <label for="channelName">Nome do Canal:</label>
                <input type="text" id="channelName" placeholder="Ex: The Biblical Unveiling" value="The Biblical Unveiling">
            </div>
            <div class="input-group">
                <label for="videoTheme">Tema do Vídeo:</label>
                <input type="text" id="videoTheme" placeholder="Ex: A Arca da Aliança Foi Encontrada?">
            </div>
            <div class="input-group md:col-span-2">
                <label for="targetAudience">Público-Alvo:</label>
                <input type="text" id="targetAudience" value="Pessoas Interessadas em Arqueologia Bíblica e História Antiga, Cristãos e Pessoas de Fé, Entusiastas de Ciência e Ceticismo (com mente aberta), Curiosos em Geral e Amantes de Mistérios." readonly>
            </div>
            <div class="input-group">
                <label for="languageSelect">Idioma do Roteiro:</label>
                <select id="languageSelect">
                    <option value="pt-br">Português (Brasil)</option>
                    <option value="pt-pt">Português (Portugal)</option>
                    <option value="en" selected>English</option> <!-- Changed selected to en -->
                    <option value="es">Españão</option>
                </select>
            </div>
             <div class="input-group">
                <label for="languageStyle">Estilo de Linguagem:</label>
                <select id="languageStyle">
                    <option value="formal">Formal</option>
                    <option value="informal">Informar</option>
                    <option value="emocional">Emocional</option>
                    <option value="tecnico">Técnico</option>
                    <option value="inspirador" selected>Inspirador</option>
                    <option value="humoristico">Humorístico</option>
                </select>
            </div>
            <div class="input-group md:col-span-2">
                <label for="videoObjective">Objetivo do Vídeo:</label>
                <select id="videoObjective">
                    <option value="informar" selected>Informar</option>
                    <option value="emocionar">Emocionar</option>
                    <option value="evangelizar">Evangelizar (criar defensores)</option>
                    <option value="vender">Vender</option>
                    <option value="entreter">Entreter</option>
                </select>
            </div>
            <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                        <div class="input-group">
                            <label for="videoDuration">Duração Desejada:</label>
                            <select id="videoDuration">
                                <option value="">-- Selecione a Duração --</option> <!-- NEW: Placeholder option -->
                                <option value="short">Curto (~1-3 min)</option>
                                <option value="medium">Médio (~4-7 min)</option> <!-- REMOVED 'selected' attribute -->
                                <option value="long">Longo (~8-12 min)</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="speakingPace">Ritmo de Fala:</label>
                            <select id="speakingPace">
                                <option value="slow">Lento</m>
                                <option value="moderate" selected>Moderado</option>
                                <option value="fast">Rápido</option>
                            </select>
                        </div>
            </div>
            <!-- NEW: Narrative Style Select -->
            <div class="input-group md:col-span-2">
                <div class="flex items-center gap-2"> <!-- Usamos flexbox para alinhamento do label e do ícone -->
                    <label for="narrativeStyle">Estilo da Narrativa:</label>
                    <span class="tooltip"
      data-tooltip="Direto e Informativo: Estrutura clássica de começo, meio e fim. Ideal para documentários.
      
Jornada do Herói: Conta uma história de transformação e superação. Ótimo para narrativas inspiradoras.

Mistério (Loop Aberto): Apresenta uma pergunta no início e a responde no final. Excelente para reter a atenção.

Problema-Agitação-Solução (PAS): Foca em um problema que o público tem e apresenta a solução. Perfeito para vídeos de marketing e tutoriais.

Antes-Depois-Ponte (BAB): Mostra um cenário 'antes' (o problema), um 'depois' (o resultado ideal) e seu conteúdo como 'a ponte' para chegar lá.

Narrativa com Virada (Twist): Constrói uma expectativa e a quebra com uma revelação surpreendente no final."
>
    (?)</span>
                </div>
                <select id="narrativeStyle">
                    <option value="direct" selected>Direto e Informativo (Padrão)</option>
                    <option value="heros_journey">Jornada do Herói (Clássico)</option>
                    <option value="mystery_loop">Mistério (com Loop Aberto)</option>
                    <option value="pas">Problema-Agitação-Solução (PAS)</option>
                    <option value="before_after_bridge">Antes-Depois-Ponte (BAB)</option>
                    <option value="twist">Narrativa com Virada (Twist)</option>
                </select>
            </div>
            <div class="input-group md:col-span-2">
                <label for="videoDescription">Descrição do Vídeo (para inspiração):</label>
                <textarea id="videoDescription" rows="4" placeholder="Cole uma breve descrição do vídeo aqui para que a IA possa usar como inspiração para o roteiro."></textarea>
            </div>
            <!-- ========================================================== -->
            <!-- ======== NOVO BOTÃO DE ESTRATÉGIA AUTOMÁTICA ========= -->
            <!-- ========================================================== -->
            <div class="md:col-span-2 my-4 flex justify-center">
                <button id="analyzeStrategyBtn" class="btn btn-primary w-full md:w-1/2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" class="bi bi-magic" viewBox="0 0 16 16">
                        <path d="M9.5 2.672a.5.5 0 1 0 1 0V.843a.5.5 0 0 0-1 0v1.829Zm4.5.035A.5.5 0 0 0 13.293 2L12 3.293a.5.5 0 1 0 .707.707L14 2.707a.5.5 0 0 0 0-.707ZM7.293 4A.5.5 0 1 0 8 3.293L6.707 2A.5.5 0 0 0 6 2.707L7.293 4Zm-.621 2.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L7.38 6.207a.5.5 0 0 0-.707 0ZM5.5 7a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Zm-1.829-1.5a.5.5 0 0 0-.707 0L2 6.793a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L3.707 7.5H3.5a.5.5 0 0 0 0-1h.207L2.707 5.5Zm-1 .707a.5.5 0 0 0-.707-.707L.707 6.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L1.293 7.5H1.5a.5.5 0 0 0 0-1h-.207L2.293 6.207Z"/>
                        <path d="M12.026 8.5H11a.5.5 0 0 0 0 1h1.026a.5.5 0 0 0 0-1Zm-1.633.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293Zm-3.134 3.367a.5.5 0 1 0-.707.707l1.293 1.293a.5.5 0 0 0 .707-.707l-1.293-1.293Zm1.633-.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293A.5.5 0 0 1 8.89 11.86Z"/>
                    </svg>
                    <span class="button-text">Definir Estratégia com IA</span>
                    <div class="loading-spinner hidden"></div>
                </button>
            </div><!-- ========================================================== -->
            <div class="input-group md:col-span-2">
                <label for="centralQuestion">Pergunta Central (Opcional):</label>
                <textarea id="centralQuestion" rows="2" placeholder="Ex: A Arca da Aliança era uma arma ou um meio de comunicação?"></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="emotionalArc">Arco Emocional Desejado (Opcional):</label>
                <textarea id="emotionalArc" rows="2" placeholder="Ex: Começar com curiosidade, construir para admiração, e terminar com inspiração."></textarea>
            </div>
            <div class="input-group md:col-span-2">
                <label for="viralElements">Elementos Virais/Tendências (Opcional):</label>
                <textarea id="viralElements" rows="2" placeholder="Insira memes, frases, tendências ou palavras-chave em alta. Ex: 'o hype é real', 'chocado', 'plot twist'"></textarea>
            </div>
            <!-- RENOMEADO: imageQualityInstructions para imageDescriptionEngine -->
            <div class="input-group md:col-span-2">
                <label for="imageDescriptionEngine">Motor de Descrição de Imagem:</label>
                <textarea id="imageDescriptionEngine" rows="2" placeholder="Ex: 'alta resolução', 'detalhado', 'fotorrealista', 'cores vibrantes'"></textarea>
            </div>
            <!-- NOVO: Motor de Qualidade de Imagem com seleção de estilo -->
            <div class="input-group md:col-span-2">
                <label for="imageStyleSelect">Motor de Qualidade de Imagem:</label>
                <select id="imageStyleSelect">
                    <option value="cinematic" selected>Cinematográfico</option>
                    <option value="custom">Personalizado</option>
                    <option value="none">Nenhum</option>
                </select>
            </div>
            <div class="input-group md:col-span-2" id="customImageStyleContainer" style="display: none;">
                <label for="customImageStyle">Estilo Visual Personalizado:</label>
                <textarea id="customImageStyle" rows="5" placeholder="Cole aqui o seu bloco de estilo personalizado (ex: para cartoon, anime, etc.)."></textarea>
            </div>
            <div class="input-group md:col-span-2" style="display: none;">
                <label for="apiKeyInput">Chaves da API (Groq - uma por linha):</label>
                <textarea id="apiKeyInput" rows="4" placeholder="Cole suas chaves de API do Groq aqui, uma por linha (ex:
gsk_xxxxxxxxxxxxxxxxxxxxxx
gsk_yyyyyyyyyyyyyyyyyyyyyy)"></textarea>
                <!-- NOTE: Exposing API keys on the client-side is a security risk. This is for demonstration purposes. In a production environment, handle API calls through a secure backend server. -->
            </div>
        </div>

        <div class="mb-8 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
            <h3 class="font-bold text-lg text-indigo-800 mb-3">Passo 1: Gerar o Roteiro Principal</h3>
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                <button id="generateIntroBtn" class="btn btn-primary">
                    <span class="button-text">Introdução</span>
                    <span id="introCheck" class="completion-icon hidden"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></span>
                    <div class="loading-spinner hidden" id="introSpinner"></div>
                </button>
                <button id="generateDevelopmentBtn" class="btn btn-primary">
                    <span class="button-text">Desenvolvimento</span>
                    <span id="developmentCheck" class="completion-icon hidden"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></span>
                    <div class="loading-spinner hidden" id="developmentSpinner"></div>
                </button>
                <button id="generateClimaxBtn" class="btn btn-primary">
                    <span class="button-text">Clímax</span>
                    <span id="climaxCheck" class="completion-icon hidden"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></span>
                    <div class="loading-spinner hidden" id="climaxSpinner"></div>
                </button>
                <button id="conclusionBtn" class="btn btn-primary">
                    <span class="button-text">Conclusão</span>
                    <span id="conclusionCheck" class="completion-icon hidden"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></span>
                    <div class="loading-spinner hidden" id="conclusionSpinner"></div>
                </button>
                <button id="generateCTABtn" class="btn btn-primary">
                    <span class="button-text">CTA</span>
                    <span id="ctaCheck" class="completion-icon hidden"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></span>
                    <div class="loading-spinner hidden" id="ctaSpinner"></div>
                </button>
            </div>
        </div>

        <div class="mb-8 p-4 bg-gray-50 border border-gray-200 rounded-lg">
            <h3 class="font-bold text-lg text-gray-800 mb-3">Passo 2: Criar Material de Suporte</h3>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <button id="generateDescriptionBtn" class="btn btn-secondary">
                    <span class="button-text">Descrição do Vídeo</span>
                    <span id="descriptionCheck" class="completion-icon hidden"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></span>
                    <div class="loading-spinner hidden" id="descriptionSpinner"></div>
                </button>
                <!-- Swapped positions of these two buttons -->
                <button id="generateTitlesAndThumbnailsBtn" class="btn btn-secondary">
                    <span class="button-text">Títulos de Vídeos e Thumbnails</span>
                    <span id="titlesThumbnailsCheck" class="completion-icon hidden"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></span>
                    <div class="loading-spinner hidden" id="titlesThumbnailsSpinner"></div>
                </button>
                <!-- O botão "Prompts de Imagem" global foi removido daqui -->
            </div>
        </div>
       
        <div class="mb-8 p-4 bg-gray-50 border border-gray-200 rounded-lg">
            <h3 class="font-bold text-lg text-gray-800 mb-3">Passo 3: Salvar e Exportar</h3>
             <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- ========================================================== -->
                <!-- ======== NOVOS BOTÕES DE EXPORTAR E IMPORTAR ========= -->
                <!-- ========================================================== -->
                <button id="exportProjectBtn" class="btn btn-secondary">Exportar Projeto</button>
                <button id="importProjectBtn" class="btn btn-secondary">Importar Projeto</button>
                <input type="file" id="importFileInput" class="hidden" accept=".json">
                <button id="downloadPdfBtn" class="btn btn-secondary">Download PDF</button>
                <button id="resetScriptBtn" class="btn btn-secondary">Novo Roteiro</button>
                <!-- ========================================================== -->
            </div>
        </div>

        <div id="scriptOutput" class="mt-8">
            <!-- Fixed script sections will be dynamically updated here -->
            <div id="introSection" class="script-section hidden"></div>
            <div id="developmentSection" class="script-section hidden"></div>
            <div id="climaxSection" class="script-section hidden"></div>
            <div id="conclusionSection" class="script-section hidden"></div>
            <div id="ctaSection" class="script-section hidden"></div>
            <div id="videoDescriptionOutputSection" class="script-section hidden"></div>
            <div id="titlesThumbnailsSection" class="script-section hidden"></div>
        </div>

        <!-- A div #imagePromptsOutput foi removida daqui -->
    </div>

    <!-- Custom Toast Notification for Alerts -->
    <div id="toastNotification" class="toast-notification"></div>

    <!-- NEW: Full-screen alert for incomplete script -->
    <div id="fullScreenAlertOverlay">
        <div id="fullScreenAlertBox">
            <p id="fullScreenAlertMessage"></p>
            <button id="fullScreenAlertCloseBtn">Entendi</button>
        </div>
    </div>

    <script type="module">
    // Import do Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // ================================================================
    // =================== ESTRUTURA DE CÓDIGO CORRIGIDA ================
    // ================================================================

    // --- 1. VARIÁVEIS GLOBAIS E CONSTANTES ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    // Correção: Usar __initial_auth_token diretamente
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 
    let app, db, auth;
    let userId = null;
    let isAuthReady = false;
    let generatedTitlesAndThumbnails = null;
    let apiKeys = [];
    // allImagePrompts agora é um objeto para armazenar prompts por seção
    let allImagePrompts = {}; 
    // currentImagePromptIndex e IMAGE_PROMPT_BATCH_SIZE não são mais necessários para a nova lógica
    // const IMAGE_PROMPT_BATCH_SIZE = 2; 
    const CINEMATIC_STYLE_BLOCK = `
**[ESTILO CINEMATOGRÁFICO]**
**Style:** Cinematic film still, hyper-realistic, masterful cinematography. Shot on an Arri Alexa 65 with vintage anamorphic lenses. The composition is deliberate and powerful, using principles of photographic storytelling.
**Lighting:** Naturalistic and dramatic lighting. Strong use of light and shadow (chiaroscuro) to create depth and mood. The light source feels authentic to the environment, whether it's harsh sunlight, soft window light, or moody candlelight.
**Details & Textures:** Extreme attention to micro-details. Hyper-realistic textures are paramount: visible skin pores, fabric weaves, material imperfections (scratches on metal, weathering on stone, dust on surfaces). Every element feels tangible and real.
**Color & Mood:** Rich, cinematic color grading. The color palette is carefully controlled to enhance the story and emotion of the scene. The overall mood is immersive, evocative, and deeply atmospheric.
**Negative Prompt:** --no cgi, 3d, render, painting, illustration, animation, video game, digital art, cartoon
`;
    const imageDescriptionLabels = { 'pt-br': 'Descrição da Imagem:', 'pt-pt': 'Descrição da Imagem:', 'en': 'Image Description:', 'es': 'Descripción de la Imagen:' };

    // --- 2. REFERÊNCIAS A ELEMENTOS DO DOM ---
    const elements = {
        channelName: document.getElementById('channelName'),
        videoTheme: document.getElementById('videoTheme'),
        targetAudience: document.getElementById('targetAudience'),
        languageSelect: document.getElementById('languageSelect'),
        languageStyle: document.getElementById('languageStyle'),
        videoObjective: document.getElementById('videoObjective'),
        videoDuration: document.getElementById('videoDuration'),
        speakingPace: document.getElementById('speakingPace'),
        narrativeStyle: document.getElementById('narrativeStyle'),
        videoDescription: document.getElementById('videoDescription'),
        centralQuestion: document.getElementById('centralQuestion'),
        emotionalArc: document.getElementById('emotionalArc'),
        viralElements: document.getElementById('viralElements'),
        imageDescriptionEngine: document.getElementById('imageDescriptionEngine'),
        imageStyleSelect: document.getElementById('imageStyleSelect'),
        customImageStyle: document.getElementById('customImageStyle'),
        customImageStyleContainer: document.getElementById('customImageStyleContainer'),
        apiKeyInput: document.getElementById('apiKeyInput'),
        userIdDisplay: document.getElementById('userIdDisplay'),
        scriptOutput: document.getElementById('scriptOutput'),
        // imagePromptsOutput e imagePromptsList foram removidos do HTML
        // loadMoreImagePromptsBtn também foi removido
        toastNotification: document.getElementById('toastNotification'),
        fullScreenAlertOverlay: document.getElementById('fullScreenAlertOverlay'),
        fullScreenAlertMessage: document.getElementById('fullScreenAlertMessage'),
        fullScreenAlertCloseBtn: document.getElementById('fullScreenAlertCloseBtn'),
        // No objeto 'elements'
        darkModeToggle: document.getElementById('darkModeToggle'),
        moonIcon: document.getElementById('moonIcon'),
        sunIcon: document.getElementById('sunIcon'),
        importFileInput: document.getElementById('importFileInput'),
        // ADDED: Floating Action Bar
        floatingActionBar: document.getElementById('floatingActionBar'),
    };
    const buttons = {
        generateIntroBtn: document.getElementById('generateIntroBtn'),
        generateDevelopmentBtn: document.getElementById('generateDevelopmentBtn'),
        generateClimaxBtn: document.getElementById('climaxBtn'),
        conclusionBtn: document.getElementById('conclusionBtn'),
        generateCTABtn: document.getElementById('generateCTABtn'),
        generateTitlesAndThumbnailsBtn: document.getElementById('generateTitlesAndThumbnailsBtn'),
        // generateImagePromptsBtn foi removido
        generateDescriptionBtn: document.getElementById('generateDescriptionBtn'),
        
        downloadPdfBtn: document.getElementById('downloadPdfBtn'),
        resetScriptBtn: document.getElementById('resetScriptBtn'),
        // No objeto 'buttons'
        analyzeStrategyBtn: document.getElementById('analyzeStrategyBtn'),
        exportProjectBtn: document.getElementById('exportProjectBtn'),
        importProjectBtn: document.getElementById('importProjectBtn'),
    };
    const buttonCheckmarkMap = {
        'generateIntroBtn': 'introCheck',
        'generateDevelopmentBtn': 'developmentCheck',
        'climaxBtn': 'climaxCheck',
        'conclusionBtn': 'conclusionCheck',
        'generateCTABtn': 'ctaCheck',
        'generateTitlesAndThumbnailsBtn': 'titlesThumbnailsCheck',
        // 'generateImagePromptsBtn': 'imagePromptsCheck' foi removido
        'generateDescriptionBtn': 'descriptionCheck'
    };

    // --- 3. FUNÇÕES DE UTILIDADE (DEFINIDAS PRIMEIRO) ---
    window.showToast = (message) => { elements.toastNotification.textContent = message; elements.toastNotification.classList.add('toast-visible'); setTimeout(() => { elements.toastNotification.classList.remove('toast-visible'); setTimeout(() => { elements.toastNotification.textContent = ''; }, 300); }, 3000); };
    window.copyTextToClipboard = async (text) => { try { await navigator.clipboard.writeText(text); window.showToast('Copiado!'); } catch (err) { const ta = document.createElement('textarea'); ta.value = text; ta.style.position = 'fixed'; ta.style.opacity = '0'; document.body.appendChild(ta); ta.focus(); ta.select(); try { document.execCommand('copy'); window.showToast('Copiado!'); } finally { document.body.removeChild(ta); } } };
    
    // **VILÃO 2 CORRIGIDO: showLoading com bloqueio total**
    const showLoading = (button) => {
        // Desabilitar TODOS os botões de geração para evitar rate limit
        Object.values(buttons).forEach(btn => { if(btn) btn.disabled = true; });
    
        const textSpan = button.querySelector('.button-text');
        const checkmarkSpan = button.querySelector('.completion-icon');
        const spinnerDiv = button.querySelector('.loading-spinner');

        if (textSpan) textSpan.classList.add('hidden');
        if (checkmarkSpan) checkmarkSpan.classList.add('hidden');
        if (spinnerDiv) spinnerDiv.classList.remove('hidden');
    };

    // **VILÃO 2 CORRIGIDO: hideLoading com reativação total**
    const hideLoading = (button) => {
        // Habilita TODOS os botões de geração novamente
        Object.values(buttons).forEach(btn => { if(btn) btn.disabled = false; });
        
        const spinnerDiv = button.querySelector('.loading-spinner');
        if (spinnerDiv) spinnerDiv.classList.add('hidden');
        
        const textSpan = button.querySelector('.button-text');
        if (textSpan) textSpan.classList.remove('hidden');

        const checkmarkSpan = button.querySelector('.completion-icon');
        if (checkmarkSpan && button.dataset.completed === 'true') {
            checkmarkSpan.classList.remove('hidden');
        }
        updateButtonStates(); // Chama a função centralizada para reavaliar o estado
    };
    
    // ==========================================================
    // VERSÕES FINAIS E SINCRONIZADAS DAS FUNÇÕES
    // ==========================================================
    // Popula a barra UMA VEZ, criando um link entre original e clone.
    window.populateActionBar = () => {
        const cloneAndAppend = (id, container) => {
            const original = document.getElementById(id);
            if (original) {
                const clone = original.cloneNode(true);
                clone.id = ''; // Remove o ID duplicado para evitar conflitos
                clone.dataset.cloneOf = id; // Adiciona um link: data-clone-of="generateIntroBtn"
                
                // Adiciona o listener de clique diretamente no clone
                clone.addEventListener('click', () => original.click());
                
                container.appendChild(clone);
            }
        };

        const mainButtonsContainer = document.querySelector('#mainActions .btn-clone-container');
        const quickButtonsContainer = document.querySelector('#quickActions .btn-clone-container');
        if (!mainButtonsContainer || !quickButtonsContainer) return;

        mainButtonsContainer.innerHTML = '';
        quickButtonsContainer.innerHTML = '';

        ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'].forEach(id => cloneAndAppend(id, mainButtonsContainer));
        ['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn', 'downloadPdfBtn', 'resetScriptBtn'].forEach(id => cloneAndAppend(id, quickButtonsContainer));
    };

    // Atualiza o original E o seu clone.
    const markButtonAsCompleted = (buttonId) => {
        const buttonsToUpdate = document.querySelectorAll(`#${buttonId}, [data-clone-of='${buttonId}']`);
        buttonsToUpdate.forEach(button => {
            if (button) {
                button.classList.remove('btn-primary', 'btn-secondary');
                button.classList.add('btn-success');
            }
        });
    };

    // Reseta o original E o seu clone.
    const resetCompletionIcons = () => {
        for (const buttonId in buttonCheckmarkMap) {
            const buttonsToUpdate = document.querySelectorAll(`#${buttonId}, [data-clone-of='${buttonId}']`);
            const passo1_buttons = ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'];
            const isPasso1 = passo1_buttons.includes(buttonId);

            buttonsToUpdate.forEach(button => {
                if (button) {
                    button.classList.remove('btn-success');
                    if (isPasso1) {
                        button.classList.add('btn-primary');
                    } else {
                        button.classList.add('btn-secondary');
                    }
                }
            });
        }
    };
    
    const showFullScreenAlert = (message) => { elements.fullScreenAlertMessage.textContent = message; elements.fullScreenAlertOverlay.classList.add('visible'); };
    const hideFullScreenAlert = () => { elements.fullScreenAlertOverlay.classList.remove('visible'); };
    const toggleCustomImageStyleVisibility = () => { elements.customImageStyleContainer.style.display = elements.imageStyleSelect.value === 'custom' ? 'block' : 'none'; };
    
    // ==========================================================
    // NOVA FUNÇÃO generateSectionHtmlContent (VERSÃO ACORDEÃO)
    // ==========================================================
    const generateSectionHtmlContent = (sectionId, title, content) => {
        // IDs únicos para o corpo do acordeão e o ícone de seta
        const bodyId = `${sectionId}Body`;
        const arrowId = `${sectionId}Arrow`;

        const regenerateBtnHtml = `<button class="regenerate-btn" onclick="event.stopPropagation(); window.regenerateSection('${sectionId}', '${title}', '${sectionId}')" title="Re-gerar esta seção">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
            </svg>
        </button>`;

        const copyBtnHtml = `<button class="copy-btn" onclick="event.stopPropagation(); copyTextToClipboard(document.getElementById('${bodyId}').querySelector('p').textContent)">Copiar</button>`;

        return `<div class="accordion-item">
                    <div class="accordion-header" onclick="toggleAccordion('${bodyId}', '${arrowId}')">
                        <div class="header-content">
                             <h3>${title}</h3>
                             <svg id="${arrowId}" class="accordion-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                             </svg>
                        </div>
                        <div class="header-buttons">
                            ${regenerateBtnHtml}
                            ${copyBtnHtml}
                        </div>
                    </div>
                    <div id="${bodyId}" class="accordion-body">
                        <p class="whitespace-pre-wrap" contenteditable="true">${content}</p>
                        <div class="section-prompts">
                            <button class="btn btn-secondary btn-small" onclick="window.generatePromptsForSection('${sectionId}Section')">
                                Gerar Prompts para esta Seção
                            </button>
                            <div class="prompt-container mt-4"></div>
                        </div>
                        <div class="section-soundtrack">
                            <button class="btn btn-secondary btn-small" onclick="window.suggestSoundtrack('${sectionId}Section')">
                                Sugerir Trilha Sonora
                            </button>
                            <div class="soundtrack-container mt-4"></div>
                        </div>
                    </div>
                </div>`;
    };

    // Arquivo: index.html - cleanGeneratedText VERSÃO 8 (CAÇADORA DE JSON)
    const cleanGeneratedText = (text, expectJson = false) => {
        if (!text) return null;

        if (expectJson) {
            console.log("Recebido para limpeza de JSON:", text);
            
            // Procura o início do JSON, seja ele um objeto '{' ou um array '['
            const startIndex = text.indexOf('{');
            const startBracket = text.indexOf('[');
            
            let jsonStartIndex = -1;

            if (startIndex > -1 && startBracket > -1) {
                // Se ambos existem, pega o que aparecer primeiro
                jsonStartIndex = Math.min(startIndex, startBracket);
            } else if (startIndex > -1) {
                jsonStartIndex = startIndex;
            } else {
                jsonStartIndex = startBracket;
            }

            if (jsonStartIndex === -1) {
                console.error("cleanGeneratedText: Não foi possível encontrar um início de JSON ('{' ou '[') na resposta.", text);
                return null;
            }

            // Pega o substring a partir do início do JSON encontrado
            const potentialJson = text.substring(jsonStartIndex);
            
            // Tenta encontrar o fechamento correspondente
            let jsonString = '';
            if (potentialJson.startsWith('{')) {
                const endIndex = potentialJson.lastIndexOf('}');
                jsonString = potentialJson.substring(0, endIndex + 1);
            } else {
                const endIndex = potentialJson.lastIndexOf(']');
                jsonString = potentialJson.substring(0, endIndex + 1);
            }
            
            console.log("Bloco JSON extraído:", jsonString);

            try {
                JSON.parse(jsonString); // Apenas para validar
                console.log("JSON extraído é válido.");
                return jsonString;
            } catch (e) {
                console.error("O JSON extraído é inválido.", e.message, jsonString);
                return null;
            }
        }
        
        return text.trim();
    };
    
    // --- 4. FUNÇÕES DE ESTADO E LÓGICA PRINCIPAL ---
    const isScriptComplete = () => { return ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'].every(id => !document.getElementById(id).classList.contains('hidden')); };

    const updateButtonStates = () => {
        // Força o reset antes de qualquer outra atualização
        resetCompletionIcons();

        const anyMainScriptGenerated = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection', 'ctaSection'].some(id => !document.getElementById(id).classList.contains('hidden'));
        const allMainScriptGenerated = isScriptComplete();
        
        buttons.generateDescriptionBtn.disabled = !allMainScriptGenerated;
        buttons.generateTitlesAndThumbnailsBtn.disabled = !allMainScriptGenerated;
        // buttons.generateImagePromptsBtn.disabled = !allMainScriptGenerated; // Removido

        // Verifica se há conteúdo gerado (script, títulos/thumbnails, ou prompts de imagem em qualquer seção)
        const hasAnyImagePrompts = Object.keys(allImagePrompts).length > 0 && Object.values(allImagePrompts).some(arr => arr.length > 0);
        const hasAnyContent = anyMainScriptGenerated || hasAnyImagePrompts || !!generatedTitlesAndThumbnails;
        buttons.downloadPdfBtn.disabled = !hasAnyContent;
        
        // O botão de reset agora pode ser sempre habilitado
        buttons.resetScriptBtn.disabled = false;

        // ADICIONADO: Atualiza os botões na barra flutuante
        // REMOVIDO: window.populateActionBar(); // Esta linha foi removida conforme a instrução.
    };
    
    const getBasePromptContext = () => {
        const channelName = elements.channelName.value.trim();
        const videoTheme = elements.videoTheme.value.trim();
        const targetAudience = elements.targetAudience.value.trim();
        const language = elements.languageSelect.value;
        const languageStyle = elements.languageStyle.value;
        const videoObjective = elements.videoObjective.value;
        const videoDuration = elements.videoDuration.value;
        const speakingPace = elements.speakingPace.value;
        const narrativeStyle = elements.narrativeStyle.value;
        const videoDescription = elements.videoDescription.value.trim();
        const centralQuestion = elements.centralQuestion.value.trim();
        const emotionalArc = elements.emotionalArc.value.trim();
        const viralElements = elements.viralElements.value.trim();
        const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
        const imageStyleSelect = elements.imageStyleSelect.value;
        const customImageStyle = elements.customImageStyle.value.trim();

        let context = `
        You are an expert YouTube scriptwriter for the channel "${channelName}".
        Your goal is to create highly engaging and viral video content.
        
        Video Theme: "${videoTheme}"
        Target Audience: "${targetAudience}"
        Language: "${language}"
        Language Style: "${languageStyle}"
        Video Objective: "${videoObjective}"
        Desired Duration: "${videoDuration}"
        Speaking Pace: "${speakingPace}"
        Narrative Style: "${narrativeStyle}"
        `;

        if (videoDescription) {
            context += `\nInspiration/Context: "${videoDescription}"`;
        }
        if (centralQuestion) {
            context += `\nCentral Question to guide the entire script: "${centralQuestion}"`;
        }
        if (emotionalArc) {
            context += `\nEmotional Arc: "${emotionalArc}"`;
        }
        if (viralElements) {
            context += `\nViral Elements to incorporate: "${viralElements}"`;
        }
        if (imageDescriptionEngine) {
            context += `\nImage Description Instructions: "${imageDescriptionEngine}"`;
        }
        
        if (imageStyleSelect === 'cinematic') {
            context += `\nImage Style: Cinematic film still, hyper-realistic, masterful cinematography. Shot on an Arri Alexa 65 with vintage anamorphic lenses. The composition is deliberate and powerful, using principles of photographic storytelling. Naturalistic and dramatic lighting. Strong use of light and shadow (chiaroscuro) to create depth and mood. Extreme attention to micro-details. Hyper-realistic textures are paramount: visible skin pores, fabric weaves, material imperfections. Rich, cinematic color grading. The overall mood is immersive, evocative, and deeply atmospheric.`;
        } else if (imageStyleSelect === 'custom' && customImageStyle) {
            context += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
        }

        return context;
    };

    const constructScriptPrompt = (sectionName, sectionTitle) => {
        const baseContext = getBasePromptContext();
        const videoDuration = elements.videoDuration.value;
        const selectedLanguage = elements.languageSelect.value;
        const narrativeStyle = elements.narrativeStyle.value;

        let prompt = `${baseContext}\n\nGenerate the **${sectionTitle}** section of the video script. Focus on making it highly engaging and suitable for a viral video. Ensure the tone and content align with the channel and audience.`;
        let maxTokens = 2000;

        prompt += `\n\nIMPORTANT: Do NOT include any scene descriptions, visual/audio cues (e.g., [SHOT], (Camera pan), (Music swells)), or speaker labels (e.g., "Narrator:", "Host:") in the generated script content. Provide only the spoken text.`;
        prompt += `\n\nABSOLUTELY NO META-COMMENTS. Do not add any explanatory text about the script itself. Your entire response must be ONLY the text to be spoken in the video, and nothing else.`;

        if (elements.centralQuestion.value.trim()) {
            prompt += `\nIf a 'Central Question' is provided, ensure every section of the script (Introduction, Development, Climax) directly contributes to exploring or answering this question. The entire video must revolve around this central theme.`;
        }

        switch (narrativeStyle) {
            case 'mystery_loop':
                prompt += `\n\nNARRATIVE STYLE: Use the 'Mystery/Open Loop' structure.
                - In the **Introduction**, present a compelling central question or mystery and promise the answer by the end.
                - In the **Development**, build suspense by exploring clues and theories, occasionally reminding the viewer of the central question.
                - In the **Climax**, deliver the satisfying answer to the question posed in the introduction.`;
                break;
            case 'pas':
                prompt += `\n\nNARRATIVE STYLE: Use the 'Problem-Agitate-Solution' structure.
                - Frame the **Introduction** around a clear 'Problem' that the audience can relate to.
                - Use the first part of the **Development** to 'Agitate' this problem, explaining its importance and complexity.
                - Frame the rest of the **Development** and the **Climax** as the 'Solution' or the revealing insight that addresses the initial problem.`;
                break;
            case 'twist':
                prompt += `\n\nNARRATIVE STYLE: Use the 'False Climax & Twist' structure.
                - In the **Development**, build evidence towards a seemingly obvious conclusion (the 'false climax').
                - In the **Climax**, introduce a surprising new piece of information or a counter-argument that completely changes the expected outcome (the 'twist').
                - The **Conclusion** should reflect on the implications of this new, unexpected truth.`;
                break;
            // ==========================================================
            // ========= ADICIONE ESTES DOIS NOVOS CASES AQUI =========
            // ==========================================================
            case 'heros_journey':
                prompt += `\n\nNARRATIVE STYLE: Use the 'Hero's Journey' structure.
                - **Introduction:** Present the 'Ordinary World' and the 'Call to Adventure'. Introduce the central character or concept.
                - **Development:** This is the 'Special World'. Describe the trials, allies, and enemies. Build the character's transformation through challenges.
                - **Climax:** The 'Ordeal' or the final battle. The moment of greatest tension and the hero's ultimate test.
                - **Conclusion:** The 'Return with the Elixir'. Show the resolution, what was learned, and how the 'Ordinary World' has changed because of the journey.`;
                break;

            case 'before_after_bridge':
                prompt += `\n\nNARRATIVE STYLE: Use the 'Before-After-Bridge' (BAB) structure.
                - **Introduction (Before):** Describe the 'Before' state. A world without the knowledge or solution you're about to present. Paint a picture of the problem or the lack of understanding.
                - **Development (After):** Describe the 'After' state. A desirable world where the problem is solved or the knowledge is revealed. Show the benefits and the ideal outcome.
                - **Climax & Conclusion (The Bridge):** Present your content as 'The Bridge'. Explain how your video's information is the exact path to get from the 'Before' state to the 'After' state. This is the solution, the 'how-to'.`;
                break;
            // ==========================================================
            // ==========================================================
        } // Fim do switch

        prompt += `\n\nIMPORTANT WRITING STYLE: Use the 'Show, Don't Tell' principle. Instead of stating facts plainly, use descriptive, evocative language to paint a picture in the viewer's mind. Create a sensory and visual experience through your words.`;

        switch (sectionName) {
            case 'intro':
                prompt += `
                The introduction should hook the viewer immediately, clearly state the video's intriguing question or mystery, and set the stage for what's to come. It must be captivating and create curiosity. For a "${videoDuration}" video, make this introduction appropriate in length and detail.
                `;
                if (narrativeStyle === 'direct') {
                    prompt += `\nThis is **Act 1** of the story. Your introduction should serve as the 'Inciting Incident', clearly presenting the central question or mystery that will drive the video. Establish the 'Normal World' of the topic before introducing the core conflict.`;
                }
                if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                    prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                }
                maxTokens = 500;
                break;
            case 'development':
                prompt += `
                The development section should delve into the core topic, presenting facts, arguments, and historical context. It should maintain a strong narrative flow, building suspense and providing compelling information. Break down complex ideas into easily digestible parts. For a "${videoDuration}" video, ensure this section is comprehensive but also flows well, adapting its length to the desired duration.
                `;
                if (narrativeStyle === 'direct') {
                    prompt += `\nThis is **Act 2** of the story. Your goal is to raise the stakes. Present compelling evidence but also introduce obstacles and counter-arguments. Build towards a major revelation or turning point (the Midpoint).`;
                }
                maxTokens = 1500;
                break;
            case 'climax':
                prompt += `
                The climax should be the most impactful part of the video, revealing key insights, surprising twists, or the most compelling evidence related to the video theme. It should be dramatic and leave the viewer with a sense of awe or profound understanding. For a "${videoDuration}" video, make this climax impactful and well-paced.
                `;
                if (narrativeStyle === 'direct') {
                    prompt += `\nThis is the peak of **Act 2**, leading into Act 3. Deliver the most impactful revelation or the resolution of the main conflict.`;
                }
                maxTokens = 500;
                break;
            case 'conclusion':
                prompt += `
                The conclusion should summarize the main points, provide a final thought or reflection, and leave the viewer with a lasting impression. Ensure the conclusion is complete and well-rounded, providing a sense of closure. For a "${videoDuration}" video, make this conclusion concise yet impactful.
                `;
                if (narrativeStyle === 'direct') {
                    prompt += `\nThis is **Act 3** of the story. Provide the final resolution and reflect on the implications of the video's journey.`;
                }
                if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                    prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                }
                maxTokens = 500;
                break;
            case 'cta':
                prompt += `
                The Call to Action (CTA) should be clear and concise, encouraging viewers to subscribe, like, comment, share, or engage with other content. Make it compelling and natural within the video's flow. For a "${videoDuration}" video, keep this CTA direct and effective.
                `;
                if (narrativeStyle === 'direct') {
                    prompt += `\nThis is the final part of **Act 3**. Ensure a strong and clear call to action that naturally concludes the video's narrative.`;
                }
                if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                    prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                }
                maxTokens = 200;
                break;
            case 'titles_thumbnails':
                prompt = `${baseContext}
Generate 5 highly clickable and viral YouTube video titles and 3 compelling thumbnail ideas.

IMPORTANT: Respond ONLY with a valid JSON object. Do not include any other text, preambles, or explanations outside of the JSON structure itself.

The JSON object must have two top-level keys:
1.  "titles": An array of strings.
2.  "thumbnails": An array of objects, where each object has a "title" (string) and a "description" (string) key.

The final output MUST be only the JSON code, like this example:
{
  "titles": [
    "The Shocking Truth About the Ark of the Covenant",
    "Was the Ark of the Covenant Finally Discovered?",
    "This Ancient Secret Could Change History Forever",
    "Biblical Mystery: The Ark's Final Location Revealed",
    "They Found It? The Search for the Lost Ark Ends Here"
  ],
  "thumbnails": [
    {
      "title": "FOUND?",
      "description": "A dramatic image of an ancient, glowing chest half-buried in a dark cave, with an astonished archaeologist looking on."
    },
    {
      "title": "TOP SECRET",
      "description": "A collage showing a faded ancient map, a secret biblical text, and a satellite image pointing to a location in Ethiopia."
    },
    {
      "title": "HISTORY CHANGED",
      "description": "A visually stunning image of the Ark of the Covenant radiating golden light inside a reconstructed Solomon's Temple."
    }
  ]
}
`;
                maxTokens = 800;
                break;
            case 'description':
                prompt = `${baseContext}\n\nGenerate a compelling YouTube video description (around 150-200 words) that summarizes the video, includes relevant keywords for SEO, and encourages engagement. Include a strong hook, a brief overview of the content, and a call to action. Also, suggest 10 relevant hashtags.
                Output format:
                Description:
                [Your description here]

                Hashtags:
                #hashtag1 #hashtag2 ...
                `;
                maxTokens = 700;
                break;
            default:
                maxTokens = 1000;
                break;
        }
        return { prompt, maxTokens };
    };

    // Arquivo: index.html - removeMetaComments VERSÃO 3 (Com RegEx)
    const removeMetaComments = (text) => {
        if (!text) return text;

        let cleanedText = text;

        // Padrão 1: Remove frases como "Here's the **Section** section..." ou "Here is a compelling..."
        // Esta RegEx procura por "Here's" ou "Here is", seguido por qualquer texto (.*?), 
        // até encontrar a primeira quebra de linha (\n). Ela remove a linha inteira.
        const introPattern = /^(Here's|Here is)\s.*?\n/gim;
        cleanedText = cleanedText.replace(introPattern, '');

        // Padrão 2: Remove linhas que são apenas títulos de seção, como "**Description:**" ou "**Hashtags:**"
        // se eles estiverem sozinhos em uma linha, mas mantém se tiverem texto depois.
        // O código atual já faz isso bem ao separar o conteúdo. Vamos refinar.
        // Esta limpeza pode ser feita no momento da exibição, mas vamos tentar aqui primeiro.
        // A lógica de extrair a descrição e hashtags separadamente pode ser mais robusta.

        // Por enquanto, o Padrão 1 é o mais crucial.
        
        return cleanedText.trim();
    };

    // VERSÃO 2 SEGURA da callGroqAPI
    const callGroqAPI = async (prompt, maxTokens) => {
        const proxyUrl = "/.netlify/functions/groq";

        // O payload agora NÃO inclui a chave da API
        const payload = {
            prompt: prompt,
            maxTokens: maxTokens
        };

        const request = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        };

        try {
            const response = await fetch(proxyUrl, request);
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: { message: 'Erro desconhecido do servidor proxy.' } }));
                throw new Error(`Erro na API via Proxy: ${errorData.error?.message || 'Erro do servidor'}`);
            }
            const result = await response.json();
            const rawContent = result.choices?.[0]?.message?.content;
            if (rawContent) { return rawContent; }
            else { throw new Error("Resposta inesperada da API Groq."); }
        } catch (error) {
            console.error("Fetch da API via Netlify Function falhou:", error);
            window.showToast(`Falha na API: ${error.message}`);
            throw error;
       }
    }

    const validateInputs = () => {
        if (!elements.channelName.value.trim()) {
            window.showToast("Por favor, insira o nome do canal.");
            return false;
        }
        if (!elements.videoTheme.value.trim()) {
            window.showToast("Por favor, insira o tema do vídeo.");
            return false;
        }
        if (!elements.videoDescription.value.trim()) {
            window.showToast("Por favor, insira a descrição do vídeo (para inspiração).");
            return false;
        }
        if (!elements.videoDuration.value || elements.videoDuration.value === "") {
            window.showToast("Por favor, selecione a Duração Desejada do vídeo.");
            return false;
        }
        // A validação de chaves da API é movida para getNextApiKey, mas ainda é importante ter um check
        // para garantir que o campo não está vazio se ele for visível.
        // Como o campo agora está oculto, esta validação pode ser removida ou adaptada se a lógica de chave for alterada.
        // Por enquanto, vamos manter a lógica de que getNextApiKey vai lançar um erro se não houver chaves.
        return true;
    };

    const getNextApiKey = () => {
        // Agora que o campo está oculto, as chaves podem vir de uma variável global ou ser gerenciadas pelo backend.
        // Para fins de demonstração, se o campo estiver vazio, ainda precisaremos de uma chave.
        // Se a intenção é que o proxy gerencie a chave, esta função pode se tornar mais simples ou ser removida.
        // Por enquanto, vamos simular que a chave é "disponível" para que o proxy possa ser chamado.
        // Em um cenário real, o proxy não precisaria de uma chave enviada do frontend.
        
        // Se a API key não é mais inserida pelo usuário, esta função pode ser simplificada
        // para retornar uma chave dummy ou ser removida se o proxy não precisar dela do frontend.
        // Para manter a compatibilidade com a estrutura existente, vamos retornar uma string não vazia.
        if (apiKeys.length === 0) {
            // Se o campo de input está oculto, as chaves não virão de lá.
            // Para que a chamada ao proxy funcione, precisamos de uma "chave" para que o `if (!apiKey)` não falhe.
            // Em produção, o proxy teria a chave real. Aqui, é um placeholder.
            apiKeys = [{ key: "dummy_key_for_proxy_validation", usageCount: 0 }];
        }

        let leastUsedKey = apiKeys[0];
        for (let i = 1; i < apiKeys.length; i++) {
            if (apiKeys[i].usageCount < leastUsedKey.usageCount) {
                leastUsedKey = apiKeys[i];
            }
        }
        leastUsedKey.usageCount++;
        return leastUsedKey.key;
    };
    
    const initializeFirebase = async () => {
        if (!firebaseConfig) {
            console.warn("Firebase config not found.");
            return;
        }
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    console.log("Firebase: User authenticated with UID:", userId);
                } else {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Firebase: Signed in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Firebase: Signed in anonymously.");
                        }
                        userId = auth.currentUser?.uid || crypto.randomUUID();
                    } catch (error) {
                        console.error("Firebase: Anonymous sign-in failed:", error);
                        userId = `local-${crypto.randomUUID()}`;
                    }
                }
                isAuthReady = true;
                elements.userIdDisplay.textContent = `User ID: ${userId.substring(0, 12)}...`;
                elements.userIdDisplay.classList.remove('hidden');
                
                updateButtonStates(); // Update button states after auth is ready
            });
        } catch (error) {
            console.error("Firebase init failed:", error);
            window.showToast("Erro ao inicializar Firebase. Verifique o console.");
        }
    };

    const handleGenerateSection = async (button, sectionName, sectionTitle, elementId) => {
        if (!validateInputs()) return;
        showLoading(button);
        try {
            const { prompt, maxTokens } = constructScriptPrompt(sectionName, sectionTitle);
            let result = await callGroqAPI(prompt, maxTokens);
            
            result = result.replace(/^Here's (?:the|a potential) \*\*[\w\s]+\*\* (?:section of the video script|for the video script):\s*\n*\s*$/gm, '');
            result = result.replace(/^(?:Host|Narrator)(?:\s*\(.*?\))?:\s*/gm, '');
            result = result.replace(/^\*\*[\w\s]+\*\*$/gm, '');
            result = result.replace(/^\s*(?:\*\*?\[.*?\]\*\*?|\(.*?\))\s*$/gm, '');
            result = result.replace(/^\s*[\r\n]+/gm, '');

            result = cleanGeneratedText(result, false);
            result = removeMetaComments(result);

            const targetSectionElement = document.getElementById(`${elementId}Section`);
            if (targetSectionElement) {
                targetSectionElement.innerHTML = generateSectionHtmlContent(elementId, sectionTitle, result);
                targetSectionElement.classList.remove('hidden');
            } else {
                console.error(`Target section element with ID '${elementId}Section' not found.`);
                window.showToast("Erro interno: Seção do roteiro não encontrada.");
                return;
            }
            
            markButtonAsCompleted(button.id);
            updateButtonStates(); // Update button states after a section is generated

        } catch (error) {
            window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
            console.error(`Error generating ${sectionTitle}.`, error);
        } finally {
            hideLoading(button);
        }
    };

    // NOVA FUNÇÃO para o botão "Re-gerar"
    window.regenerateSection = (sectionName, sectionTitle, elementId) => {
        const mainButtonIdMap = {
            'intro': 'generateIntroBtn',
            'development': 'generateDevelopmentBtn',
            'climax': 'climaxBtn',
            'conclusion': 'conclusionBtn',
            'cta': 'generateCTABtn'
        };
        const buttonId = mainButtonIdMap[sectionName];
        if (buttonId) {
            const button = document.getElementById(buttonId);
            handleGenerateSection(button, sectionName, sectionTitle, elementId);
        }
    };

    // =========================================================================
    // NOVA FUNÇÃO generatePromptsForSection (Substitui a antiga generateImagePrompts)
    // =========================================================================
    window.generatePromptsForSection = async (sectionElementId) => {
        const sectionElement = document.getElementById(sectionElementId);
        const scriptContentElement = sectionElement.querySelector('p[contenteditable="true"]');
        const promptContainer = sectionElement.querySelector('.prompt-container');
        
        if (!scriptContentElement || !scriptContentElement.textContent.trim()) {
            window.showToast("Por favor, gere o conteúdo do roteiro desta seção primeiro.");
            return;
        }

        const scriptContent = scriptContentElement.textContent;
        
        // Mostra um spinner
        promptContainer.innerHTML = `<div class="loading-spinner-small"></div>`; 

        const imageDescriptionEngine = elements.imageDescriptionEngine.value.trim();
        const imageStyleSelect = elements.imageStyleSelect.value;
        const customImageStyle = elements.customImageStyle.value.trim();
        let selectedStyleBlock = '';

        // Usamos uma versão adaptada do nosso prompt mestre
        let prompt = `Você é um diretor de vídeo. Sua tarefa é ler o trecho de roteiro a seguir e criar prompts de imagem.

**SUA REGRA MAIS IMPORTANTE é manter um ritmo dinâmico.** Não crie uma imagem para cada frase. O objetivo é criar um prompt a cada **15 a 25 segundos de narração**, aproximadamente. Isso significa que você deve LER várias frases, entender o tempo de narração e só então escolher o momento mais impactante DENTRO desse bloco de tempo para criar UM prompt.

**IMAGEM INICIAL INEGOCIÁVEL:** O primeiro prompt de imagem que você criar **DEVE OBRIGATORIAMENTE** corresponder à **PRIMEIRA FRASE COMPLETA** do trecho do roteiro. Sem exceções. O vídeo precisa de um impacto visual imediato.

Encontre os pontos de virada ou as imagens mentais mais fortes dentro desses intervalos de tempo.

Responda APENAS com um array JSON de objetos (com chaves "scriptPhrase" e "imageDescription").

Trecho do roteiro:
---${scriptContent}
---`;
        
        if (imageDescriptionEngine) {
            prompt += `\n\nAlso, ensure the image descriptions incorporate the following quality instructions: "${imageDescriptionEngine}"`;
        }

        if (imageStyleSelect === 'cinematic') {
            const cinematicPromptPart = `Apply a cinematic film still style to these image descriptions: hyper-realistic, masterful cinematography, Arri Alexa 65, vintage anamorphic lenses, deliberate composition, dramatic naturalistic lighting, strong chiaroscuro, extreme attention to micro-details, hyper-realistic textures (skin pores, fabric weaves, material imperfections), rich cinematic color grading, immersive and evocative mood. Avoid cgi, 3d, render, painting, illustration, animation, video game, digital art, cartoon.`;
            prompt += `\n\n${cinematicPromptPart}`;
            selectedStyleBlock = CINEMATIC_STYLE_BLOCK;
        } else if (imageStyleSelect === 'custom' && customImageStyle) {
            prompt += `\n\nApply the following custom image style to these image descriptions: ${customImageStyle}`;
            selectedStyleBlock = customImageStyle;
        }

        try {
            const rawResult = await callGroqAPI(prompt, 4000); // Aumentado para 4000 tokens para prompts de imagem
            const cleanedText = cleanGeneratedText(rawResult, true);
            let prompts = [];
            if (cleanedText) {
                try {
                    prompts = JSON.parse(cleanedText);
                    if (!Array.isArray(prompts)) {
                        console.warn("AI returned non-array JSON, attempting to convert.");
                        prompts = [prompts];
                    }
                } catch (e) {
                    window.showToast("Erro ao analisar JSON de prompts de imagem. Verifique o console.");
                    console.error("Erro ao analisar JSON de prompts de imagem:", e);
                    prompts = [];
                }
            } else {
                window.showToast("Erro: IA não retornou prompts ou o formato está incorreto para esta seção.");
            }

            // Armazena os prompts gerados na estrutura global
            let accumulatedTimeSeconds = 1; // Reinicia para cada seção para cálculo de tempo
            allImagePrompts[sectionElementId] = prompts.map((p, i) => {
                const time = accumulatedTimeSeconds;
                accumulatedTimeSeconds += 20; // Estimativa de 20s por cena
                const mins = Math.floor(time / 60);
                const secs = Math.floor(time % 60);
                return { 
                    ...p, 
                    time: `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`, 
                    sequence: String(i + 1).padStart(2, '0'),
                    styleBlock: selectedStyleBlock
                };
            });

            promptContainer.innerHTML = ''; // Limpa o spinner
            if (allImagePrompts[sectionElementId] && allImagePrompts[sectionElementId].length > 0) {
                allImagePrompts[sectionElementId].forEach(promptData => {
                    const styleBlockContent = promptData.styleBlock || '';
                    const promptHtml = `
                        <div class="individual-prompt-block">
                            <div class="flex items-center justify-between mb-2">
                                <p class="prompt-time">${promptData.time} - Cena ${promptData.sequence}</p>
                                <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${promptData.sequence}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${promptData.sequence}').textContent)">Copiar</button>
                            </div>
                            <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                            <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                            <p id="prompt-content-${sectionElementId}-${promptData.sequence}" class="prompt-description-content">${promptData.imageDescription}</p>
                            <pre id="style-block-${sectionElementId}-${promptData.sequence}" class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                        </div>
                    `;
                    promptContainer.innerHTML += promptHtml;
                });
            } else {
                promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta seção.</p>';
            }
            updateButtonStates(); // Atualiza o estado dos botões após gerar prompts
        } catch (error) {
            promptContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar prompts: ${error.message}</p>`;
            console.error(`Error generating prompts for section ${sectionElementId}.`, error);
        }
    };

    // ==========================================================
    // NOVA FUNÇÃO PARA SUGERIR TRILHA SONORA
    // ==========================================================
    window.suggestSoundtrack = async (sectionId) => {
        const sectionElement = document.getElementById(sectionId);
        const scriptContent = sectionElement.querySelector('p[contenteditable="true"]').textContent;
        const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
        
        if (!scriptContent) {
            window.showToast("Gere o roteiro para esta seção primeiro.");
            return;
        }

        soundtrackContainer.innerHTML = `<div class="loading-spinner-small"></div>`; // Mostra um spinner

        const prompt = `Você é um produtor musical e compositor de trilhas sonoras para filmes. Analise o tone, o ritmo e a emoção do seguinte trecho de roteiro.

Sua tarefa é criar 3 prompts de texto detalhados e prontos para serem usados em uma IA de geração de música (como Suno ou Udio). Cada prompt deve gerar uma trilha sonora instrumental única e de alta qualidade que combine com o roteiro.

Para cada um dos 3 prompts, inclua:
- O gênero/estilo (ex: cinematic, orchestral, ambient, electronic).
- O humor/emoção (ex: inspirational, tense, mysterious, melancholic, epic).
- Instrumentos chave (ex: solo piano, string section, taiko drums, synth pads).
- Influências de estilo (ex: Hans Zimmer style, Lo-fi chillhop, Two Steps from Hell).
- Instruções negativas (ex: no vocals, no saxophone).

Responda APENAS com um array JSON de strings, onde cada string é um prompt musical completo e detalhado.

Trecho do roteiro para analisar:
---
${scriptContent}
---`;
        
        try {
            const rawResult = await callGroqAPI(prompt, 500); // 500 tokens são suficientes
            const cleanedResult = cleanGeneratedText(rawResult, true);
            const suggestions = JSON.parse(cleanedResult);

            soundtrackContainer.innerHTML = ''; // Limpa o spinner
            if (suggestions && suggestions.length > 0) {
                let suggestionsHtml = '<ul class="soundtrack-list">';
                suggestions.forEach(suggestion => {
                    suggestionsHtml += `<li>${suggestion}</li>`;
                });
                suggestionsHtml += '</ul>';
                soundtrackContainer.innerHTML = suggestionsHtml;
            } else {
                soundtrackContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhuma sugestão de trilha sonora foi gerada.</p>';
            }
        } catch (error) {
            soundtrackContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugestões: ${error.message}</p>`;
        }
    };
    // ==========================================================

    // ==========================================================
    // RESTAURANDO A FUNÇÃO PERDIDA
    // ==========================================================
    const generateTitlesAndThumbnails = async () => {
        if (!validateInputs()) return;
        showLoading(buttons.generateTitlesAndThumbnailsBtn);
        try {
            const { prompt, maxTokens } = constructScriptPrompt('titles_thumbnails');
            let result = await callGroqAPI(prompt, maxTokens);
            let cleanedResult = cleanGeneratedText(result, true);
            let parsedContent = { titles: [], thumbnails: [] };
            try {
                if (cleanedResult) {
                    parsedContent = JSON.parse(cleanedResult);
                    generatedTitlesAndThumbnails = parsedContent;
                }
            } catch (e) {
                console.error("Falha ao analisar o JSON da IA:", e);
                console.error("Texto problemático:", cleanedResult);
                window.showToast("Erro: A IA retornou um formato de título/thumbnail inválido.");
                generatedTitlesAndThumbnails = null;
            }
            
            const targetSectionElement = document.getElementById('titlesThumbnailsSection');
            if (targetSectionElement) {
                let titlesListHtml = '<p class="text-red-500">Não foi possível extrair os títulos.</p>';
                if (parsedContent.titles && parsedContent.titles.length > 0) {
                    titlesListHtml = parsedContent.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                }
                
                let thumbnailsListHtml = '<p class="text-red-500">Não foi possível extrair as thumbnails.</p>';
                if (parsedContent.thumbnails && parsedContent.thumbnails.length > 0) {
                    thumbnailsListHtml = parsedContent.thumbnails.map((thumb, index) => {
                        const itemClasses = index === 0 ? '' : 'thumbnail-item-separator';
                        return `
                            <div class="${itemClasses}"> 
                                <p class="font-semibold text-gray-800 mb-0.5">"${thumb.title}"</p>
                                <p class="text-sm text-gray-600 leading-tight">Descrição: ${thumb.description}</p>
                            </div>
                        `;
                    }).join('\n');
                }
                
                // HTML COMPLETO COM O BOTÃO DE ANÁLISE
                const fullInnerHtml = `
                    <div class="whitespace-normal">
                        <div class="section-header">
                            <h3>Títulos e Thumbnails</h3>
                            <div class="header-buttons">
                                <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('titlesThumbnailsSection').textContent)">Copiar</button>
                            </div>
                        </div>
                        
                        <div class="mt-4 space-y-6">
                            <div>
                                <h4 class="font-bold text-lg text-gray-700 mb-2">Títulos de Vídeos:</h4>
                                <div class="p-3 border border-gray-200 rounded-md bg-white shadow-sm space-y-2">
                                    ${titlesListHtml}
                                </div>
                                <div class="mt-4">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeTitles()">
                                        Analisar Potencial de Clique (CTR)
                                    </button>
                                    <div id="ctrAnalysisResult" class="mt-4"></div>
                                </div>
                            </div>
                            <div>
                                <h4 class="font-bold text-lg text-gray-700 mb-2">Thumbnails:</h4>
                                <div class="p-3 border border-gray-200 rounded-md bg-white shadow-sm">${thumbnailsListHtml}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                targetSectionElement.innerHTML = fullInnerHtml;
                targetSectionElement.classList.remove('hidden');
                markButtonAsCompleted(buttons.generateTitlesAndThumbnailsBtn.id);
            }
            updateButtonStates();
        } catch (error) {
            window.showToast(`Falha ao gerar Títulos e Thumbnails: ${error.message}`);
            console.error(`Error generating Titles/Thumbnails.`, error);
        } finally {
            hideLoading(buttons.generateTitlesAndThumbnailsBtn);
        }
    };
    // ==========================================================

    // ==========================================================
    // COLE ESTA FUNÇÃO COMPLETA NO SEU JAVASCRIPT
    // ==========================================================
    window.analyzeTitles = async () => {
        if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.titles || generatedTitlesAndThumbnails.titles.length === 0) {
            window.showToast("Gere os títulos primeiro!");
            return;
        }

        const resultContainer = document.getElementById('ctrAnalysisResult');
        resultContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

        const titlesString = generatedTitlesAndThumbnails.titles.join('\n');
        
        const prompt = `Você é um especialista em marketing de conteúdo para o YouTube. Analise a seguinte lista de títulos de vídeo. Para cada um, forneça uma "nota de CTR" de 0 a 10 (onde 10 é um clique quase garantido) e uma sugestão curta e objetiva para melhorá-lo, focando em curiosidade, urgência e benefício claro.

        Responda APENAS com um array JSON. Cada objeto no array deve ter as chaves "titulo_original", "nota_ctr" e "sugestao_melhora".

        Títulos para analisar:
        ---
        ${titlesString}
        ---`;

        try {
            const rawResult = await callGroqAPI(prompt, 2000);
            const cleanedResult = cleanGeneratedText(rawResult, true);
            const analysis = JSON.parse(cleanedResult);

            let analysisHtml = '<div class="space-y-4">';
            analysis.forEach(item => {
                analysisHtml += `
                    <div class="p-3 border border-gray-200 rounded-md dark:border-gray-600">
                        <p class="font-semibold">${item.titulo_original}</p>
                        <p class="text-sm mt-1"><strong>Nota de CTR:</strong> <span class="text-indigo-500 font-bold">${item.nota_ctr} / 10</span></p>
                        <p class="text-sm mt-1"><strong>Sugestão:</strong> ${item.sugestao_melhora}</p>
                    </div>
                `;
            });
            analysisHtml += '</div>';
            resultContainer.innerHTML = analysisHtml;

        } catch (error) {
            resultContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao analisar os títulos: ${error.message}</p>`;
        }
    };
    // ==========================================================

    const generateVideoDescription = async () => {
        if (!validateInputs()) return;
        showLoading(buttons.generateDescriptionBtn);
        try {
            const { prompt, maxTokens } = constructScriptPrompt('description');
            let result = await callGroqAPI(prompt, maxTokens);
            result = cleanGeneratedText(result, false);
            result = removeMetaComments(result); // <-- ADICIONADO AQUI!
            const targetSectionElement = document.getElementById('videoDescriptionOutputSection');
            if (targetSectionElement) {
                targetSectionElement.innerHTML = generateSectionHtmlContent('videoDescriptionOutput', 'Descrição do Vídeo e Hashtags', result);
                targetSectionElement.classList.remove('hidden');
            } else {
                console.error("Target section element with ID 'videoDescriptionOutputSection' not found.");
                window.showToast("Erro interno: Seção de descrição não encontrada.");
                return;
            }
            markButtonAsCompleted(buttons.generateDescriptionBtn.id);
            updateButtonStates(); // Update button states after description is generated
        } catch (error) {
            window.showToast(`Falha ao gerar Descrição do Vídeo: ${error.message}`);
            console.error(`Error generating Video Description.`, error);
        } finally {
            hideLoading(buttons.generateDescriptionBtn);
        }
    };

    const saveScript = async () => {
        if (!isAuthReady) {
            window.showToast("Autenticação não pronta. Tente novamente em alguns segundos.");
            return;
        }
        if (!userId) {
            window.showToast("ID do usuário não disponível. Não é possível salvar.");
            return;
        }

        // showLoading(buttons.saveScriptBtn); // Este botão não existe mais, foi um erro.
        try {
            const scriptContentSections = [];
            const sectionIds = ['intro', 'development', 'climax', 'conclusion', 'cta'];
            sectionIds.forEach(id => {
                const sectionElement = document.getElementById(`${id}Section`);
                if (sectionElement && !sectionElement.classList.contains('hidden')) {
                    scriptContentSections.push({
                        title: sectionElement.querySelector('h3').textContent,
                        content: sectionElement.querySelector('p').textContent
                    });
                }
            });

            if (generatedTitlesAndThumbnails) {
                scriptContentSections.push({
                    title: "Títulos e Thumbnails",
                    content: generatedTitlesAndThumbnails
                });
            }

            const videoDescriptionSection = document.getElementById('videoDescriptionOutputSection');
            if (videoDescriptionSection && !videoDescriptionSection.classList.contains('hidden')) {
                scriptContentSections.push({
                    title: "Descrição do Vídeo e Hashtags",
                    content: videoDescriptionSection.querySelector('p').textContent
                });
            }

            const scriptData = {
                userId: userId,
                channelName: elements.channelName.value,
                videoTheme: elements.videoTheme.value,
                targetAudience: elements.targetAudience.value,
                language: elements.languageSelect.value,
                languageStyle: elements.languageStyle.value,
                videoObjective: elements.videoObjective.value,
                videoDuration: elements.videoDuration.value,
                speakingPace: elements.speakingPace.value,
                narrativeStyle: elements.narrativeStyle.value,
                videoDescription: elements.videoDescription.value,
                centralQuestion: elements.centralQuestion.value,
                emotionalArc: elements.emotionalArc.value,
                viralElements: elements.viralElements.value,
                imageDescriptionEngine: elements.imageDescriptionEngine.value,
                imageStyleSelect: elements.imageStyleSelect.value,
                customImageStyle: elements.customImageStyle.value,
                scriptContent: scriptContentSections,
                imagePrompts: allImagePrompts, // Agora é um objeto
                timestamp: serverTimestamp()
            };

            const docRef = doc(db, `artifacts/${appId}/users/${userId}/scripts`, 'latest');
            await setDoc(docRef, scriptData);
            window.showToast("Roteiro salvo com sucesso!");
        } catch (error) {
            console.error("Erro ao salvar roteiro:", error);
            window.showToast(`Falha ao salvar roteiro: ${error.message}`);
        } finally {
            // hideLoading(buttons.saveScriptBtn); // Este botão não existe mais.
        }
    };

    const downloadPdf = async () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        let y = 10;
        doc.setFontSize(22);
        doc.text("Roteiro Viral", 105, y, null, null, "center");
        y += 10;
        doc.setFontSize(12);
        doc.text(`Canal: ${elements.channelName.value}`, 10, y);
        y += 7;
        doc.text(`Tema: ${elements.videoTheme.value}`, 10, y);
        y += 10;

        const sectionOrder = ['intro', 'development', 'climax', 'conclusion', 'cta', 'videoDescriptionOutput', 'titlesThumbnails'];
        sectionOrder.forEach(id => {
            const sectionElement = document.getElementById(`${id}Section`);
            if (sectionElement && !sectionElement.classList.contains('hidden')) {
                const title = sectionElement.querySelector('h3').textContent;
                doc.setFontSize(16);
                doc.text(title, 10, y);
                y += 7;
                doc.setFontSize(12);

                if (id === 'titlesThumbnails') {
                    const titlesHtmlDiv = sectionElement.querySelector('.p-3:first-of-type');
                    if (titlesHtmlDiv) {
                        const titlesText = Array.from(titlesHtmlDiv.querySelectorAll('p')).map(p => p.textContent).join('\n');
                        const splitTitles = doc.splitTextToSize(`Títulos de Vídeos:\n${titlesText}`, 180);
                        doc.text(splitTitles, 10, y);
                        y += (splitTitles.length * 7) + 5;
                    }

                    const thumbnailsHtmlDiv = sectionElement.querySelector('.p-3:last-of-type');
                    if (thumbnailsHtmlDiv) {
                        const thumbnailsText = Array.from(thumbnailsHtmlDiv.querySelectorAll('div')).map(div => {
                            const thumbTitle = div.querySelector('p:first-of-type').textContent;
                            const thumbDesc = div.querySelector('p:last-of-type').textContent;
                            return `${thumbTitle}\n${thumbDesc}`;
                        }).join('\n\n');
                        const splitThumbnails = doc.splitTextToSize(`Thumbnails:\n${thumbnailsText}`, 180);
                        doc.text(splitThumbnails, 10, y);
                        y += (splitThumbnails.length * 7) + 5;
                    }
                } else {
                    const content = sectionElement.querySelector('.whitespace-normal p').textContent; // Target the p inside whitespace-normal
                    const splitContent = doc.splitTextToSize(content, 180);
                    doc.text(splitContent, 10, y);
                    y += (splitContent.length * 7) + 5;
                }

                if (y > 280) {
                    doc.addPage();
                    y = 10;
                }
            }
        });

        // Loop através das seções para adicionar os prompts de imagem
        for (const sectionId in allImagePrompts) {
            if (allImagePrompts.hasOwnProperty(sectionId) && allImagePrompts[sectionId].length > 0) {
                if (y > 250) {
                    doc.addPage();
                    y = 10;
                }
                const sectionTitleElement = document.getElementById(sectionId)?.querySelector('h3');
                const sectionTitle = sectionTitleElement ? sectionTitleElement.textContent : sectionId.replace('Section', '');

                doc.setFontSize(18);
                doc.text(`Prompts de Imagem para ${sectionTitle}`, 10, y);
                y += 10;
                doc.setFontSize(10);

                allImagePrompts[sectionId].forEach(promptData => {
                    const promptText = `${promptData.time} - Cena ${promptData.sequence}\nScript Phrase: ${promptData.scriptPhrase}\nImage Description: ${promptData.imageDescription}\n\n`;
                    const splitPrompt = doc.splitTextToSize(promptText, 180);
                    doc.text(splitPrompt, 10, y);
                    y += (splitPrompt.length * 5) + 3;

                    if (y > 280) {
                        doc.addPage();
                        y = 10;
                    }
                });
            }
        }

        doc.save(`${elements.videoTheme.value.replace(/[^a-zA-Z0-9]/g, '_')}_roteiro.pdf`);
        window.showToast("PDF gerado!");
    };

    const loadLatestScript = async () => {
        if (!isAuthReady) {
            window.showToast("Autenticação não pronta. Tente novamente em alguns segundos.");
            return;
        }
        if (!userId) {
            window.showToast("ID do usuário não disponível. Não é possível carregar.");
            return;
        }

        // showLoading(buttons.loadLatestScriptBtn); // Este botão não existe mais.
        try {
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/scripts`, 'latest');
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const latestScript = docSnap.data();
                
                // ========================================================
                // ================ CORREÇÃO APLICADA AQUI ================
                // ========================================================
                // Reseta completamente o estado da aplicação antes de carregar os novos dados.
                // Isso limpa a UI e, mais importante, reseta variáveis como 'allImagePrompts' e 'currentImagePromptIndex'.
                resetApplicationState();
                // ========================================================

                // Agora, preenchemos a UI limpa com os dados carregados.
                elements.channelName.value = latestScript.channelName || '';
                elements.videoTheme.value = latestScript.videoTheme || '';
                // ... (cole o resto do seu preenchimento de inputs aqui, pois já estava correto)
                elements.targetAudience.value = latestScript.targetAudience || '';
                elements.languageSelect.value = latestScript.language || 'en';
                elements.languageStyle.value = latestScript.languageStyle || 'inspirador';
                elements.videoObjective.value = latestScript.videoObjective || 'informar';
                elements.videoDuration.value = latestScript.videoDuration || '';
                elements.speakingPace.value = latestScript.speakingPace || 'moderate';
                elements.narrativeStyle.value = latestScript.narrativeStyle || 'direct';
                elements.videoDescription.value = latestScript.videoDescription || '';
                elements.centralQuestion.value = latestScript.centralQuestion || '';
                elements.emotionalArc.value = latestScript.emotionalArc.value || '';
                elements.viralElements.value = latestScript.viralElements.value || '';
                elements.imageDescriptionEngine.value = latestScript.imageDescriptionEngine || '';
                elements.imageStyleSelect.value = latestScript.imageStyleSelect || 'cinematic';
                elements.customImageStyle.value = latestScript.customImageStyle || '';
                toggleCustomImageStyleVisibility();


                if (latestScript.scriptContent && Array.isArray(latestScript.scriptContent)) {
                    latestScript.scriptContent.forEach(section => {
                        let elementId = '';
                        let sectionHtmlContent = '';

                        switch (section.title) {
                            case 'Introdução': elementId = 'intro'; sectionHtmlContent = generateSectionHtmlContent(elementId, section.title, section.content); break;
                            case 'Desenvolvimento': elementId = 'development'; sectionHtmlContent = generateSectionHtmlContent(elementId, section.title, section.content); break;
                            case 'Clímax': elementId = 'climax'; sectionHtmlContent = generateSectionHtmlContent(elementId, section.title, section.content); break;
                            case 'Conclusão': elementId = 'conclusion'; sectionHtmlContent = generateSectionHtmlContent(elementId, section.title, section.content); break;
                            case 'Chamada para Ação': elementId = 'cta'; sectionHtmlContent = generateSectionHtmlContent(elementId, section.title, section.content); break;
                            
                            case 'Títulos e Thumbnails':
                                elementId = 'titlesThumbnails';
                                generatedTitlesAndThumbnails = section.content;
                            
                                let titlesList = '<p class="text-red-500">Não foi possível carregar os títulos.</p>';
                                if (section.content.titles && section.content.titles.length > 0) {
                                    titlesList = section.content.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                                }
                                
                                let thumbnailsList = '<p class="text-red-500">Não foi possível carregar as thumbnails.</p>';
                                if (section.content.thumbnails && section.content.thumbnails.length > 0) {
                                    thumbnailsList = section.content.thumbnails.map((thumb, index) => {
                                        const itemClasses = index === 0 ? '' : 'thumbnail-item-separator';
                                        return `
                                            <div class="${itemClasses}">
                                                <p class="font-semibold text-gray-800 mb-0.5">"${thumb.title}"</p>
                                                <p class="text-sm text-gray-600 leading-tight">Descrição: ${thumb.description}</p>
                                            </div>
                                        `;
                                    }).join('\n');
                                }
                                
                                sectionHtmlContent = `
                                    <div class="whitespace-normal">
                                        <h3>${section.title}</h3>
                                        <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('titlesThumbnailsSection').textContent)">Copiar</button>
                                        <div class="mt-4 space-y-6">
                                            <div>
                                                <h4 class="font-bold text-lg text-gray-700 mb-2">Títulos de Vídeos:</h4>
                                                <div class="p-3 border border-gray-200 rounded-md bg-white shadow-sm space-y-2">${titlesList}</div>
                                            </div>
                                            <div>
                                                <h4 class="font-bold text-lg text-gray-700 mb-2">Thumbnails:</h4>
                                                <div class="p-3 border border-gray-200 rounded-md bg-white shadow-sm">${thumbnailsList}</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                                break;

                            case 'Descrição do Vídeo e Hashtags': elementId = 'videoDescriptionOutput'; sectionHtmlContent = generateSectionHtmlContent(elementId, section.title, section.content); break;
                            default: console.warn(`Unknown section title loaded: ${section.title}`); return;
                        }

                        const targetSectionElement = document.getElementById(`${elementId}Section`);
                        if (targetSectionElement) {
                            targetSectionElement.innerHTML = sectionHtmlContent;
                            targetSectionElement.classList.remove('hidden');
                            switch (elementId) {
                                case 'intro': markButtonAsCompleted('generateIntroBtn'); break;
                                case 'development': markButtonAsCompleted('generateDevelopmentBtn'); break;
                                case 'climax': markButtonAsCompleted('climaxBtn'); break;
                                case 'conclusion': markButtonAsCompleted('conclusionBtn'); break;
                                case 'cta': markButtonAsCompleted('generateCTABtn'); break;
                                case 'titlesThumbnails': markButtonAsCompleted('generateTitlesAndThumbnailsBtn'); break;
                                case 'videoDescriptionOutput': markButtonAsCompleted('generateDescriptionBtn'); break;
                            }
                        }
                    });
                }
                
                // Carrega os prompts de imagem salvos
                allImagePrompts = latestScript.imagePrompts || {};
                for (const sectionId in allImagePrompts) {
                    if (allImagePrompts.hasOwnProperty(sectionId) && allImagePrompts[sectionId].length > 0) {
                        const sectionElement = document.getElementById(sectionId);
                        if (sectionElement) {
                            const promptContainer = sectionElement.querySelector('.prompt-container');
                            if (promptContainer) {
                                promptContainer.innerHTML = ''; // Limpa o container antes de popular
                                allImagePrompts[sectionId].forEach(promptData => {
                                    const styleBlockContent = promptData.styleBlock || '';
                                    const promptHtml = `
                                        <div class="individual-prompt-block">
                                            <div class="flex items-center justify-between mb-2">
                                                <p class="prompt-time">${promptData.time} - Cena ${promptData.sequence}</p>
                                                <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionId}-${promptData.sequence}').textContent + ' ' + document.getElementById('style-block-${sectionId}-${promptData.sequence}').textContent)">Copiar</button>
                                            </div>
                                            <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                                            <p class="prompt-description-label">${imageDescriptionLabels[latestScript.language] || 'Image Description:'}</p>
                                            <p id="prompt-content-${sectionId}-${promptData.sequence}" class="prompt-description-content">${promptData.imageDescription}</p>
                                            <pre id="style-block-${sectionId}-${promptData.sequence}" class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                                        </div>
                                    `;
                                    promptContainer.innerHTML += promptHtml;
                                });
                            }
                        }
                    }
                }
                // Não há mais um botão global de prompts de imagem para marcar como completo
                // markButtonAsCompleted('generateImagePromptsBtn'); 
                
                updateButtonStates(); // Habilita/desabilita botões de suporte após carregar o script

                window.showToast("Último roteiro carregado!");
            } else {
                window.showToast("Nenhum roteiro salvo encontrado.");
                resetCompletionIcons(); // Atualiza o estado dos botões mesmo que nenhum script seja encontrado
                updateButtonStates(); // Atualiza o estado dos botões mesmo que nenhum script seja encontrado
            }
        } catch (error) {
            console.error("Erro ao carregar roteiro:", error);
            window.showToast(`Falha ao carregar roteiro: ${error.message}`);
        } finally {
            // hideLoading(buttons.loadLatestScriptBtn); // Este botão não existe mais.
        }
    };
    
    const resetApplicationState = () => {
        elements.videoTheme.value = '';
        elements.videoDescription.value = '';
        elements.centralQuestion.value = '';
        elements.emotionalArc.value = '';
        elements.viralElements.value = '';
        elements.imageDescriptionEngine.value = '';
        elements.imageStyleSelect.value = 'cinematic';
        elements.customImageStyle.value = '';
        toggleCustomImageStyleVisibility();
        elements.narrativeStyle.value = 'direct';
        elements.videoDuration.value = '';

        document.querySelectorAll('#scriptOutput > .script-section').forEach(sec => {
            sec.innerHTML = '';
            sec.classList.add('hidden');
        });
        // elements.imagePromptsList.innerHTML = ''; // Removido
        // elements.imagePromptsOutput.classList.add('hidden'); // Removido

        // Limpa os prompts de imagem de todas as seções
        allImagePrompts = {}; 
        // currentImagePromptIndex e loadMoreImagePromptsBtn não são mais relevantes
        // elements.loadMoreImagePromptsBtn.style.display = 'none'; 
        generatedTitlesAndThumbnails = null;
        
        apiKeys.forEach(keyObj => keyObj.usageCount = 0);

        resetCompletionIcons();
        updateButtonStates(); // **CORREÇÃO: Chamar updateButtonStates aqui**

        window.showToast("Pronto para um novo roteiro!");
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

    // ==========================================================
    // ======== NOVAS FUNÇÕES DE EXPORTAR E IMPORTAR ========
    // ==========================================================
    const exportProject = () => {
        const projectData = {
            // Salva o estado dos inputs
            inputs: {},
            // Salva o conteúdo gerado
            outputs: {
                introSection: document.getElementById('introSection').innerHTML,
                developmentSection: document.getElementById('developmentSection').innerHTML,
                climaxSection: document.getElementById('climaxSection').innerHTML,
                conclusionSection: document.getElementById('conclusionSection').innerHTML,
                ctaSection: document.getElementById('ctaSection').innerHTML,
                videoDescriptionOutputSection: document.getElementById('videoDescriptionOutputSection').innerHTML,
                titlesThumbnailsSection: document.getElementById('titlesThumbnailsSection').innerHTML,
            },
            // Salva as variáveis de memória
            memory: {
                allImagePrompts: allImagePrompts,
                generatedTitlesAndThumbnails: generatedTitlesAndThumbnails
            }
        };

        // Preenche o objeto de inputs
        for (const key in elements) {
            if (elements[key] && typeof elements[key].value !== 'undefined') {
                projectData.inputs[key] = elements[key].value;
            }
        }
        
        // Converte para JSON e cria o arquivo para download
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        const fileName = elements.videoTheme.value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro_viral';
        downloadAnchorNode.setAttribute("download", `${fileName}_projeto.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
        window.showToast("Projeto exportado com sucesso!");
    };

    const renderImagePromptsForSection = (sectionElementId) => {
        const promptContainer = document.getElementById(sectionElementId)?.querySelector('.prompt-container');
        if (!promptContainer) return;

        promptContainer.innerHTML = ''; // Clear existing prompts

        const promptsData = allImagePrompts[sectionElementId];
        if (promptsData && promptsData.length > 0) {
            promptsData.forEach(promptData => {
                const styleBlockContent = promptData.styleBlock || '';
                const promptHtml = `
                    <div class="individual-prompt-block">
                        <div class="flex items-center justify-between mb-2">
                            <p class="prompt-time">${promptData.time} - Cena ${promptData.sequence}</p>
                            <button class="copy-btn" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${promptData.sequence}').textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${promptData.sequence}').textContent)">Copiar</button>
                        </div>
                        <p class="prompt-phrase">${promptData.scriptPhrase}</p>
                        <p class="prompt-description-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                        <p id="prompt-content-${sectionElementId}-${promptData.sequence}" class="prompt-description-content">${promptData.imageDescription}</p>
                        <pre id="style-block-${sectionElementId}-${promptData.sequence}" class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md overflow-auto">${styleBlockContent}</pre>
                    </div>
                `;
                promptContainer.innerHTML += promptHtml;
            });
        } else {
            promptContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhum prompt gerado para esta seção.</p>';
        }
    };

    const importProject = (event) => {
        const file = event.target.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const projectData = JSON.parse(e.target.result);
                
                resetApplicationState(); // Limpa o estado atual antes de importar

                // Restaura os inputs
                for (const key in elements) {
                    if (elements[key] && typeof elements[key].value !== 'undefined') {
                        elements[key].value = projectData.inputs[key];
                    }
                }

                // Restaura o conteúdo gerado
                for (const key in projectData.outputs) {
                    const element = document.getElementById(key);
                    if (element && projectData.outputs[key]) {
                        element.innerHTML = projectData.outputs[key];
                        element.classList.remove('hidden');
                    }
                }

                // Restaura as variáveis de memória
                allImagePrompts = projectData.memory.allImagePrompts || {}; // Ensure it's an object
                generatedTitlesAndThumbnails = projectData.memory.generatedTitlesAndThumbnails || null;

                // Atualiza a interface para refletir o estado carregado
                updateButtonStates();
                
                // Marca os botões como concluídos se o conteúdo existir
                if (document.getElementById('introSection').innerHTML.trim()) markButtonAsCompleted('generateIntroBtn');
                if (document.getElementById('developmentSection').innerHTML.trim()) markButtonAsCompleted('generateDevelopmentBtn');
                if (document.getElementById('climaxSection').innerHTML.trim()) markButtonAsCompleted('climaxBtn');
                if (document.getElementById('conclusionSection').innerHTML.trim()) markButtonAsCompleted('conclusionBtn');
                if (document.getElementById('ctaSection').innerHTML.trim()) markButtonAsCompleted('generateCTABtn');
                if (document.getElementById('videoDescriptionOutputSection').innerHTML.trim()) markButtonAsCompleted('generateDescriptionBtn');
                if (document.getElementById('titlesThumbnailsSection').innerHTML.trim()) markButtonAsCompleted('generateTitlesAndThumbnailsBtn');

                // Re-renderiza os prompts de imagem para todas as seções
                for (const sectionId in allImagePrompts) {
                    if (allImagePrompts.hasOwnProperty(sectionId)) {
                        renderImagePromptsForSection(sectionId);
                    }
                }

                window.showToast("Projeto importado com sucesso!");

            } catch (err) {
                window.showToast("Erro: Arquivo de projeto inválido ou corrompido.");
                console.error("Erro ao importar projeto:", err);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Limpa o input para permitir importar o mesmo arquivo novamente
    };
    // ==========================================================

    // --- 5. SETUP DE EVENT LISTENERS (Definidos por último) ---
    const setupButtonListeners = () => {
        if (buttons.generateIntroBtn) buttons.generateIntroBtn.addEventListener('click', () => handleGenerateSection(buttons.generateIntroBtn, 'intro', 'Introdução', 'intro'));
        if (buttons.generateDevelopmentBtn) buttons.generateDevelopmentBtn.addEventListener('click', () => handleGenerateSection(buttons.generateDevelopmentBtn, 'development', 'Desenvolvimento', 'development'));
        if (buttons.climaxBtn) buttons.climaxBtn.addEventListener('click', () => handleGenerateSection(buttons.climaxBtn, 'climax', 'Clímax', 'climax'));
        if (buttons.conclusionBtn) buttons.conclusionBtn.addEventListener('click', () => handleGenerateSection(buttons.conclusionBtn, 'conclusion', 'Conclusão', 'conclusion'));
        if (buttons.generateCTABtn) buttons.generateCTABtn.addEventListener('click', () => handleGenerateSection(buttons.generateCTABtn, 'cta', 'Chamada para Ação', 'cta'));
        if (buttons.generateTitlesAndThumbnailsBtn) buttons.generateTitlesAndThumbnailsBtn.addEventListener('click', generateTitlesAndThumbnails);
        // if (buttons.generateImagePromptsBtn) buttons.generateImagePromptsBtn.addEventListener('click', () => generateImagePrompts(buttons.generateImagePromptsBtn)); // Removido
        // if (elements.loadMoreImagePromptsBtn) elements.loadMoreImagePromptsBtn.addEventListener('click', displayImagePromptsBatch); // Removido
        if (buttons.generateDescriptionBtn) buttons.generateDescriptionBtn.addEventListener('click', generateVideoDescription);
        if (elements.fullScreenAlertCloseBtn) elements.fullScreenAlertCloseBtn.addEventListener('click', hideFullScreenAlert);
        if (elements.imageStyleSelect) elements.imageStyleSelect.addEventListener('change', toggleCustomImageStyleVisibility);
        
        // As linhas abaixo foram removidas conforme sua solicitação
        // if (buttons.saveScriptBtn) buttons.saveScriptBtn.addEventListener('click', saveScript);
        // if (buttons.loadLatestScriptBtn) elements.loadLatestScriptBtn.addEventListener('click', loadLatestScript);
        
        if (buttons.downloadPdfBtn) buttons.downloadPdfBtn.addEventListener('click', downloadPdf);
        if (buttons.resetScriptBtn) buttons.resetScriptBtn.addEventListener('click', resetApplicationState);

        // Dentro de setupButtonListeners
        if (elements.darkModeToggle) {
            elements.darkModeToggle.addEventListener('click', () => {
                const isDarkMode = document.body.classList.contains('dark');
                setDarkMode(!isDarkMode);
            });
        }
        // Conectar o novo botão à função
        if (buttons.analyzeStrategyBtn) buttons.analyzeStrategyBtn.addEventListener('click', analyzeAndSetStrategy);

        // Lógica de Importação - Garantia de Funcionamento
        const importBtn = document.getElementById('importProjectBtn');
        const fileInput = document.getElementById('importFileInput');
        if (importBtn && fileInput) {
            importBtn.addEventListener('click', () => {
                console.log("Botão de Importar Clicado!"); // Para depuração
                fileInput.click();
            });
            fileInput.addEventListener('change', importProject);
        }
    };

    // NOVA FUNÇÃO para análise estratégica
    const analyzeAndSetStrategy = async () => {
        const theme = elements.videoTheme.value.trim();
        const description = elements.videoDescription.value.trim();

        if (!theme || !description) {
            window.showToast("Por favor, preencha o Tema e a Descrição do Vídeo.");
            return;
        }

        const button = buttons.analyzeStrategyBtn;
        showLoading(button);

        // Opções válidas para cada campo (precisamos disso para a IA)
        const languageStyleOptions = Array.from(elements.languageStyle.options).map(o => o.value).join(', ');
        const videoObjectiveOptions = Array.from(elements.videoObjective.options).map(o => o.value).join(', ');
        const narrativeStyleOptions = Array.from(elements.narrativeStyle.options).map(o => o.value).join(', ');

        const prompt = `Você é um Estrategista de Conteúdo de IA para o YouTube. Sua tarefa é analisar o tema e a descrição de um vídeo e definir a melhor estratégia de conteúdo para ele.

        Tema do Vídeo: "${theme}"
        Descrição do Vídeo: "${description}"

        Com base nisso, preencha os seguintes campos. Responda APENAS com um objeto JSON válido.

        O objeto JSON deve ter as seguintes chaves:
        1.  "target_audience": (string) Descreva em uma frase o público-alvo ideal para este vídeo.
        2.  "language_style": (string) Escolha o melhor estilo de linguagem da seguinte lista: [${languageStyleOptions}].
        3.  "video_objective": (string) Escolha o objetivo principal do vídeo da seguinte lista: [${videoObjectiveOptions}].
        4.  "narrative_style": (string) Escolha a estrutura narrativa mais impactante da seguinte lista: [${narrativeStyleOptions}].
        5.  "central_question": (string) Formule a pergunta central mais intrigante que o vídeo deve responder.
        6.  "emotional_arc": (string) Descreva o arco emocional ideal em uma frase curta (Ex: Curiosidade -> Tensão -> Revelação -> Inspiração).

        Analise profundamente o tema e a descrição para fazer as escolhas mais coesas e eficazes.`;

        try {
            const rawResult = await callGroqAPI(prompt, 1000);
            const cleanedResult = cleanGeneratedText(rawResult, true);
            const strategy = JSON.parse(cleanedResult);

            // Preenche os campos da interface com a resposta da IA
            if(strategy.target_audience) elements.targetAudience.value = strategy.target_audience;
            if(strategy.language_style) elements.languageStyle.value = strategy.language_style;
            if(strategy.video_objective) elements.videoObjective.value = strategy.video_objective;
            if(strategy.narrative_style) elements.narrativeStyle.value = strategy.narrativeStyle;
            if(strategy.central_question) elements.centralQuestion.value = strategy.central_question;
            if(strategy.emotional_arc) elements.emotionalArc.value = strategy.emotional_arc;

            window.showToast("Estratégia definida com sucesso!");

        } catch (error) {
            window.showToast(`Falha ao definir estratégia: ${error.message}`);
            console.error("Erro na análise estratégica:", error);
        } finally {
            hideLoading(button);
        }
    };

    const setDarkMode = (isDark) => {
        if (isDark) {
            document.body.classList.add('dark');
            elements.moonIcon.classList.add('hidden');
            elements.sunIcon.classList.remove('hidden');
            localStorage.setItem('darkMode', 'enabled');
        } else {
            document.body.classList.remove('dark');
            elements.moonIcon.classList.remove('hidden');
            elements.sunIcon.classList.add('hidden');
            localStorage.setItem('darkMode', 'disabled');
        }
    };

    // ===============================================
    // AS NOVAS FUNÇÕES QUE ADICIONAMOS
    // ===============================================
    // VERSÃO FINAL do populateActionBar
    window.populateActionBar = () => {
        const cloneAndAppend = (id, container) => {
            const original = document.getElementById(id);
            if (original) {
                const clone = original.cloneNode(true);
                clone.id = ''; // Remove o ID duplicado para evitar conflitos
                clone.dataset.cloneOf = id; // Adiciona um link: data-clone-of="generateIntroBtn"
                
                // Adiciona o listener de clique diretamente no clone
                clone.addEventListener('click', () => original.click());
                
                container.appendChild(clone);
            }
        };

        const mainButtonsContainer = document.querySelector('#mainActions .btn-clone-container');
        const quickButtonsContainer = document.querySelector('#quickActions .btn-clone-container');
        if (!mainButtonsContainer || !quickButtonsContainer) return;

        mainButtonsContainer.innerHTML = '';
        quickButtonsContainer.innerHTML = '';

        ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'].forEach(id => cloneAndAppend(id, mainButtonsContainer));
        ['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn', 'downloadPdfBtn', 'resetScriptBtn'].forEach(id => cloneAndAppend(id, quickButtonsContainer));
    };

    // VERSÃO CONTEXTUAL do handleFloatingActionBar
    window.handleFloatingActionBar = () => {
        const mainActions = document.getElementById('mainActions');
        const quickActions = document.getElementById('quickActions');
        const scriptOutput = document.getElementById('scriptOutput');
        
        if (!scriptOutput) return;

        const actionBar = elements.floatingActionBar;
        const triggerPoint = scriptOutput.offsetTop - actionBar.offsetHeight;

        if (window.scrollY > triggerPoint) {
            // Se rolou para a área de resultados, mostra a barra (se já não estiver visível)
            actionBar.classList.add('visible');
            // e mostra as Ações Rápidas
            mainActions.classList.add('hidden');
            quickActions.classList.remove('hidden');
        } else if (window.scrollY > 150) { // Um pequeno buffer para não aparecer imediatamente
            // Se rolou um pouco, mas não chegou nos resultados, mostra a barra com as Ações Principais
            actionBar.classList.add('visible');
            mainActions.classList.remove('hidden');
            quickActions.classList.add('hidden');
        } else {
            // Se está no topo, esconde a barra
            actionBar.classList.remove('visible');
        }
    };
    // ===============================================

    // NOVA FUNÇÃO para controlar o acordeão
    window.toggleAccordion = (bodyId, arrowId) => {
        const body = document.getElementById(bodyId);
        const arrow = document.getElementById(arrowId);
        if (body && arrow) {
            body.classList.toggle('open');
            arrow.classList.toggle('open');
        }
    };

    // --- 6. PONTO DE ENTRADA DA APLICAÇÃO ---
    // O bloco de inicialização agora vem por último, garantindo que todas as funções sejam definidas.
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Content Loaded. Initializing app."); 
        
	// Comentando para desativar, já que não estamos usando Firebase
	// initializeFirebase();
        
	setupButtonListeners(); // Agora é seguro chamar
        populateActionBar(); // Chama UMA VEZ para criar os clones.
        updateButtonStates(); // Define o estado inicial dos botões.

        // Dentro de DOMContentLoaded
        if (localStorage.getItem('darkMode') === 'enabled') {
            setDarkMode(true);
        }
        // LÓGICA DA BARRA FLUTUANTE
        window.addEventListener('scroll', window.handleFloatingActionBar); // Updated call
    });
    </script>
</body>
</html>
